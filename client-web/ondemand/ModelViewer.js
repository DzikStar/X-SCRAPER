"use strict";
(self.webpackChunk_twitter_responsive_web = self.webpackChunk_twitter_responsive_web || []).push([
    ["ondemand.ModelViewer"],
    {
        524462: (t, e, i) => {
            i.r(e), i.d(e, { ModelViewerElement: () => fv });
            var n = i(348834).Buffer;
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */ const s = "undefined" != typeof window && null != window.customElements && void 0 !== window.customElements.polyfillWrapFlushCallback,
                r = (t, e, i = null) => {
                    for (; e !== i; ) {
                        const i = e.nextSibling;
                        t.removeChild(e), (e = i);
                    }
                },
                a = `{{lit-${String(Math.random()).slice(2)}}}`,
                o = `\x3c!--${a}--\x3e`,
                l = new RegExp(`${a}|${o}`);
            class c {
                constructor(t, e) {
                    (this.parts = []), (this.element = e);
                    const i = [],
                        n = [],
                        s = document.createTreeWalker(e.content, 133, null, !1);
                    let r = 0,
                        o = -1,
                        c = 0;
                    const {
                        strings: u,
                        values: { length: A },
                    } = t;
                    for (; c < A; ) {
                        const t = s.nextNode();
                        if (null !== t) {
                            if ((o++, 1 === t.nodeType)) {
                                if (t.hasAttributes()) {
                                    const e = t.attributes,
                                        { length: i } = e;
                                    let n = 0;
                                    for (let t = 0; t < i; t++) h(e[t].name, "$lit$") && n++;
                                    for (; n-- > 0; ) {
                                        const e = u[c],
                                            i = p.exec(e)[2],
                                            n = i.toLowerCase() + "$lit$",
                                            s = t.getAttribute(n);
                                        t.removeAttribute(n);
                                        const r = s.split(l);
                                        this.parts.push({ type: "attribute", index: o, name: i, strings: r }), (c += r.length - 1);
                                    }
                                }
                                "TEMPLATE" === t.tagName && (n.push(t), (s.currentNode = t.content));
                            } else if (3 === t.nodeType) {
                                const e = t.data;
                                if (e.indexOf(a) >= 0) {
                                    const n = t.parentNode,
                                        s = e.split(l),
                                        r = s.length - 1;
                                    for (let e = 0; e < r; e++) {
                                        let i,
                                            r = s[e];
                                        if ("" === r) i = d();
                                        else {
                                            const t = p.exec(r);
                                            null !== t && h(t[2], "$lit$") && (r = r.slice(0, t.index) + t[1] + t[2].slice(0, -5) + t[3]), (i = document.createTextNode(r));
                                        }
                                        n.insertBefore(i, t), this.parts.push({ type: "node", index: ++o });
                                    }
                                    "" === s[r] ? (n.insertBefore(d(), t), i.push(t)) : (t.data = s[r]), (c += r);
                                }
                            } else if (8 === t.nodeType)
                                if (t.data === a) {
                                    const e = t.parentNode;
                                    (null !== t.previousSibling && o !== r) || (o++, e.insertBefore(d(), t)), (r = o), this.parts.push({ type: "node", index: o }), null === t.nextSibling ? (t.data = "") : (i.push(t), o--), c++;
                                } else {
                                    let e = -1;
                                    for (; -1 !== (e = t.data.indexOf(a, e + 1)); ) this.parts.push({ type: "node", index: -1 }), c++;
                                }
                        } else s.currentNode = n.pop();
                    }
                    for (const t of i) t.parentNode.removeChild(t);
                }
            }
            const h = (t, e) => {
                    const i = t.length - e.length;
                    return i >= 0 && t.slice(i) === e;
                },
                u = (t) => -1 !== t.index,
                d = () => document.createComment(""),
                p = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;
            function A(t, e) {
                const {
                        element: { content: i },
                        parts: n,
                    } = t,
                    s = document.createTreeWalker(i, 133, null, !1);
                let r = m(n),
                    a = n[r],
                    o = -1,
                    l = 0;
                const c = [];
                let h = null;
                for (; s.nextNode(); ) {
                    o++;
                    const t = s.currentNode;
                    for (t.previousSibling === h && (h = null), e.has(t) && (c.push(t), null === h && (h = t)), null !== h && l++; void 0 !== a && a.index === o; ) (a.index = null !== h ? -1 : a.index - l), (r = m(n, r)), (a = n[r]);
                }
                c.forEach((t) => t.parentNode.removeChild(t));
            }
            const g = (t) => {
                    let e = 11 === t.nodeType ? 0 : 1;
                    const i = document.createTreeWalker(t, 133, null, !1);
                    for (; i.nextNode(); ) e++;
                    return e;
                },
                m = (t, e = -1) => {
                    for (let i = e + 1; i < t.length; i++) {
                        const e = t[i];
                        if (u(e)) return i;
                    }
                    return -1;
                },
                f = new WeakMap(),
                v = (t) => "function" == typeof t && f.has(t),
                y = {},
                x = {};
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */
            class w {
                constructor(t, e, i) {
                    (this.__parts = []), (this.template = t), (this.processor = e), (this.options = i);
                }
                update(t) {
                    let e = 0;
                    for (const i of this.__parts) void 0 !== i && i.setValue(t[e]), e++;
                    for (const t of this.__parts) void 0 !== t && t.commit();
                }
                _clone() {
                    const t = s ? this.template.element.content.cloneNode(!0) : document.importNode(this.template.element.content, !0),
                        e = [],
                        i = this.template.parts,
                        n = document.createTreeWalker(t, 133, null, !1);
                    let r,
                        a = 0,
                        o = 0,
                        l = n.nextNode();
                    for (; a < i.length; )
                        if (((r = i[a]), u(r))) {
                            for (; o < r.index; ) o++, "TEMPLATE" === l.nodeName && (e.push(l), (n.currentNode = l.content)), null === (l = n.nextNode()) && ((n.currentNode = e.pop()), (l = n.nextNode()));
                            if ("node" === r.type) {
                                const t = this.processor.handleTextExpression(this.options);
                                t.insertAfterNode(l.previousSibling), this.__parts.push(t);
                            } else this.__parts.push(...this.processor.handleAttributeExpressions(l, r.name, r.strings, this.options));
                            a++;
                        } else this.__parts.push(void 0), a++;
                    return s && (document.adoptNode(t), customElements.upgrade(t)), t;
                    /**
                     * @license
                     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
                     * This code may only be used under the BSD style license found at
                     * http://polymer.github.io/LICENSE.txt
                     * The complete set of authors may be found at
                     * http://polymer.github.io/AUTHORS.txt
                     * The complete set of contributors may be found at
                     * http://polymer.github.io/CONTRIBUTORS.txt
                     * Code distributed by Google as part of the polymer project is also
                     * subject to an additional IP rights grant found at
                     * http://polymer.github.io/PATENTS.txt
                     */
                }
            }
            const _ = window.trustedTypes && trustedTypes.createPolicy("lit-html", { createHTML: (t) => t }),
                I = ` ${a} `;
            class C {
                constructor(t) {
                    (this.value = void 0), (this.__pendingValue = void 0), (this.options = t);
                }
                appendInto(t) {
                    (this.startNode = t.appendChild(d())), (this.endNode = t.appendChild(d()));
                }
                insertAfterNode(t) {
                    (this.startNode = t), (this.endNode = t.nextSibling);
                }
                appendIntoPart(t) {
                    t.__insert((this.startNode = d())), t.__insert((this.endNode = d()));
                }
                insertAfterPart(t) {
                    t.__insert((this.startNode = d())), (this.endNode = t.endNode), (t.endNode = this.startNode);
                }
                setValue(t) {
                    this.__pendingValue = t;
                }
                commit() {
                    if (null === this.startNode.parentNode) return;
                    for (; v(this.__pendingValue); ) {
                        const t = this.__pendingValue;
                        (this.__pendingValue = y), t(this);
                    }
                    const t = this.__pendingValue;
                    t !== y &&
                        (((t) => null === t || !("object" == typeof t || "function" == typeof t))(t)
                            ? t !== this.value && this.__commitText(t)
                            : t instanceof
                                class {
                                    constructor(t, e, i, n) {
                                        (this.strings = t), (this.values = e), (this.type = i), (this.processor = n);
                                    }
                                    getHTML() {
                                        const t = this.strings.length - 1;
                                        let e = "",
                                            i = !1;
                                        for (let n = 0; n < t; n++) {
                                            const t = this.strings[n],
                                                s = t.lastIndexOf("\x3c!--");
                                            i = (s > -1 || i) && -1 === t.indexOf("--\x3e", s + 1);
                                            const r = p.exec(t);
                                            e += null === r ? t + (i ? I : o) : t.substr(0, r.index) + r[1] + r[2] + "$lit$" + r[3] + a;
                                        }
                                        return (e += this.strings[t]), e;
                                    }
                                    getTemplateElement() {
                                        const t = document.createElement("template");
                                        let e = this.getHTML();
                                        return void 0 !== _ && (e = _.createHTML(e)), (t.innerHTML = e), t;
                                        /**
                                         * @license
                                         * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
                                         * This code may only be used under the BSD style license found at
                                         * http://polymer.github.io/LICENSE.txt
                                         * The complete set of authors may be found at
                                         * http://polymer.github.io/AUTHORS.txt
                                         * The complete set of contributors may be found at
                                         * http://polymer.github.io/CONTRIBUTORS.txt
                                         * Code distributed by Google as part of the polymer project is also
                                         * subject to an additional IP rights grant found at
                                         * http://polymer.github.io/PATENTS.txt
                                         */
                                    }
                                }
                              ? this.__commitTemplateResult(t)
                              : t instanceof Node
                                ? this.__commitNode(t)
                                : ((t) => Array.isArray(t) || !(!t || !t[Symbol.iterator]))(t)
                                  ? this.__commitIterable(t)
                                  : t === x
                                    ? ((this.value = x), this.clear())
                                    : this.__commitText(t));
                }
                __insert(t) {
                    this.endNode.parentNode.insertBefore(t, this.endNode);
                }
                __commitNode(t) {
                    this.value !== t && (this.clear(), this.__insert(t), (this.value = t));
                }
                __commitText(t) {
                    const e = this.startNode.nextSibling,
                        i = "string" == typeof (t = null == t ? "" : t) ? t : String(t);
                    e === this.endNode.previousSibling && 3 === e.nodeType ? (e.data = i) : this.__commitNode(document.createTextNode(i)), (this.value = t);
                }
                __commitTemplateResult(t) {
                    const e = this.options.templateFactory(t);
                    if (this.value instanceof w && this.value.template === e) this.value.update(t.values);
                    else {
                        const i = new w(e, t.processor, this.options),
                            n = i._clone();
                        i.update(t.values), this.__commitNode(n), (this.value = i);
                    }
                }
                __commitIterable(t) {
                    Array.isArray(this.value) || ((this.value = []), this.clear());
                    const e = this.value;
                    let i,
                        n = 0;
                    for (const s of t) (i = e[n]), void 0 === i && ((i = new C(this.options)), e.push(i), 0 === n ? i.appendIntoPart(this) : i.insertAfterPart(e[n - 1])), i.setValue(s), i.commit(), n++;
                    n < e.length && ((e.length = n), this.clear(i && i.endNode));
                }
                clear(t = this.startNode) {
                    r(this.startNode.parentNode, t.nextSibling, this.endNode);
                }
            }
            let M = null;
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */ function E(t) {
                let e = b.get(t.type);
                void 0 === e && ((e = { stringsArray: new WeakMap(), keyString: new Map() }), b.set(t.type, e));
                let i = e.stringsArray.get(t.strings);
                if (void 0 !== i) return i;
                const n = t.strings.join(a);
                return (i = e.keyString.get(n)), void 0 === i && ((i = new c(t, t.getTemplateElement())), e.keyString.set(n, i)), e.stringsArray.set(t.strings, i), i;
            }
            (() => {
                try {
                    const t = {
                        get capture() {
                            return (M = !0), !1;
                        },
                    };
                    window.addEventListener("test", t, t), window.removeEventListener("test", t, t);
                } catch (t) {}
            })();
            const b = new Map(),
                S = new WeakMap();
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */ "undefined" != typeof window && (window.litHtmlVersions || (window.litHtmlVersions = [])).push("1.4.1");
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */
            const B = (t, e) => `${t}--${e}`;
            let T = !0;
            (void 0 === window.ShadyCSS || void 0 === window.ShadyCSS.prepareTemplateDom) && (T = !1);
            const L = (t) => (e) => {
                    const i = B(e.type, t);
                    let n = b.get(i);
                    void 0 === n && ((n = { stringsArray: new WeakMap(), keyString: new Map() }), b.set(i, n));
                    let s = n.stringsArray.get(e.strings);
                    if (void 0 !== s) return s;
                    const r = e.strings.join(a);
                    if (((s = n.keyString.get(r)), void 0 === s)) {
                        const i = e.getTemplateElement();
                        T && window.ShadyCSS.prepareTemplateDom(i, t), (s = new c(e, i)), n.keyString.set(r, s);
                    }
                    return n.stringsArray.set(e.strings, s), s;
                },
                D = ["html", "svg"],
                Q = new Set();
            window.JSCompiler_renameProperty = (t, e) => t;
            const R = {
                    toAttribute(t, e) {
                        switch (e) {
                            case Boolean:
                                return t ? "" : null;
                            case Object:
                            case Array:
                                return null == t ? t : JSON.stringify(t);
                        }
                        return t;
                    },
                    fromAttribute(t, e) {
                        switch (e) {
                            case Boolean:
                                return null !== t;
                            case Number:
                                return null === t ? null : Number(t);
                            case Object:
                            case Array:
                                return JSON.parse(t);
                        }
                        return t;
                    },
                },
                P = (t, e) => e !== t && (e == e || t == t),
                N = { attribute: !0, type: String, converter: R, reflect: !1, hasChanged: P };
            class F extends HTMLElement {
                constructor() {
                    super(), this.initialize();
                }
                static get observedAttributes() {
                    this.finalize();
                    const t = [];
                    return (
                        this._classProperties.forEach((e, i) => {
                            const n = this._attributeNameForProperty(i, e);
                            void 0 !== n && (this._attributeToPropertyMap.set(n, i), t.push(n));
                        }),
                        t
                    );
                }
                static _ensureClassProperties() {
                    if (!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties", this))) {
                        this._classProperties = new Map();
                        const t = Object.getPrototypeOf(this)._classProperties;
                        void 0 !== t && t.forEach((t, e) => this._classProperties.set(e, t));
                    }
                }
                static createProperty(t, e = N) {
                    if ((this._ensureClassProperties(), this._classProperties.set(t, e), e.noAccessor || this.prototype.hasOwnProperty(t))) return;
                    const i = "symbol" == typeof t ? Symbol() : `__${t}`,
                        n = this.getPropertyDescriptor(t, i, e);
                    void 0 !== n && Object.defineProperty(this.prototype, t, n);
                }
                static getPropertyDescriptor(t, e, i) {
                    return {
                        get() {
                            return this[e];
                        },
                        set(n) {
                            const s = this[t];
                            (this[e] = n), this.requestUpdateInternal(t, s, i);
                        },
                        configurable: !0,
                        enumerable: !0,
                    };
                }
                static getPropertyOptions(t) {
                    return (this._classProperties && this._classProperties.get(t)) || N;
                }
                static finalize() {
                    const t = Object.getPrototypeOf(this);
                    if ((t.hasOwnProperty("finalized") || t.finalize(), (this.finalized = !0), this._ensureClassProperties(), (this._attributeToPropertyMap = new Map()), this.hasOwnProperty(JSCompiler_renameProperty("properties", this)))) {
                        const t = this.properties,
                            e = [...Object.getOwnPropertyNames(t), ...("function" == typeof Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(t) : [])];
                        for (const i of e) this.createProperty(i, t[i]);
                    }
                }
                static _attributeNameForProperty(t, e) {
                    const i = e.attribute;
                    return !1 === i ? void 0 : "string" == typeof i ? i : "string" == typeof t ? t.toLowerCase() : void 0;
                }
                static _valueHasChanged(t, e, i = P) {
                    return i(t, e);
                }
                static _propertyValueFromAttribute(t, e) {
                    const i = e.type,
                        n = e.converter || R,
                        s = "function" == typeof n ? n : n.fromAttribute;
                    return s ? s(t, i) : t;
                }
                static _propertyValueToAttribute(t, e) {
                    if (void 0 === e.reflect) return;
                    const i = e.type,
                        n = e.converter;
                    return ((n && n.toAttribute) || R.toAttribute)(t, i);
                }
                initialize() {
                    (this._updateState = 0), (this._updatePromise = new Promise((t) => (this._enableUpdatingResolver = t))), (this._changedProperties = new Map()), this._saveInstanceProperties(), this.requestUpdateInternal();
                }
                _saveInstanceProperties() {
                    this.constructor._classProperties.forEach((t, e) => {
                        if (this.hasOwnProperty(e)) {
                            const t = this[e];
                            delete this[e], this._instanceProperties || (this._instanceProperties = new Map()), this._instanceProperties.set(e, t);
                        }
                    });
                }
                _applyInstanceProperties() {
                    this._instanceProperties.forEach((t, e) => (this[e] = t)), (this._instanceProperties = void 0);
                }
                connectedCallback() {
                    this.enableUpdating();
                }
                enableUpdating() {
                    void 0 !== this._enableUpdatingResolver && (this._enableUpdatingResolver(), (this._enableUpdatingResolver = void 0));
                }
                disconnectedCallback() {}
                attributeChangedCallback(t, e, i) {
                    e !== i && this._attributeToProperty(t, i);
                }
                _propertyToAttribute(t, e, i = N) {
                    const n = this.constructor,
                        s = n._attributeNameForProperty(t, i);
                    if (void 0 !== s) {
                        const t = n._propertyValueToAttribute(e, i);
                        if (void 0 === t) return;
                        (this._updateState = 8 | this._updateState), null == t ? this.removeAttribute(s) : this.setAttribute(s, t), (this._updateState = -9 & this._updateState);
                    }
                }
                _attributeToProperty(t, e) {
                    if (8 & this._updateState) return;
                    const i = this.constructor,
                        n = i._attributeToPropertyMap.get(t);
                    if (void 0 !== n) {
                        const t = i.getPropertyOptions(n);
                        (this._updateState = 16 | this._updateState), (this[n] = i._propertyValueFromAttribute(e, t)), (this._updateState = -17 & this._updateState);
                    }
                }
                requestUpdateInternal(t, e, i) {
                    let n = !0;
                    if (void 0 !== t) {
                        const s = this.constructor;
                        (i = i || s.getPropertyOptions(t)), s._valueHasChanged(this[t], e, i.hasChanged) ? (this._changedProperties.has(t) || this._changedProperties.set(t, e), !0 !== i.reflect || 16 & this._updateState || (void 0 === this._reflectingProperties && (this._reflectingProperties = new Map()), this._reflectingProperties.set(t, i))) : (n = !1);
                    }
                    !this._hasRequestedUpdate && n && (this._updatePromise = this._enqueueUpdate());
                }
                requestUpdate(t, e) {
                    return this.requestUpdateInternal(t, e), this.updateComplete;
                }
                async _enqueueUpdate() {
                    this._updateState = 4 | this._updateState;
                    try {
                        await this._updatePromise;
                    } catch (t) {}
                    const t = this.performUpdate();
                    return null != t && (await t), !this._hasRequestedUpdate;
                }
                get _hasRequestedUpdate() {
                    return 4 & this._updateState;
                }
                get hasUpdated() {
                    return 1 & this._updateState;
                }
                performUpdate() {
                    if (!this._hasRequestedUpdate) return;
                    this._instanceProperties && this._applyInstanceProperties();
                    let t = !1;
                    const e = this._changedProperties;
                    try {
                        (t = this.shouldUpdate(e)), t ? this.update(e) : this._markUpdated();
                    } catch (e) {
                        throw ((t = !1), this._markUpdated(), e);
                    }
                    t && (1 & this._updateState || ((this._updateState = 1 | this._updateState), this.firstUpdated(e)), this.updated(e));
                }
                _markUpdated() {
                    (this._changedProperties = new Map()), (this._updateState = -5 & this._updateState);
                }
                get updateComplete() {
                    return this._getUpdateComplete();
                }
                _getUpdateComplete() {
                    return this.getUpdateComplete();
                }
                getUpdateComplete() {
                    return this._updatePromise;
                }
                shouldUpdate(t) {
                    return !0;
                }
                update(t) {
                    void 0 !== this._reflectingProperties && this._reflectingProperties.size > 0 && (this._reflectingProperties.forEach((t, e) => this._propertyToAttribute(e, this[e], t)), (this._reflectingProperties = void 0)), this._markUpdated();
                }
                updated(t) {}
                firstUpdated(t) {}
            }
            F.finalized = !0;
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */
            const U = (t, e) =>
                "method" === e.kind && e.descriptor && !("value" in e.descriptor)
                    ? Object.assign(Object.assign({}, e), {
                          finisher(i) {
                              i.createProperty(e.key, t);
                          },
                      })
                    : {
                          kind: "field",
                          key: Symbol(),
                          placement: "own",
                          descriptor: {},
                          initializer() {
                              "function" == typeof e.initializer && (this[e.key] = e.initializer.call(this));
                          },
                          finisher(i) {
                              i.createProperty(e.key, t);
                          },
                      };
            function k(t) {
                return (e, i) =>
                    void 0 !== i
                        ? ((t, e, i) => {
                              e.constructor.createProperty(i, t);
                          })(t, e, i)
                        : U(t, e);
                /**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/
            }
            const O = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
                G = Symbol();
            class z {
                constructor(t, e) {
                    if (e !== G) throw new Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
                    this.cssText = t;
                }
                get styleSheet() {
                    return void 0 === this._styleSheet && (O ? ((this._styleSheet = new CSSStyleSheet()), this._styleSheet.replaceSync(this.cssText)) : (this._styleSheet = null)), this._styleSheet;
                }
                toString() {
                    return this.cssText;
                }
            }
            /**
             * @license
             * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
             * This code may only be used under the BSD style license found at
             * http://polymer.github.io/LICENSE.txt
             * The complete set of authors may be found at
             * http://polymer.github.io/AUTHORS.txt
             * The complete set of contributors may be found at
             * http://polymer.github.io/CONTRIBUTORS.txt
             * Code distributed by Google as part of the polymer project is also
             * subject to an additional IP rights grant found at
             * http://polymer.github.io/PATENTS.txt
             */ (window.litElementVersions || (window.litElementVersions = [])).push("2.5.1");
            const V = {};
            class H extends F {
                static getStyles() {
                    return this.styles;
                }
                static _getUniqueStyles() {
                    if (this.hasOwnProperty(JSCompiler_renameProperty("_styles", this))) return;
                    const t = this.getStyles();
                    if (Array.isArray(t)) {
                        const e = (t, i) => t.reduceRight((t, i) => (Array.isArray(i) ? e(i, t) : (t.add(i), t)), i),
                            i = e(t, new Set()),
                            n = [];
                        i.forEach((t) => n.unshift(t)), (this._styles = n);
                    } else this._styles = void 0 === t ? [] : [t];
                    this._styles = this._styles.map((t) => {
                        if (t instanceof CSSStyleSheet && !O) {
                            const e = Array.prototype.slice.call(t.cssRules).reduce((t, e) => t + e.cssText, "");
                            return new z(String(e), G);
                        }
                        return t;
                    });
                }
                initialize() {
                    super.initialize(), this.constructor._getUniqueStyles(), (this.renderRoot = this.createRenderRoot()), window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot && this.adoptStyles();
                }
                createRenderRoot() {
                    return this.attachShadow(this.constructor.shadowRootOptions);
                }
                adoptStyles() {
                    const t = this.constructor._styles;
                    0 !== t.length &&
                        (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow
                            ? O
                                ? (this.renderRoot.adoptedStyleSheets = t.map((t) => (t instanceof CSSStyleSheet ? t : t.styleSheet)))
                                : (this._needsShimAdoptedStyleSheets = !0)
                            : window.ShadyCSS.ScopingShim.prepareAdoptedCssText(
                                  t.map((t) => t.cssText),
                                  this.localName,
                              ));
                }
                connectedCallback() {
                    super.connectedCallback(), this.hasUpdated && void 0 !== window.ShadyCSS && window.ShadyCSS.styleElement(this);
                }
                update(t) {
                    const e = this.render();
                    super.update(t),
                        e !== V && this.constructor.render(e, this.renderRoot, { scopeName: this.localName, eventContext: this }),
                        this._needsShimAdoptedStyleSheets &&
                            ((this._needsShimAdoptedStyleSheets = !1),
                            this.constructor._styles.forEach((t) => {
                                const e = document.createElement("style");
                                (e.textContent = t.cssText), this.renderRoot.appendChild(e);
                            }));
                }
                render() {
                    return V;
                }
            }
            (H.finalized = !0),
                (H.render = (t, e, i) => {
                    if (!i || "object" != typeof i || !i.scopeName) throw new Error("The `scopeName` option is required.");
                    const n = i.scopeName,
                        s = S.has(e),
                        a = T && 11 === e.nodeType && !!e.host,
                        o = a && !Q.has(n),
                        l = o ? document.createDocumentFragment() : e;
                    if (
                        (((t, e, i) => {
                            let n = S.get(e);
                            void 0 === n && (r(e, e.firstChild), S.set(e, (n = new C(Object.assign({ templateFactory: E }, i)))), n.appendInto(e)), n.setValue(t), n.commit();
                        })(t, l, Object.assign({ templateFactory: L(n) }, i)),
                        o)
                    ) {
                        const t = S.get(l);
                        S.delete(l);
                        ((t, e, i) => {
                            Q.add(t);
                            const n = i ? i.element : document.createElement("template"),
                                s = e.querySelectorAll("style"),
                                { length: r } = s;
                            if (0 === r) return void window.ShadyCSS.prepareTemplateStyles(n, t);
                            const a = document.createElement("style");
                            for (let t = 0; t < r; t++) {
                                const e = s[t];
                                e.parentNode.removeChild(e), (a.textContent += e.textContent);
                            }
                            ((t) => {
                                D.forEach((e) => {
                                    const i = b.get(B(e, t));
                                    void 0 !== i &&
                                        i.keyString.forEach((t) => {
                                            const {
                                                    element: { content: e },
                                                } = t,
                                                i = new Set();
                                            Array.from(e.querySelectorAll("style")).forEach((t) => {
                                                i.add(t);
                                            }),
                                                A(t, i);
                                        });
                                });
                            })(t);
                            const o = n.content;
                            i
                                ? (function (t, e, i = null) {
                                      const {
                                          element: { content: n },
                                          parts: s,
                                      } = t;
                                      if (null == i) return void n.appendChild(e);
                                      const r = document.createTreeWalker(n, 133, null, !1);
                                      let a = m(s),
                                          o = 0,
                                          l = -1;
                                      for (; r.nextNode(); )
                                          for (l++, r.currentNode === i && ((o = g(e)), i.parentNode.insertBefore(e, i)); -1 !== a && s[a].index === l; ) {
                                              if (o > 0) {
                                                  for (; -1 !== a; ) (s[a].index += o), (a = m(s, a));
                                                  return;
                                              }
                                              a = m(s, a);
                                          }
                                  })(i, a, o.firstChild)
                                : o.insertBefore(a, o.firstChild),
                                window.ShadyCSS.prepareTemplateStyles(n, t);
                            const l = o.querySelector("style");
                            if (window.ShadyCSS.nativeShadow && null !== l) e.insertBefore(l.cloneNode(!0), e.firstChild);
                            else if (i) {
                                o.insertBefore(a, o.firstChild);
                                const t = new Set();
                                t.add(a), A(i, t);
                            }
                        })(n, l, t.value instanceof w ? t.value.template : void 0),
                            r(e, e.firstChild),
                            e.appendChild(l),
                            S.set(e, t);
                    }
                    !s && a && window.ShadyCSS.styleElement(e.host);
                }),
                (H.shadowRootOptions = { mode: "open" });
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const W = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
                q = W && self.XRSession.prototype.requestHitTestSource,
                j = null != self.ResizeObserver,
                Y = null != self.IntersectionObserver,
                J = q;
            (() => {
                const t = navigator.userAgent || navigator.vendor || self.opera;
                let e = !1;
                /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4));
            })(),
                /\bCrOS\b/.test(navigator.userAgent);
            const X = /android/i.test(navigator.userAgent),
                K = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream) || ("MacIntel" === navigator.platform && navigator.maxTouchPoints > 1),
                Z = (() => {
                    const t = document.createElement("a");
                    return Boolean(t.relList && t.relList.supports && t.relList.supports("ar"));
                })();
            /Safari\//.test(navigator.userAgent);
            const $ = /firefox/i.test(navigator.userAgent),
                tt = /OculusBrowser/.test(navigator.userAgent);
            K && /CriOS\//.test(navigator.userAgent);
            const et = X && !$ && !tt,
                it = document.createElement("template");
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ it.innerHTML =
                '\n<style>\n:host {\n  display: block;\n  position: relative;\n  contain: strict;\n  width: 300px;\n  height: 150px;\n}\n\n/* NOTE: This ruleset is our integration surface area with the\n * :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196 */\n:host([data-js-focus-visible]:focus:not(.focus-visible)),\n:host([data-js-focus-visible]) :focus:not(.focus-visible) {\n  outline: none;\n}\n\n.container {\n  position: relative;\n}\n\n.userInput {\n  width: 100%;\n  height: 100%;\n  display: block;\n  position: relative;\n  overflow: hidden;\n}\n\ncanvas {\n  position: absolute;\n  display: none;\n  pointer-events: none;\n  /* NOTE(cdata): Chrome 76 and below apparently have a bug\n   * that causes our canvas not to display pixels unless it is\n   * on its own render layer\n   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893\n   */\n  transform: translateZ(0);\n}\n\ncanvas.show {\n  display: block;\n}\n\n/* Adapted from HTML5 Boilerplate\n *\n * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */\n.screen-reader-only {\n  border: 0;\n  clip: rect(0, 0, 0, 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n}\n\n.slot {\n  position: absolute;\n  pointer-events: none;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n\n.slot > * {\n  pointer-events: initial;\n}\n\n.annotation-wrapper ::slotted(*) {\n  opacity: var(--max-hotspot-opacity, 1);\n  transition: opacity 0.3s;\n}\n\n.pointer-tumbling .annotation-wrapper ::slotted(*) {\n  pointer-events: none;\n}\n\n.annotation-wrapper ::slotted(*) {\n  pointer-events: initial;\n}\n\n.annotation-wrapper.hide ::slotted(*) {\n  opacity: var(--min-hotspot-opacity, 0.25);\n}\n\n.slot.poster {\n  opacity: 0;\n  transition: opacity 0.3s 0.3s;\n  background-color: inherit;\n}\n\n.slot.poster.show {\n  opacity: 1;\n  transition: none;\n}\n\n.slot.poster > * {\n  pointer-events: initial;\n}\n\n.slot.poster:not(.show) > * {\n  pointer-events: none;\n}\n\n#default-poster {\n  width: 100%;\n  height: 100%;\n  /* The default poster is a <button> so we need to set display\n   * to prevent it from being affected by text-align: */\n  display: block;\n  position: absolute;\n  border: none;\n  padding: 0;\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: center;\n  background-color: var(--poster-color, #fff);\n  background-image: var(--poster-image, none);\n}\n\n#default-progress-bar {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  overflow: hidden;\n}\n\n#default-progress-bar > .mask {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: var(--progress-mask, #fff);\n  transition: opacity 0.3s;\n  opacity: 0.2;\n}\n\n#default-progress-bar > .bar {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: var(--progress-bar-height, 5px);\n  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));\n  transition: transform 0.09s;\n  transform-origin: top left;\n  transform: scaleX(0);\n  overflow: hidden;\n}\n\n#default-progress-bar > .bar.hide {\n  transition: opacity 0.3s 1s;\n  opacity: 0;\n}\n\n.slot.interaction-prompt {\n  display: var(--interaction-prompt-display, flex);\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n\n  opacity: 0;\n  will-change: opacity;\n  overflow: hidden;\n  transition: opacity 0.3s;\n}\n\n.slot.interaction-prompt.visible {\n  opacity: 1;\n}\n\n.slot.interaction-prompt > .animated-container {\n  will-change: transform, opacity;\n}\n\n.slot.interaction-prompt > * {\n  pointer-events: none;\n}\n\n.slot.ar-button {\n  -moz-user-select: none;\n  -webkit-tap-highlight-color: transparent;\n  user-select: none;\n\n  display: var(--ar-button-display, block);\n}\n\n.slot.ar-button:not(.enabled) {\n  display: none;\n}\n\n.fab {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-sizing: border-box;\n  width: 40px;\n  height: 40px;\n  cursor: pointer;\n  background-color: #fff;\n  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);\n  border-radius: 100px;\n}\n\n.fab > * {\n  opacity: 0.87;\n}\n\n#default-ar-button {\n  position: absolute;\n  bottom: 16px;\n  right: 16px;\n  transform: scale(var(--ar-button-scale, 1));\n  transform-origin: bottom right;\n}\n\n.slot.default {\n  pointer-events: none;\n}\n\n.slot.progress-bar {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button {\n  pointer-events: none;\n}\n\n.slot.exit-webxr-ar-button:not(.enabled) {\n  display: none;\n}\n\n#default-exit-webxr-ar-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  top: 16px;\n  right: 16px;\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n}\n\n#default-exit-webxr-ar-button > svg {\n  fill: #fff;\n}\n</style>\n<div class="container">\n  <div class="userInput" tabindex="0" role="img"\n      aria-label="A depiction of a 3D model"\n      aria-live="polite">\n      <div class="slot canvas">\n        <slot name="canvas">\n          <canvas></canvas>\n        </slot>\n      </div>\n  </div>\n\n  \x3c!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM\n        will have their <slot> elements removed by ShadyCSS --\x3e\n  <div class="slot poster">\n    <slot name="poster">\n      <button type="button" id="default-poster" aria-hidden="true" aria-label="Activate to view in 3D!"></button>\n    </slot>\n  </div>\n\n  <div class="slot ar-button">\n    <slot name="ar-button">\n      <a id="default-ar-button" part="default-ar-button" class="fab"\n          tabindex="2"\n          aria-label="View this 3D model up close">\n        \n<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"\n\t xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"\n\t viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">\n<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>\n<g id="Art_layer">\n\t<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>\n\t<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>\n\t<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>\n\t<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>\n\t<g>\n\t\t<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3\n\t\t\tl5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62\n\t\t\tl4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>\n\t</g>\n</g>\n</svg>\n      </a>\n    </slot>\n  </div>\n\n  <div class="slot interaction-prompt">\n    <div class="animated-container">\n      <slot name="interaction-prompt" aria-hidden="true">\n        \n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">\n    <defs>\n        <path id="A" d="M.001.232h24.997V36H.001z" />\n    </defs>\n    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">\n        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />\n        <g transform="translate(11 3)">\n            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />\n            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />\n            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />\n            <g transform="translate(0 .769)">\n                <mask id="B" fill="#fff">\n                    <use xlink:href="#A" />\n                </mask>\n                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />\n            </g>\n        </g>\n    </g>\n</svg>\n      </slot>\n    </div>\n  </div>\n\n  <div class="slot default">\n    <slot></slot>\n\n    <div class="slot progress-bar">\n      <slot name="progress-bar">\n        <div id="default-progress-bar" aria-hidden="true">\n          <div class="mask" part="default-progress-mask"></div>\n          <div class="bar" part="default-progress-bar"></div>\n        </div>\n      </slot>\n    </div>\n    \n    <div class="slot exit-webxr-ar-button">\n      <slot name="exit-webxr-ar-button">\n        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"\n            tabindex="3"\n            aria-label="Exit AR"\n            aria-hidden="true">\n          \n<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">\n    \x3c!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement\n         support for dynamic re-coloring of UI components --\x3e\n    <defs>\n      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">\n        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>\n        <feOffset dx="0" dy="0" result="offsetblur"/>\n        <feFlood flood-color="#000000"/>\n        <feComposite in2="offsetblur" operator="in"/>\n        <feMerge>\n          <feMergeNode/>\n          <feMergeNode in="SourceGraphic"/>\n        </feMerge>\n      </filter>\n    </defs>\n    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>\n        </a>\n      </slot>\n    </div>\n  </div>\n</div>';
            class nt {
                addEventListener(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const i = this._listeners;
                    void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
                }
                hasEventListener(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const i = this._listeners;
                    return void 0 !== i[t] && -1 !== i[t].indexOf(e);
                }
                removeEventListener(t, e) {
                    if (void 0 === this._listeners) return;
                    const i = this._listeners[t];
                    if (void 0 !== i) {
                        const t = i.indexOf(e);
                        -1 !== t && i.splice(t, 1);
                    }
                }
                dispatchEvent(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const i = e.slice(0);
                        for (let e = 0, n = i.length; e < n; e++) i[e].call(this, t);
                        t.target = null;
                    }
                }
            }
            const st = [];
            for (let t = 0; t < 256; t++) st[t] = (t < 16 ? "0" : "") + t.toString(16);
            let rt = 1234567;
            const at = Math.PI / 180,
                ot = 180 / Math.PI;
            function lt() {
                const t = (4294967295 * Math.random()) | 0,
                    e = (4294967295 * Math.random()) | 0,
                    i = (4294967295 * Math.random()) | 0,
                    n = (4294967295 * Math.random()) | 0;
                return (st[255 & t] + st[(t >> 8) & 255] + st[(t >> 16) & 255] + st[(t >> 24) & 255] + "-" + st[255 & e] + st[(e >> 8) & 255] + "-" + st[((e >> 16) & 15) | 64] + st[(e >> 24) & 255] + "-" + st[(63 & i) | 128] + st[(i >> 8) & 255] + "-" + st[(i >> 16) & 255] + st[(i >> 24) & 255] + st[255 & n] + st[(n >> 8) & 255] + st[(n >> 16) & 255] + st[(n >> 24) & 255]).toUpperCase();
            }
            function ct(t, e, i) {
                return Math.max(e, Math.min(i, t));
            }
            function ht(t, e) {
                return ((t % e) + e) % e;
            }
            function ut(t, e, i) {
                return (1 - i) * t + i * e;
            }
            function dt(t) {
                return !(t & (t - 1)) && 0 !== t;
            }
            function pt(t) {
                return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
            }
            function At(t) {
                return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
            }
            var gt = Object.freeze({
                __proto__: null,
                DEG2RAD: at,
                RAD2DEG: ot,
                generateUUID: lt,
                clamp: ct,
                euclideanModulo: ht,
                mapLinear: function (t, e, i, n, s) {
                    return n + ((t - e) * (s - n)) / (i - e);
                },
                inverseLerp: function (t, e, i) {
                    return t !== e ? (i - t) / (e - t) : 0;
                },
                lerp: ut,
                damp: function (t, e, i, n) {
                    return ut(t, e, 1 - Math.exp(-i * n));
                },
                pingpong: function (t, e = 1) {
                    return e - Math.abs(ht(t, 2 * e) - e);
                },
                smoothstep: function (t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t);
                },
                smootherstep: function (t, e, i) {
                    return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10);
                },
                randInt: function (t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1));
                },
                randFloat: function (t, e) {
                    return t + Math.random() * (e - t);
                },
                randFloatSpread: function (t) {
                    return t * (0.5 - Math.random());
                },
                seededRandom: function (t) {
                    return void 0 !== t && (rt = t % 2147483647), (rt = (16807 * rt) % 2147483647), (rt - 1) / 2147483646;
                },
                degToRad: function (t) {
                    return t * at;
                },
                radToDeg: function (t) {
                    return t * ot;
                },
                isPowerOfTwo: dt,
                ceilPowerOfTwo: pt,
                floorPowerOfTwo: At,
                setQuaternionFromProperEuler: function (t, e, i, n, s) {
                    const r = Math.cos,
                        a = Math.sin,
                        o = r(i / 2),
                        l = a(i / 2),
                        c = r((e + n) / 2),
                        h = a((e + n) / 2),
                        u = r((e - n) / 2),
                        d = a((e - n) / 2),
                        p = r((n - e) / 2),
                        A = a((n - e) / 2);
                    switch (s) {
                        case "XYX":
                            t.set(o * h, l * u, l * d, o * c);
                            break;
                        case "YZY":
                            t.set(l * d, o * h, l * u, o * c);
                            break;
                        case "ZXZ":
                            t.set(l * u, l * d, o * h, o * c);
                            break;
                        case "XZX":
                            t.set(o * h, l * A, l * p, o * c);
                            break;
                        case "YXY":
                            t.set(l * p, o * h, l * A, o * c);
                            break;
                        case "ZYZ":
                            t.set(l * A, l * p, o * h, o * c);
                    }
                },
            });
            class mt {
                constructor(t = 0, e = 0) {
                    (this.x = t), (this.y = e);
                }
                get width() {
                    return this.x;
                }
                set width(t) {
                    this.x = t;
                }
                get height() {
                    return this.y;
                }
                set height(t) {
                    this.y = t;
                }
                set(t, e) {
                    return (this.x = t), (this.y = e), this;
                }
                setScalar(t) {
                    return (this.x = t), (this.y = t), this;
                }
                setX(t) {
                    return (this.x = t), this;
                }
                setY(t) {
                    return (this.y = t), this;
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t);
                    }
                    return this;
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t);
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y);
                }
                copy(t) {
                    return (this.x = t.x), (this.y = t.y), this;
                }
                add(t, e) {
                    return void 0 !== e ? this.addVectors(t, e) : ((this.x += t.x), (this.y += t.y), this);
                }
                addScalar(t) {
                    return (this.x += t), (this.y += t), this;
                }
                addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
                }
                addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), this;
                }
                sub(t, e) {
                    return void 0 !== e ? this.subVectors(t, e) : ((this.x -= t.x), (this.y -= t.y), this);
                }
                subScalar(t) {
                    return (this.x -= t), (this.y -= t), this;
                }
                subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
                }
                multiply(t) {
                    return (this.x *= t.x), (this.y *= t.y), this;
                }
                multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), this;
                }
                divide(t) {
                    return (this.x /= t.x), (this.y /= t.y), this;
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                }
                applyMatrix3(t) {
                    const e = this.x,
                        i = this.y,
                        n = t.elements;
                    return (this.x = n[0] * e + n[3] * i + n[6]), (this.y = n[1] * e + n[4] * i + n[7]), this;
                }
                min(t) {
                    return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
                }
                max(t) {
                    return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
                }
                clamp(t, e) {
                    return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), this;
                }
                clampScalar(t, e) {
                    return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), this;
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
                }
                floor() {
                    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
                }
                ceil() {
                    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
                }
                round() {
                    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
                }
                roundToZero() {
                    return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), this;
                }
                negate() {
                    return (this.x = -this.x), (this.y = -this.y), this;
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y;
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x;
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y);
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y);
                }
                normalize() {
                    return this.divideScalar(this.length() || 1);
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI;
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t));
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        i = this.y - t.y;
                    return e * e + i * i;
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t);
                }
                lerp(t, e) {
                    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
                }
                lerpVectors(t, e, i) {
                    return (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), this;
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y;
                }
                fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), t;
                }
                fromBufferAttribute(t, e, i) {
                    return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
                }
                rotateAround(t, e) {
                    const i = Math.cos(e),
                        n = Math.sin(e),
                        s = this.x - t.x,
                        r = this.y - t.y;
                    return (this.x = s * i - r * n + t.x), (this.y = s * n + r * i + t.y), this;
                }
                random() {
                    return (this.x = Math.random()), (this.y = Math.random()), this;
                }
            }
            mt.prototype.isVector2 = !0;
            class ft {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                }
                set(t, e, i, n, s, r, a, o, l) {
                    const c = this.elements;
                    return (c[0] = t), (c[1] = n), (c[2] = a), (c[3] = e), (c[4] = s), (c[5] = o), (c[6] = i), (c[7] = r), (c[8] = l), this;
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
                }
                copy(t) {
                    const e = this.elements,
                        i = t.elements;
                    return (e[0] = i[0]), (e[1] = i[1]), (e[2] = i[2]), (e[3] = i[3]), (e[4] = i[4]), (e[5] = i[5]), (e[6] = i[6]), (e[7] = i[7]), (e[8] = i[8]), this;
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t);
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this);
                }
                multiplyMatrices(t, e) {
                    const i = t.elements,
                        n = e.elements,
                        s = this.elements,
                        r = i[0],
                        a = i[3],
                        o = i[6],
                        l = i[1],
                        c = i[4],
                        h = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        A = n[0],
                        g = n[3],
                        m = n[6],
                        f = n[1],
                        v = n[4],
                        y = n[7],
                        x = n[2],
                        w = n[5],
                        _ = n[8];
                    return (s[0] = r * A + a * f + o * x), (s[3] = r * g + a * v + o * w), (s[6] = r * m + a * y + o * _), (s[1] = l * A + c * f + h * x), (s[4] = l * g + c * v + h * w), (s[7] = l * m + c * y + h * _), (s[2] = u * A + d * f + p * x), (s[5] = u * g + d * v + p * w), (s[8] = u * m + d * y + p * _), this;
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return (e[0] *= t), (e[3] *= t), (e[6] *= t), (e[1] *= t), (e[4] *= t), (e[7] *= t), (e[2] *= t), (e[5] *= t), (e[8] *= t), this;
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        s = t[3],
                        r = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        c = t[8];
                    return e * r * c - e * a * l - i * s * c + i * a * o + n * s * l - n * r * o;
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        s = t[3],
                        r = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        c = t[8],
                        h = c * r - a * l,
                        u = a * o - c * s,
                        d = l * s - r * o,
                        p = e * h + i * u + n * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const A = 1 / p;
                    return (t[0] = h * A), (t[1] = (n * l - c * i) * A), (t[2] = (a * i - n * r) * A), (t[3] = u * A), (t[4] = (c * e - n * o) * A), (t[5] = (n * s - a * e) * A), (t[6] = d * A), (t[7] = (i * o - l * e) * A), (t[8] = (r * e - i * s) * A), this;
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return (t = e[1]), (e[1] = e[3]), (e[3] = t), (t = e[2]), (e[2] = e[6]), (e[6] = t), (t = e[5]), (e[5] = e[7]), (e[7] = t), this;
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose();
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return (t[0] = e[0]), (t[1] = e[3]), (t[2] = e[6]), (t[3] = e[1]), (t[4] = e[4]), (t[5] = e[7]), (t[6] = e[2]), (t[7] = e[5]), (t[8] = e[8]), this;
                }
                setUvTransform(t, e, i, n, s, r, a) {
                    const o = Math.cos(s),
                        l = Math.sin(s);
                    return this.set(i * o, i * l, -i * (o * r + l * a) + r + t, -n * l, n * o, -n * (-l * r + o * a) + a + e, 0, 0, 1), this;
                }
                scale(t, e) {
                    const i = this.elements;
                    return (i[0] *= t), (i[3] *= t), (i[6] *= t), (i[1] *= e), (i[4] *= e), (i[7] *= e), this;
                }
                rotate(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t),
                        n = this.elements,
                        s = n[0],
                        r = n[3],
                        a = n[6],
                        o = n[1],
                        l = n[4],
                        c = n[7];
                    return (n[0] = e * s + i * o), (n[3] = e * r + i * l), (n[6] = e * a + i * c), (n[1] = -i * s + e * o), (n[4] = -i * r + e * l), (n[7] = -i * a + e * c), this;
                }
                translate(t, e) {
                    const i = this.elements;
                    return (i[0] += t * i[2]), (i[3] += t * i[5]), (i[6] += t * i[8]), (i[1] += e * i[2]), (i[4] += e * i[5]), (i[7] += e * i[8]), this;
                }
                equals(t) {
                    const e = this.elements,
                        i = t.elements;
                    for (let t = 0; t < 9; t++) if (e[t] !== i[t]) return !1;
                    return !0;
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
                    return this;
                }
                toArray(t = [], e = 0) {
                    const i = this.elements;
                    return (t[e] = i[0]), (t[e + 1] = i[1]), (t[e + 2] = i[2]), (t[e + 3] = i[3]), (t[e + 4] = i[4]), (t[e + 5] = i[5]), (t[e + 6] = i[6]), (t[e + 7] = i[7]), (t[e + 8] = i[8]), t;
                }
                clone() {
                    return new this.constructor().fromArray(this.elements);
                }
            }
            let vt;
            ft.prototype.isMatrix3 = !0;
            class yt {
                static getDataURL(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                        void 0 === vt && (vt = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), (vt.width = t.width), (vt.height = t.height);
                        const i = vt.getContext("2d");
                        t instanceof ImageData ? i.putImageData(t, 0, 0) : i.drawImage(t, 0, 0, t.width, t.height), (e = vt);
                    }
                    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", 0.6) : e.toDataURL("image/png");
                }
            }
            let xt = 0;
            class wt extends nt {
                constructor(t = wt.DEFAULT_IMAGE, e = wt.DEFAULT_MAPPING, i = 1001, n = 1001, s = 1006, r = 1008, a = 1023, o = 1009, l = 1, c = 3e3) {
                    super(), Object.defineProperty(this, "id", { value: xt++ }), (this.uuid = lt()), (this.name = ""), (this.image = t), (this.mipmaps = []), (this.mapping = e), (this.wrapS = i), (this.wrapT = n), (this.magFilter = s), (this.minFilter = r), (this.anisotropy = l), (this.format = a), (this.internalFormat = null), (this.type = o), (this.offset = new mt(0, 0)), (this.repeat = new mt(1, 1)), (this.center = new mt(0, 0)), (this.rotation = 0), (this.matrixAutoUpdate = !0), (this.matrix = new ft()), (this.generateMipmaps = !0), (this.premultiplyAlpha = !1), (this.flipY = !0), (this.unpackAlignment = 4), (this.encoding = c), (this.version = 0), (this.onUpdate = null), (this.isRenderTargetTexture = !1);
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return (this.name = t.name), (this.image = t.image), (this.mipmaps = t.mipmaps.slice(0)), (this.mapping = t.mapping), (this.wrapS = t.wrapS), (this.wrapT = t.wrapT), (this.magFilter = t.magFilter), (this.minFilter = t.minFilter), (this.anisotropy = t.anisotropy), (this.format = t.format), (this.internalFormat = t.internalFormat), (this.type = t.type), this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), (this.rotation = t.rotation), (this.matrixAutoUpdate = t.matrixAutoUpdate), this.matrix.copy(t.matrix), (this.generateMipmaps = t.generateMipmaps), (this.premultiplyAlpha = t.premultiplyAlpha), (this.flipY = t.flipY), (this.unpackAlignment = t.unpackAlignment), (this.encoding = t.encoding), this;
                }
                toJSON(t) {
                    const e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
                    if (void 0 !== this.image) {
                        const n = this.image;
                        if ((void 0 === n.uuid && (n.uuid = lt()), !e && void 0 === t.images[n.uuid])) {
                            let e;
                            if (Array.isArray(n)) {
                                e = [];
                                for (let t = 0, i = n.length; t < i; t++) n[t].isDataTexture ? e.push(_t(n[t].image)) : e.push(_t(n[t]));
                            } else e = _t(n);
                            t.images[n.uuid] = { uuid: n.uuid, url: e };
                        }
                        i.image = n.uuid;
                    }
                    return e || (t.textures[this.uuid] = i), i;
                }
                dispose() {
                    this.dispatchEvent({ type: "dispose" });
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
                        switch (this.wrapS) {
                            case 1e3:
                                t.x = t.x - Math.floor(t.x);
                                break;
                            case 1001:
                                t.x = t.x < 0 ? 0 : 1;
                                break;
                            case 1002:
                                1 === Math.abs(Math.floor(t.x) % 2) ? (t.x = Math.ceil(t.x) - t.x) : (t.x = t.x - Math.floor(t.x));
                        }
                    if (t.y < 0 || t.y > 1)
                        switch (this.wrapT) {
                            case 1e3:
                                t.y = t.y - Math.floor(t.y);
                                break;
                            case 1001:
                                t.y = t.y < 0 ? 0 : 1;
                                break;
                            case 1002:
                                1 === Math.abs(Math.floor(t.y) % 2) ? (t.y = Math.ceil(t.y) - t.y) : (t.y = t.y - Math.floor(t.y));
                        }
                    return this.flipY && (t.y = 1 - t.y), t;
                }
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
            }
            function _t(t) {
                return ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) || ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) || ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap) ? yt.getDataURL(t) : t.data ? { data: Array.prototype.slice.call(t.data), width: t.width, height: t.height, type: t.data.constructor.name } : {};
            }
            (wt.DEFAULT_IMAGE = void 0), (wt.DEFAULT_MAPPING = 300), (wt.prototype.isTexture = !0);
            class It {
                constructor(t = 0, e = 0, i = 0, n = 1) {
                    (this.x = t), (this.y = e), (this.z = i), (this.w = n);
                }
                get width() {
                    return this.z;
                }
                set width(t) {
                    this.z = t;
                }
                get height() {
                    return this.w;
                }
                set height(t) {
                    this.w = t;
                }
                set(t, e, i, n) {
                    return (this.x = t), (this.y = e), (this.z = i), (this.w = n), this;
                }
                setScalar(t) {
                    return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
                }
                setX(t) {
                    return (this.x = t), this;
                }
                setY(t) {
                    return (this.y = t), this;
                }
                setZ(t) {
                    return (this.z = t), this;
                }
                setW(t) {
                    return (this.w = t), this;
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t);
                    }
                    return this;
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t);
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w);
                }
                copy(t) {
                    return (this.x = t.x), (this.y = t.y), (this.z = t.z), (this.w = void 0 !== t.w ? t.w : 1), this;
                }
                add(t, e) {
                    return void 0 !== e ? this.addVectors(t, e) : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this);
                }
                addScalar(t) {
                    return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
                }
                addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), (this.w = t.w + e.w), this;
                }
                addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), (this.w += t.w * e), this;
                }
                sub(t, e) {
                    return void 0 !== e ? this.subVectors(t, e) : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this);
                }
                subScalar(t) {
                    return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
                }
                subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), (this.w = t.w - e.w), this;
                }
                multiply(t) {
                    return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), (this.w *= t.w), this;
                }
                multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
                }
                applyMatrix4(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        s = this.w,
                        r = t.elements;
                    return (this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s), (this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s), (this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s), (this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s), this;
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? ((this.x = 1), (this.y = 0), (this.z = 0)) : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)), this;
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, i, n, s;
                    const r = 0.01,
                        a = 0.1,
                        o = t.elements,
                        l = o[0],
                        c = o[4],
                        h = o[8],
                        u = o[1],
                        d = o[5],
                        p = o[9],
                        A = o[2],
                        g = o[6],
                        m = o[10];
                    if (Math.abs(c - u) < r && Math.abs(h - A) < r && Math.abs(p - g) < r) {
                        if (Math.abs(c + u) < a && Math.abs(h + A) < a && Math.abs(p + g) < a && Math.abs(l + d + m - 3) < a) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (l + 1) / 2,
                            o = (d + 1) / 2,
                            f = (m + 1) / 2,
                            v = (c + u) / 4,
                            y = (h + A) / 4,
                            x = (p + g) / 4;
                        return t > o && t > f ? (t < r ? ((i = 0), (n = 0.707106781), (s = 0.707106781)) : ((i = Math.sqrt(t)), (n = v / i), (s = y / i))) : o > f ? (o < r ? ((i = 0.707106781), (n = 0), (s = 0.707106781)) : ((n = Math.sqrt(o)), (i = v / n), (s = x / n))) : f < r ? ((i = 0.707106781), (n = 0.707106781), (s = 0)) : ((s = Math.sqrt(f)), (i = y / s), (n = x / s)), this.set(i, n, s, e), this;
                    }
                    let f = Math.sqrt((g - p) * (g - p) + (h - A) * (h - A) + (u - c) * (u - c));
                    return Math.abs(f) < 0.001 && (f = 1), (this.x = (g - p) / f), (this.y = (h - A) / f), (this.z = (u - c) / f), (this.w = Math.acos((l + d + m - 1) / 2)), this;
                }
                min(t) {
                    return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), (this.z = Math.min(this.z, t.z)), (this.w = Math.min(this.w, t.w)), this;
                }
                max(t) {
                    return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), (this.z = Math.max(this.z, t.z)), (this.w = Math.max(this.w, t.w)), this;
                }
                clamp(t, e) {
                    return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), (this.z = Math.max(t.z, Math.min(e.z, this.z))), (this.w = Math.max(t.w, Math.min(e.w, this.w))), this;
                }
                clampScalar(t, e) {
                    return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), (this.z = Math.max(t, Math.min(e, this.z))), (this.w = Math.max(t, Math.min(e, this.w))), this;
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
                }
                floor() {
                    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), (this.w = Math.floor(this.w)), this;
                }
                ceil() {
                    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), (this.w = Math.ceil(this.w)), this;
                }
                round() {
                    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), (this.w = Math.round(this.w)), this;
                }
                roundToZero() {
                    return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)), (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)), this;
                }
                negate() {
                    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), (this.w = -this.w), this;
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                }
                normalize() {
                    return this.divideScalar(this.length() || 1);
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t);
                }
                lerp(t, e) {
                    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), (this.w += (t.w - this.w) * e), this;
                }
                lerpVectors(t, e, i) {
                    return (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), (this.z = t.z + (e.z - t.z) * i), (this.w = t.w + (e.w - t.w) * i), this;
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
                }
                fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), (this.w = t[e + 3]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), (t[e + 3] = this.w), t;
                }
                fromBufferAttribute(t, e, i) {
                    return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), (this.w = t.getW(e)), this;
                }
                random() {
                    return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), (this.w = Math.random()), this;
                }
            }
            It.prototype.isVector4 = !0;
            class Ct extends nt {
                constructor(t, e, i = {}) {
                    super(), (this.width = t), (this.height = e), (this.depth = 1), (this.scissor = new It(0, 0, t, e)), (this.scissorTest = !1), (this.viewport = new It(0, 0, t, e)), (this.texture = new wt(void 0, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding)), (this.texture.isRenderTargetTexture = !0), (this.texture.image = { width: t, height: e, depth: 1 }), (this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps), (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006), (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer), (this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer), (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null);
                }
                setTexture(t) {
                    (t.image = { width: this.width, height: this.height, depth: this.depth }), (this.texture = t);
                }
                setSize(t, e, i = 1) {
                    (this.width === t && this.height === e && this.depth === i) || ((this.width = t), (this.height = e), (this.depth = i), (this.texture.image.width = t), (this.texture.image.height = e), (this.texture.image.depth = i), this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return (this.width = t.width), (this.height = t.height), (this.depth = t.depth), this.viewport.copy(t.viewport), (this.texture = t.texture.clone()), (this.texture.image = { ...this.texture.image }), (this.depthBuffer = t.depthBuffer), (this.stencilBuffer = t.stencilBuffer), (this.depthTexture = t.depthTexture), this;
                }
                dispose() {
                    this.dispatchEvent({ type: "dispose" });
                }
            }
            (Ct.prototype.isWebGLRenderTarget = !0),
                (class extends Ct {
                    constructor(t, e, i) {
                        super(t, e);
                        const n = this.texture;
                        this.texture = [];
                        for (let t = 0; t < i; t++) this.texture[t] = n.clone();
                    }
                    setSize(t, e, i = 1) {
                        if (this.width !== t || this.height !== e || this.depth !== i) {
                            (this.width = t), (this.height = e), (this.depth = i);
                            for (let n = 0, s = this.texture.length; n < s; n++) (this.texture[n].image.width = t), (this.texture[n].image.height = e), (this.texture[n].image.depth = i);
                            this.dispose();
                        }
                        return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
                    }
                    copy(t) {
                        this.dispose(), (this.width = t.width), (this.height = t.height), (this.depth = t.depth), this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), (this.depthBuffer = t.depthBuffer), (this.stencilBuffer = t.stencilBuffer), (this.depthTexture = t.depthTexture), (this.texture.length = 0);
                        for (let e = 0, i = t.texture.length; e < i; e++) this.texture[e] = t.texture[e].clone();
                        return this;
                    }
                }.prototype.isWebGLMultipleRenderTargets = !0);
            class Mt extends Ct {
                constructor(t, e, i) {
                    super(t, e, i), (this.samples = 4);
                }
                copy(t) {
                    return super.copy.call(this, t), (this.samples = t.samples), this;
                }
            }
            Mt.prototype.isWebGLMultisampleRenderTarget = !0;
            class Et {
                constructor(t = 0, e = 0, i = 0, n = 1) {
                    (this._x = t), (this._y = e), (this._z = i), (this._w = n);
                }
                static slerp(t, e, i, n) {
                    return i.slerpQuaternions(t, e, n);
                }
                static slerpFlat(t, e, i, n, s, r, a) {
                    let o = i[n + 0],
                        l = i[n + 1],
                        c = i[n + 2],
                        h = i[n + 3];
                    const u = s[r + 0],
                        d = s[r + 1],
                        p = s[r + 2],
                        A = s[r + 3];
                    if (0 === a) return (t[e + 0] = o), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = h);
                    if (1 === a) return (t[e + 0] = u), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = A);
                    if (h !== A || o !== u || l !== d || c !== p) {
                        let t = 1 - a;
                        const e = o * u + l * d + c * p + h * A,
                            i = e >= 0 ? 1 : -1,
                            n = 1 - e * e;
                        if (n > Number.EPSILON) {
                            const s = Math.sqrt(n),
                                r = Math.atan2(s, e * i);
                            (t = Math.sin(t * r) / s), (a = Math.sin(a * r) / s);
                        }
                        const s = a * i;
                        if (((o = o * t + u * s), (l = l * t + d * s), (c = c * t + p * s), (h = h * t + A * s), t === 1 - a)) {
                            const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                            (o *= t), (l *= t), (c *= t), (h *= t);
                        }
                    }
                    (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
                }
                static multiplyQuaternionsFlat(t, e, i, n, s, r) {
                    const a = i[n],
                        o = i[n + 1],
                        l = i[n + 2],
                        c = i[n + 3],
                        h = s[r],
                        u = s[r + 1],
                        d = s[r + 2],
                        p = s[r + 3];
                    return (t[e] = a * p + c * h + o * d - l * u), (t[e + 1] = o * p + c * u + l * h - a * d), (t[e + 2] = l * p + c * d + a * u - o * h), (t[e + 3] = c * p - a * h - o * u - l * d), t;
                }
                get x() {
                    return this._x;
                }
                set x(t) {
                    (this._x = t), this._onChangeCallback();
                }
                get y() {
                    return this._y;
                }
                set y(t) {
                    (this._y = t), this._onChangeCallback();
                }
                get z() {
                    return this._z;
                }
                set z(t) {
                    (this._z = t), this._onChangeCallback();
                }
                get w() {
                    return this._w;
                }
                set w(t) {
                    (this._w = t), this._onChangeCallback();
                }
                set(t, e, i, n) {
                    return (this._x = t), (this._y = e), (this._z = i), (this._w = n), this._onChangeCallback(), this;
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w);
                }
                copy(t) {
                    return (this._x = t.x), (this._y = t.y), (this._z = t.z), (this._w = t.w), this._onChangeCallback(), this;
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const i = t._x,
                        n = t._y,
                        s = t._z,
                        r = t._order,
                        a = Math.cos,
                        o = Math.sin,
                        l = a(i / 2),
                        c = a(n / 2),
                        h = a(s / 2),
                        u = o(i / 2),
                        d = o(n / 2),
                        p = o(s / 2);
                    switch (r) {
                        case "XYZ":
                            (this._x = u * c * h + l * d * p), (this._y = l * d * h - u * c * p), (this._z = l * c * p + u * d * h), (this._w = l * c * h - u * d * p);
                            break;
                        case "YXZ":
                            (this._x = u * c * h + l * d * p), (this._y = l * d * h - u * c * p), (this._z = l * c * p - u * d * h), (this._w = l * c * h + u * d * p);
                            break;
                        case "ZXY":
                            (this._x = u * c * h - l * d * p), (this._y = l * d * h + u * c * p), (this._z = l * c * p + u * d * h), (this._w = l * c * h - u * d * p);
                            break;
                        case "ZYX":
                            (this._x = u * c * h - l * d * p), (this._y = l * d * h + u * c * p), (this._z = l * c * p - u * d * h), (this._w = l * c * h + u * d * p);
                            break;
                        case "YZX":
                            (this._x = u * c * h + l * d * p), (this._y = l * d * h + u * c * p), (this._z = l * c * p - u * d * h), (this._w = l * c * h - u * d * p);
                            break;
                        case "XZY":
                            (this._x = u * c * h - l * d * p), (this._y = l * d * h - u * c * p), (this._z = l * c * p + u * d * h), (this._w = l * c * h + u * d * p);
                    }
                    return !1 !== e && this._onChangeCallback(), this;
                }
                setFromAxisAngle(t, e) {
                    const i = e / 2,
                        n = Math.sin(i);
                    return (this._x = t.x * n), (this._y = t.y * n), (this._z = t.z * n), (this._w = Math.cos(i)), this._onChangeCallback(), this;
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        i = e[0],
                        n = e[4],
                        s = e[8],
                        r = e[1],
                        a = e[5],
                        o = e[9],
                        l = e[2],
                        c = e[6],
                        h = e[10],
                        u = i + a + h;
                    if (u > 0) {
                        const t = 0.5 / Math.sqrt(u + 1);
                        (this._w = 0.25 / t), (this._x = (c - o) * t), (this._y = (s - l) * t), (this._z = (r - n) * t);
                    } else if (i > a && i > h) {
                        const t = 2 * Math.sqrt(1 + i - a - h);
                        (this._w = (c - o) / t), (this._x = 0.25 * t), (this._y = (n + r) / t), (this._z = (s + l) / t);
                    } else if (a > h) {
                        const t = 2 * Math.sqrt(1 + a - i - h);
                        (this._w = (s - l) / t), (this._x = (n + r) / t), (this._y = 0.25 * t), (this._z = (o + c) / t);
                    } else {
                        const t = 2 * Math.sqrt(1 + h - i - a);
                        (this._w = (r - n) / t), (this._x = (s + l) / t), (this._y = (o + c) / t), (this._z = 0.25 * t);
                    }
                    return this._onChangeCallback(), this;
                }
                setFromUnitVectors(t, e) {
                    let i = t.dot(e) + 1;
                    return i < Number.EPSILON ? ((i = 0), Math.abs(t.x) > Math.abs(t.z) ? ((this._x = -t.y), (this._y = t.x), (this._z = 0), (this._w = i)) : ((this._x = 0), (this._y = -t.z), (this._z = t.y), (this._w = i))) : ((this._x = t.y * e.z - t.z * e.y), (this._y = t.z * e.x - t.x * e.z), (this._z = t.x * e.y - t.y * e.x), (this._w = i)), this.normalize();
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(ct(this.dot(t), -1, 1)));
                }
                rotateTowards(t, e) {
                    const i = this.angleTo(t);
                    if (0 === i) return this;
                    const n = Math.min(1, e / i);
                    return this.slerp(t, n), this;
                }
                identity() {
                    return this.set(0, 0, 0, 1);
                }
                invert() {
                    return this.conjugate();
                }
                conjugate() {
                    return (this._x *= -1), (this._y *= -1), (this._z *= -1), this._onChangeCallback(), this;
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1)) : ((t = 1 / t), (this._x = this._x * t), (this._y = this._y * t), (this._z = this._z * t), (this._w = this._w * t)), this._onChangeCallback(), this;
                }
                multiply(t, e) {
                    return void 0 !== e ? this.multiplyQuaternions(t, e) : this.multiplyQuaternions(this, t);
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this);
                }
                multiplyQuaternions(t, e) {
                    const i = t._x,
                        n = t._y,
                        s = t._z,
                        r = t._w,
                        a = e._x,
                        o = e._y,
                        l = e._z,
                        c = e._w;
                    return (this._x = i * c + r * a + n * l - s * o), (this._y = n * c + r * o + s * a - i * l), (this._z = s * c + r * l + i * o - n * a), (this._w = r * c - i * a - n * o - s * l), this._onChangeCallback(), this;
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const i = this._x,
                        n = this._y,
                        s = this._z,
                        r = this._w;
                    let a = r * t._w + i * t._x + n * t._y + s * t._z;
                    if ((a < 0 ? ((this._w = -t._w), (this._x = -t._x), (this._y = -t._y), (this._z = -t._z), (a = -a)) : this.copy(t), a >= 1)) return (this._w = r), (this._x = i), (this._y = n), (this._z = s), this;
                    const o = 1 - a * a;
                    if (o <= Number.EPSILON) {
                        const t = 1 - e;
                        return (this._w = t * r + e * this._w), (this._x = t * i + e * this._x), (this._y = t * n + e * this._y), (this._z = t * s + e * this._z), this.normalize(), this._onChangeCallback(), this;
                    }
                    const l = Math.sqrt(o),
                        c = Math.atan2(l, a),
                        h = Math.sin((1 - e) * c) / l,
                        u = Math.sin(e * c) / l;
                    return (this._w = r * h + this._w * u), (this._x = i * h + this._x * u), (this._y = n * h + this._y * u), (this._z = s * h + this._z * u), this._onChangeCallback(), this;
                }
                slerpQuaternions(t, e, i) {
                    this.copy(t).slerp(e, i);
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
                }
                fromArray(t, e = 0) {
                    return (this._x = t[e]), (this._y = t[e + 1]), (this._z = t[e + 2]), (this._w = t[e + 3]), this._onChangeCallback(), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._w), t;
                }
                fromBufferAttribute(t, e) {
                    return (this._x = t.getX(e)), (this._y = t.getY(e)), (this._z = t.getZ(e)), (this._w = t.getW(e)), this;
                }
                _onChange(t) {
                    return (this._onChangeCallback = t), this;
                }
                _onChangeCallback() {}
            }
            Et.prototype.isQuaternion = !0;
            class bt {
                constructor(t = 0, e = 0, i = 0) {
                    (this.x = t), (this.y = e), (this.z = i);
                }
                set(t, e, i) {
                    return void 0 === i && (i = this.z), (this.x = t), (this.y = e), (this.z = i), this;
                }
                setScalar(t) {
                    return (this.x = t), (this.y = t), (this.z = t), this;
                }
                setX(t) {
                    return (this.x = t), this;
                }
                setY(t) {
                    return (this.y = t), this;
                }
                setZ(t) {
                    return (this.z = t), this;
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t);
                    }
                    return this;
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t);
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z);
                }
                copy(t) {
                    return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
                }
                add(t, e) {
                    return void 0 !== e ? this.addVectors(t, e) : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
                }
                addScalar(t) {
                    return (this.x += t), (this.y += t), (this.z += t), this;
                }
                addVectors(t, e) {
                    return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
                }
                addScaledVector(t, e) {
                    return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
                }
                sub(t, e) {
                    return void 0 !== e ? this.subVectors(t, e) : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
                }
                subScalar(t) {
                    return (this.x -= t), (this.y -= t), (this.z -= t), this;
                }
                subVectors(t, e) {
                    return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
                }
                multiply(t, e) {
                    return void 0 !== e ? this.multiplyVectors(t, e) : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
                }
                multiplyScalar(t) {
                    return (this.x *= t), (this.y *= t), (this.z *= t), this;
                }
                multiplyVectors(t, e) {
                    return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
                }
                applyEuler(t) {
                    return t && t.isEuler, this.applyQuaternion(Bt.setFromEuler(t));
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(Bt.setFromAxisAngle(t, e));
                }
                applyMatrix3(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        s = t.elements;
                    return (this.x = s[0] * e + s[3] * i + s[6] * n), (this.y = s[1] * e + s[4] * i + s[7] * n), (this.z = s[2] * e + s[5] * i + s[8] * n), this;
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize();
                }
                applyMatrix4(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        s = t.elements,
                        r = 1 / (s[3] * e + s[7] * i + s[11] * n + s[15]);
                    return (this.x = (s[0] * e + s[4] * i + s[8] * n + s[12]) * r), (this.y = (s[1] * e + s[5] * i + s[9] * n + s[13]) * r), (this.z = (s[2] * e + s[6] * i + s[10] * n + s[14]) * r), this;
                }
                applyQuaternion(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        s = t.x,
                        r = t.y,
                        a = t.z,
                        o = t.w,
                        l = o * e + r * n - a * i,
                        c = o * i + a * e - s * n,
                        h = o * n + s * i - r * e,
                        u = -s * e - r * i - a * n;
                    return (this.x = l * o + u * -s + c * -a - h * -r), (this.y = c * o + u * -r + h * -s - l * -a), (this.z = h * o + u * -a + l * -r - c * -s), this;
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
                }
                transformDirection(t) {
                    const e = this.x,
                        i = this.y,
                        n = this.z,
                        s = t.elements;
                    return (this.x = s[0] * e + s[4] * i + s[8] * n), (this.y = s[1] * e + s[5] * i + s[9] * n), (this.z = s[2] * e + s[6] * i + s[10] * n), this.normalize();
                }
                divide(t) {
                    return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t);
                }
                min(t) {
                    return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), (this.z = Math.min(this.z, t.z)), this;
                }
                max(t) {
                    return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), (this.z = Math.max(this.z, t.z)), this;
                }
                clamp(t, e) {
                    return (this.x = Math.max(t.x, Math.min(e.x, this.x))), (this.y = Math.max(t.y, Math.min(e.y, this.y))), (this.z = Math.max(t.z, Math.min(e.z, this.z))), this;
                }
                clampScalar(t, e) {
                    return (this.x = Math.max(t, Math.min(e, this.x))), (this.y = Math.max(t, Math.min(e, this.y))), (this.z = Math.max(t, Math.min(e, this.z))), this;
                }
                clampLength(t, e) {
                    const i = this.length();
                    return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
                }
                floor() {
                    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), (this.z = Math.floor(this.z)), this;
                }
                ceil() {
                    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), (this.z = Math.ceil(this.z)), this;
                }
                round() {
                    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), (this.z = Math.round(this.z)), this;
                }
                roundToZero() {
                    return (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)), (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)), (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)), this;
                }
                negate() {
                    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z;
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z;
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                }
                normalize() {
                    return this.divideScalar(this.length() || 1);
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t);
                }
                lerp(t, e) {
                    return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), (this.z += (t.z - this.z) * e), this;
                }
                lerpVectors(t, e, i) {
                    return (this.x = t.x + (e.x - t.x) * i), (this.y = t.y + (e.y - t.y) * i), (this.z = t.z + (e.z - t.z) * i), this;
                }
                cross(t, e) {
                    return void 0 !== e ? this.crossVectors(t, e) : this.crossVectors(this, t);
                }
                crossVectors(t, e) {
                    const i = t.x,
                        n = t.y,
                        s = t.z,
                        r = e.x,
                        a = e.y,
                        o = e.z;
                    return (this.x = n * o - s * a), (this.y = s * r - i * o), (this.z = i * a - n * r), this;
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const i = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(i);
                }
                projectOnPlane(t) {
                    return St.copy(this).projectOnVector(t), this.sub(St);
                }
                reflect(t) {
                    return this.sub(St.copy(t).multiplyScalar(2 * this.dot(t)));
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const i = this.dot(t) / e;
                    return Math.acos(ct(i, -1, 1));
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t));
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        i = this.y - t.y,
                        n = this.z - t.z;
                    return e * e + i * i + n * n;
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
                }
                setFromSphericalCoords(t, e, i) {
                    const n = Math.sin(e) * t;
                    return (this.x = n * Math.sin(i)), (this.y = Math.cos(e) * t), (this.z = n * Math.cos(i)), this;
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
                }
                setFromCylindricalCoords(t, e, i) {
                    return (this.x = t * Math.sin(e)), (this.y = i), (this.z = t * Math.cos(e)), this;
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        i = this.setFromMatrixColumn(t, 1).length(),
                        n = this.setFromMatrixColumn(t, 2).length();
                    return (this.x = e), (this.y = i), (this.z = n), this;
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e);
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e);
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z;
                }
                fromArray(t, e = 0) {
                    return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
                }
                fromBufferAttribute(t, e, i) {
                    return (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this;
                }
                random() {
                    return (this.x = Math.random()), (this.y = Math.random()), (this.z = Math.random()), this;
                }
            }
            bt.prototype.isVector3 = !0;
            const St = new bt(),
                Bt = new Et();
            class Tt {
                constructor(t = new bt(1 / 0, 1 / 0, 1 / 0), e = new bt(-1 / 0, -1 / 0, -1 / 0)) {
                    (this.min = t), (this.max = e);
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this;
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        s = -1 / 0,
                        r = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.length; o < l; o += 3) {
                        const l = t[o],
                            c = t[o + 1],
                            h = t[o + 2];
                        l < e && (e = l), c < i && (i = c), h < n && (n = h), l > s && (s = l), c > r && (r = c), h > a && (a = h);
                    }
                    return this.min.set(e, i, n), this.max.set(s, r, a), this;
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        i = 1 / 0,
                        n = 1 / 0,
                        s = -1 / 0,
                        r = -1 / 0,
                        a = -1 / 0;
                    for (let o = 0, l = t.count; o < l; o++) {
                        const l = t.getX(o),
                            c = t.getY(o),
                            h = t.getZ(o);
                        l < e && (e = l), c < i && (i = c), h < n && (n = h), l > s && (s = l), c > r && (r = c), h > a && (a = h);
                    }
                    return this.min.set(e, i, n), this.max.set(s, r, a), this;
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
                    return this;
                }
                setFromCenterAndSize(t, e) {
                    const i = Dt.copy(e).multiplyScalar(0.5);
                    return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
                }
                setFromObject(t) {
                    return this.makeEmpty(), this.expandByObject(t);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this;
                }
                makeEmpty() {
                    return (this.min.x = this.min.y = this.min.z = 1 / 0), (this.max.x = this.max.y = this.max.z = -1 / 0), this;
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
                }
                getCenter(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
                }
                getSize(t) {
                    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this;
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this;
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this;
                }
                expandByObject(t) {
                    t.updateWorldMatrix(!1, !1);
                    const e = t.geometry;
                    void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Qt.copy(e.boundingBox), Qt.applyMatrix4(t.matrixWorld), this.union(Qt));
                    const i = t.children;
                    for (let t = 0, e = i.length; t < e; t++) this.expandByObject(i[t]);
                    return this;
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
                }
                getParameter(t, e) {
                    return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, Dt), Dt.distanceToSquared(t.center) <= t.radius * t.radius;
                }
                intersectsPlane(t) {
                    let e, i;
                    return t.normal.x > 0 ? ((e = t.normal.x * this.min.x), (i = t.normal.x * this.max.x)) : ((e = t.normal.x * this.max.x), (i = t.normal.x * this.min.x)), t.normal.y > 0 ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y)) : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)), t.normal.z > 0 ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z)) : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)), e <= -t.constant && i >= -t.constant;
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Ot), Gt.subVectors(this.max, Ot), Rt.subVectors(t.a, Ot), Pt.subVectors(t.b, Ot), Nt.subVectors(t.c, Ot), Ft.subVectors(Pt, Rt), Ut.subVectors(Nt, Pt), kt.subVectors(Rt, Nt);
                    let e = [0, -Ft.z, Ft.y, 0, -Ut.z, Ut.y, 0, -kt.z, kt.y, Ft.z, 0, -Ft.x, Ut.z, 0, -Ut.x, kt.z, 0, -kt.x, -Ft.y, Ft.x, 0, -Ut.y, Ut.x, 0, -kt.y, kt.x, 0];
                    return !!Ht(e, Rt, Pt, Nt, Gt) && ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !!Ht(e, Rt, Pt, Nt, Gt) && (zt.crossVectors(Ft, Ut), (e = [zt.x, zt.y, zt.z]), Ht(e, Rt, Pt, Nt, Gt)));
                }
                clampPoint(t, e) {
                    return e.copy(t).clamp(this.min, this.max);
                }
                distanceToPoint(t) {
                    return Dt.copy(t).clamp(this.min, this.max).sub(t).length();
                }
                getBoundingSphere(t) {
                    return this.getCenter(t.center), (t.radius = 0.5 * this.getSize(Dt).length()), t;
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this;
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (Lt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Lt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Lt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Lt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Lt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Lt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Lt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Lt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Lt)), this;
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this;
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max);
                }
            }
            Tt.prototype.isBox3 = !0;
            const Lt = [new bt(), new bt(), new bt(), new bt(), new bt(), new bt(), new bt(), new bt()],
                Dt = new bt(),
                Qt = new Tt(),
                Rt = new bt(),
                Pt = new bt(),
                Nt = new bt(),
                Ft = new bt(),
                Ut = new bt(),
                kt = new bt(),
                Ot = new bt(),
                Gt = new bt(),
                zt = new bt(),
                Vt = new bt();
            function Ht(t, e, i, n, s) {
                for (let r = 0, a = t.length - 3; r <= a; r += 3) {
                    Vt.fromArray(t, r);
                    const a = s.x * Math.abs(Vt.x) + s.y * Math.abs(Vt.y) + s.z * Math.abs(Vt.z),
                        o = e.dot(Vt),
                        l = i.dot(Vt),
                        c = n.dot(Vt);
                    if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
                }
                return !0;
            }
            const Wt = new Tt(),
                qt = new bt(),
                jt = new bt(),
                Yt = new bt();
            class Jt {
                constructor(t = new bt(), e = -1) {
                    (this.center = t), (this.radius = e);
                }
                set(t, e) {
                    return this.center.copy(t), (this.radius = e), this;
                }
                setFromPoints(t, e) {
                    const i = this.center;
                    void 0 !== e ? i.copy(e) : Wt.setFromPoints(t).getCenter(i);
                    let n = 0;
                    for (let e = 0, s = t.length; e < s; e++) n = Math.max(n, i.distanceToSquared(t[e]));
                    return (this.radius = Math.sqrt(n)), this;
                }
                copy(t) {
                    return this.center.copy(t.center), (this.radius = t.radius), this;
                }
                isEmpty() {
                    return this.radius < 0;
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), (this.radius = -1), this;
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius;
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius;
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e;
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this);
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
                }
                clampPoint(t, e) {
                    const i = this.center.distanceToSquared(t);
                    return e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
                }
                getBoundingBox(t) {
                    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), (this.radius = this.radius * t.getMaxScaleOnAxis()), this;
                }
                translate(t) {
                    return this.center.add(t), this;
                }
                expandByPoint(t) {
                    Yt.subVectors(t, this.center);
                    const e = Yt.lengthSq();
                    if (e > this.radius * this.radius) {
                        const t = Math.sqrt(e),
                            i = 0.5 * (t - this.radius);
                        this.center.add(Yt.multiplyScalar(i / t)), (this.radius += i);
                    }
                    return this;
                }
                union(t) {
                    return jt.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(qt.copy(t.center).add(jt)), this.expandByPoint(qt.copy(t.center).sub(jt)), this;
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            const Xt = new bt(),
                Kt = new bt(),
                Zt = new bt(),
                $t = new bt(),
                te = new bt(),
                ee = new bt(),
                ie = new bt();
            class ne {
                constructor(t = new bt(), e = new bt(0, 0, -1)) {
                    (this.origin = t), (this.direction = e);
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this;
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
                }
                at(t, e) {
                    return e.copy(this.direction).multiplyScalar(t).add(this.origin);
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this;
                }
                recast(t) {
                    return this.origin.copy(this.at(t, Xt)), this;
                }
                closestPointToPoint(t, e) {
                    e.subVectors(t, this.origin);
                    const i = e.dot(this.direction);
                    return i < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(i).add(this.origin);
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t));
                }
                distanceSqToPoint(t) {
                    const e = Xt.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Xt.copy(this.direction).multiplyScalar(e).add(this.origin), Xt.distanceToSquared(t));
                }
                distanceSqToSegment(t, e, i, n) {
                    Kt.copy(t).add(e).multiplyScalar(0.5), Zt.copy(e).sub(t).normalize(), $t.copy(this.origin).sub(Kt);
                    const s = 0.5 * t.distanceTo(e),
                        r = -this.direction.dot(Zt),
                        a = $t.dot(this.direction),
                        o = -$t.dot(Zt),
                        l = $t.lengthSq(),
                        c = Math.abs(1 - r * r);
                    let h, u, d, p;
                    if (c > 0)
                        if (((h = r * o - a), (u = r * a - o), (p = s * c), h >= 0))
                            if (u >= -p)
                                if (u <= p) {
                                    const t = 1 / c;
                                    (h *= t), (u *= t), (d = h * (h + r * u + 2 * a) + u * (r * h + u + 2 * o) + l);
                                } else (u = s), (h = Math.max(0, -(r * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                            else (u = -s), (h = Math.max(0, -(r * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                        else u <= -p ? ((h = Math.max(0, -(-r * s + a))), (u = h > 0 ? -s : Math.min(Math.max(-s, -o), s)), (d = -h * h + u * (u + 2 * o) + l)) : u <= p ? ((h = 0), (u = Math.min(Math.max(-s, -o), s)), (d = u * (u + 2 * o) + l)) : ((h = Math.max(0, -(r * s + a))), (u = h > 0 ? s : Math.min(Math.max(-s, -o), s)), (d = -h * h + u * (u + 2 * o) + l));
                    else (u = r > 0 ? -s : s), (h = Math.max(0, -(r * u + a))), (d = -h * h + u * (u + 2 * o) + l);
                    return i && i.copy(this.direction).multiplyScalar(h).add(this.origin), n && n.copy(Zt).multiplyScalar(u).add(Kt), d;
                }
                intersectSphere(t, e) {
                    Xt.subVectors(t.center, this.origin);
                    const i = Xt.dot(this.direction),
                        n = Xt.dot(Xt) - i * i,
                        s = t.radius * t.radius;
                    if (n > s) return null;
                    const r = Math.sqrt(s - n),
                        a = i - r,
                        o = i + r;
                    return a < 0 && o < 0 ? null : a < 0 ? this.at(o, e) : this.at(a, e);
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const i = -(this.origin.dot(t.normal) + t.constant) / e;
                    return i >= 0 ? i : null;
                }
                intersectPlane(t, e) {
                    const i = this.distanceToPlane(t);
                    return null === i ? null : this.at(i, e);
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0;
                }
                intersectBox(t, e) {
                    let i, n, s, r, a, o;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? ((i = (t.min.x - u.x) * l), (n = (t.max.x - u.x) * l)) : ((i = (t.max.x - u.x) * l), (n = (t.min.x - u.x) * l)), c >= 0 ? ((s = (t.min.y - u.y) * c), (r = (t.max.y - u.y) * c)) : ((s = (t.max.y - u.y) * c), (r = (t.min.y - u.y) * c)), i > r || s > n ? null : ((s > i || i != i) && (i = s), (r < n || n != n) && (n = r), h >= 0 ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h)) : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)), i > o || a > n ? null : ((a > i || i != i) && (i = a), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, e)));
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, Xt);
                }
                intersectTriangle(t, e, i, n, s) {
                    te.subVectors(e, t), ee.subVectors(i, t), ie.crossVectors(te, ee);
                    let r,
                        a = this.direction.dot(ie);
                    if (a > 0) {
                        if (n) return null;
                        r = 1;
                    } else {
                        if (!(a < 0)) return null;
                        (r = -1), (a = -a);
                    }
                    $t.subVectors(this.origin, t);
                    const o = r * this.direction.dot(ee.crossVectors($t, ee));
                    if (o < 0) return null;
                    const l = r * this.direction.dot(te.cross($t));
                    if (l < 0) return null;
                    if (o + l > a) return null;
                    const c = -r * $t.dot(ie);
                    return c < 0 ? null : this.at(c / a, s);
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            class se {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                }
                set(t, e, i, n, s, r, a, o, l, c, h, u, d, p, A, g) {
                    const m = this.elements;
                    return (m[0] = t), (m[4] = e), (m[8] = i), (m[12] = n), (m[1] = s), (m[5] = r), (m[9] = a), (m[13] = o), (m[2] = l), (m[6] = c), (m[10] = h), (m[14] = u), (m[3] = d), (m[7] = p), (m[11] = A), (m[15] = g), this;
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                }
                clone() {
                    return new se().fromArray(this.elements);
                }
                copy(t) {
                    const e = this.elements,
                        i = t.elements;
                    return (e[0] = i[0]), (e[1] = i[1]), (e[2] = i[2]), (e[3] = i[3]), (e[4] = i[4]), (e[5] = i[5]), (e[6] = i[6]), (e[7] = i[7]), (e[8] = i[8]), (e[9] = i[9]), (e[10] = i[10]), (e[11] = i[11]), (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), (e[15] = i[15]), this;
                }
                copyPosition(t) {
                    const e = this.elements,
                        i = t.elements;
                    return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
                }
                setFromMatrix3(t) {
                    const e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
                }
                extractBasis(t, e, i) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
                }
                makeBasis(t, e, i) {
                    return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this;
                }
                extractRotation(t) {
                    const e = this.elements,
                        i = t.elements,
                        n = 1 / re.setFromMatrixColumn(t, 0).length(),
                        s = 1 / re.setFromMatrixColumn(t, 1).length(),
                        r = 1 / re.setFromMatrixColumn(t, 2).length();
                    return (e[0] = i[0] * n), (e[1] = i[1] * n), (e[2] = i[2] * n), (e[3] = 0), (e[4] = i[4] * s), (e[5] = i[5] * s), (e[6] = i[6] * s), (e[7] = 0), (e[8] = i[8] * r), (e[9] = i[9] * r), (e[10] = i[10] * r), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this;
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler;
                    const e = this.elements,
                        i = t.x,
                        n = t.y,
                        s = t.z,
                        r = Math.cos(i),
                        a = Math.sin(i),
                        o = Math.cos(n),
                        l = Math.sin(n),
                        c = Math.cos(s),
                        h = Math.sin(s);
                    if ("XYZ" === t.order) {
                        const t = r * c,
                            i = r * h,
                            n = a * c,
                            s = a * h;
                        (e[0] = o * c), (e[4] = -o * h), (e[8] = l), (e[1] = i + n * l), (e[5] = t - s * l), (e[9] = -a * o), (e[2] = s - t * l), (e[6] = n + i * l), (e[10] = r * o);
                    } else if ("YXZ" === t.order) {
                        const t = o * c,
                            i = o * h,
                            n = l * c,
                            s = l * h;
                        (e[0] = t + s * a), (e[4] = n * a - i), (e[8] = r * l), (e[1] = r * h), (e[5] = r * c), (e[9] = -a), (e[2] = i * a - n), (e[6] = s + t * a), (e[10] = r * o);
                    } else if ("ZXY" === t.order) {
                        const t = o * c,
                            i = o * h,
                            n = l * c,
                            s = l * h;
                        (e[0] = t - s * a), (e[4] = -r * h), (e[8] = n + i * a), (e[1] = i + n * a), (e[5] = r * c), (e[9] = s - t * a), (e[2] = -r * l), (e[6] = a), (e[10] = r * o);
                    } else if ("ZYX" === t.order) {
                        const t = r * c,
                            i = r * h,
                            n = a * c,
                            s = a * h;
                        (e[0] = o * c), (e[4] = n * l - i), (e[8] = t * l + s), (e[1] = o * h), (e[5] = s * l + t), (e[9] = i * l - n), (e[2] = -l), (e[6] = a * o), (e[10] = r * o);
                    } else if ("YZX" === t.order) {
                        const t = r * o,
                            i = r * l,
                            n = a * o,
                            s = a * l;
                        (e[0] = o * c), (e[4] = s - t * h), (e[8] = n * h + i), (e[1] = h), (e[5] = r * c), (e[9] = -a * c), (e[2] = -l * c), (e[6] = i * h + n), (e[10] = t - s * h);
                    } else if ("XZY" === t.order) {
                        const t = r * o,
                            i = r * l,
                            n = a * o,
                            s = a * l;
                        (e[0] = o * c), (e[4] = -h), (e[8] = l * c), (e[1] = t * h + s), (e[5] = r * c), (e[9] = i * h - n), (e[2] = n * h - i), (e[6] = a * c), (e[10] = s * h + t);
                    }
                    return (e[3] = 0), (e[7] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), this;
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(oe, t, le);
                }
                lookAt(t, e, i) {
                    const n = this.elements;
                    return ue.subVectors(t, e), 0 === ue.lengthSq() && (ue.z = 1), ue.normalize(), ce.crossVectors(i, ue), 0 === ce.lengthSq() && (1 === Math.abs(i.z) ? (ue.x += 1e-4) : (ue.z += 1e-4), ue.normalize(), ce.crossVectors(i, ue)), ce.normalize(), he.crossVectors(ue, ce), (n[0] = ce.x), (n[4] = he.x), (n[8] = ue.x), (n[1] = ce.y), (n[5] = he.y), (n[9] = ue.y), (n[2] = ce.z), (n[6] = he.z), (n[10] = ue.z), this;
                }
                multiply(t, e) {
                    return void 0 !== e ? this.multiplyMatrices(t, e) : this.multiplyMatrices(this, t);
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this);
                }
                multiplyMatrices(t, e) {
                    const i = t.elements,
                        n = e.elements,
                        s = this.elements,
                        r = i[0],
                        a = i[4],
                        o = i[8],
                        l = i[12],
                        c = i[1],
                        h = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        A = i[6],
                        g = i[10],
                        m = i[14],
                        f = i[3],
                        v = i[7],
                        y = i[11],
                        x = i[15],
                        w = n[0],
                        _ = n[4],
                        I = n[8],
                        C = n[12],
                        M = n[1],
                        E = n[5],
                        b = n[9],
                        S = n[13],
                        B = n[2],
                        T = n[6],
                        L = n[10],
                        D = n[14],
                        Q = n[3],
                        R = n[7],
                        P = n[11],
                        N = n[15];
                    return (s[0] = r * w + a * M + o * B + l * Q), (s[4] = r * _ + a * E + o * T + l * R), (s[8] = r * I + a * b + o * L + l * P), (s[12] = r * C + a * S + o * D + l * N), (s[1] = c * w + h * M + u * B + d * Q), (s[5] = c * _ + h * E + u * T + d * R), (s[9] = c * I + h * b + u * L + d * P), (s[13] = c * C + h * S + u * D + d * N), (s[2] = p * w + A * M + g * B + m * Q), (s[6] = p * _ + A * E + g * T + m * R), (s[10] = p * I + A * b + g * L + m * P), (s[14] = p * C + A * S + g * D + m * N), (s[3] = f * w + v * M + y * B + x * Q), (s[7] = f * _ + v * E + y * T + x * R), (s[11] = f * I + v * b + y * L + x * P), (s[15] = f * C + v * S + y * D + x * N), this;
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return (e[0] *= t), (e[4] *= t), (e[8] *= t), (e[12] *= t), (e[1] *= t), (e[5] *= t), (e[9] *= t), (e[13] *= t), (e[2] *= t), (e[6] *= t), (e[10] *= t), (e[14] *= t), (e[3] *= t), (e[7] *= t), (e[11] *= t), (e[15] *= t), this;
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        i = t[4],
                        n = t[8],
                        s = t[12],
                        r = t[1],
                        a = t[5],
                        o = t[9],
                        l = t[13],
                        c = t[2],
                        h = t[6],
                        u = t[10],
                        d = t[14];
                    return t[3] * (+s * o * h - n * l * h - s * a * u + i * l * u + n * a * d - i * o * d) + t[7] * (+e * o * d - e * l * u + s * r * u - n * r * d + n * l * c - s * o * c) + t[11] * (+e * l * h - e * a * d - s * r * h + i * r * d + s * a * c - i * l * c) + t[15] * (-n * a * c - e * o * h + e * a * u + n * r * h - i * r * u + i * o * c);
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return (e = t[1]), (t[1] = t[4]), (t[4] = e), (e = t[2]), (t[2] = t[8]), (t[8] = e), (e = t[6]), (t[6] = t[9]), (t[9] = e), (e = t[3]), (t[3] = t[12]), (t[12] = e), (e = t[7]), (t[7] = t[13]), (t[13] = e), (e = t[11]), (t[11] = t[14]), (t[14] = e), this;
                }
                setPosition(t, e, i) {
                    const n = this.elements;
                    return t.isVector3 ? ((n[12] = t.x), (n[13] = t.y), (n[14] = t.z)) : ((n[12] = t), (n[13] = e), (n[14] = i)), this;
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        i = t[1],
                        n = t[2],
                        s = t[3],
                        r = t[4],
                        a = t[5],
                        o = t[6],
                        l = t[7],
                        c = t[8],
                        h = t[9],
                        u = t[10],
                        d = t[11],
                        p = t[12],
                        A = t[13],
                        g = t[14],
                        m = t[15],
                        f = h * g * l - A * u * l + A * o * d - a * g * d - h * o * m + a * u * m,
                        v = p * u * l - c * g * l - p * o * d + r * g * d + c * o * m - r * u * m,
                        y = c * A * l - p * h * l + p * a * d - r * A * d - c * a * m + r * h * m,
                        x = p * h * o - c * A * o - p * a * u + r * A * u + c * a * g - r * h * g,
                        w = e * f + i * v + n * y + s * x;
                    if (0 === w) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const _ = 1 / w;
                    return (t[0] = f * _), (t[1] = (A * u * s - h * g * s - A * n * d + i * g * d + h * n * m - i * u * m) * _), (t[2] = (a * g * s - A * o * s + A * n * l - i * g * l - a * n * m + i * o * m) * _), (t[3] = (h * o * s - a * u * s - h * n * l + i * u * l + a * n * d - i * o * d) * _), (t[4] = v * _), (t[5] = (c * g * s - p * u * s + p * n * d - e * g * d - c * n * m + e * u * m) * _), (t[6] = (p * o * s - r * g * s - p * n * l + e * g * l + r * n * m - e * o * m) * _), (t[7] = (r * u * s - c * o * s + c * n * l - e * u * l - r * n * d + e * o * d) * _), (t[8] = y * _), (t[9] = (p * h * s - c * A * s - p * i * d + e * A * d + c * i * m - e * h * m) * _), (t[10] = (r * A * s - p * a * s + p * i * l - e * A * l - r * i * m + e * a * m) * _), (t[11] = (c * a * s - r * h * s - c * i * l + e * h * l + r * i * d - e * a * d) * _), (t[12] = x * _), (t[13] = (c * A * n - p * h * n + p * i * u - e * A * u - c * i * g + e * h * g) * _), (t[14] = (p * a * n - r * A * n - p * i * o + e * A * o + r * i * g - e * a * g) * _), (t[15] = (r * h * n - c * a * n + c * i * o - e * h * o - r * i * u + e * a * u) * _), this;
                }
                scale(t) {
                    const e = this.elements,
                        i = t.x,
                        n = t.y,
                        s = t.z;
                    return (e[0] *= i), (e[4] *= n), (e[8] *= s), (e[1] *= i), (e[5] *= n), (e[9] *= s), (e[2] *= i), (e[6] *= n), (e[10] *= s), (e[3] *= i), (e[7] *= n), (e[11] *= s), this;
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, i, n));
                }
                makeTranslation(t, e, i) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        i = Math.sin(t);
                    return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
                }
                makeRotationAxis(t, e) {
                    const i = Math.cos(e),
                        n = Math.sin(e),
                        s = 1 - i,
                        r = t.x,
                        a = t.y,
                        o = t.z,
                        l = s * r,
                        c = s * a;
                    return this.set(l * r + i, l * a - n * o, l * o + n * a, 0, l * a + n * o, c * a + i, c * o - n * r, 0, l * o - n * a, c * o + n * r, s * o * o + i, 0, 0, 0, 0, 1), this;
                }
                makeScale(t, e, i) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
                }
                makeShear(t, e, i, n, s, r) {
                    return this.set(1, i, s, 0, t, 1, r, 0, e, n, 1, 0, 0, 0, 0, 1), this;
                }
                compose(t, e, i) {
                    const n = this.elements,
                        s = e._x,
                        r = e._y,
                        a = e._z,
                        o = e._w,
                        l = s + s,
                        c = r + r,
                        h = a + a,
                        u = s * l,
                        d = s * c,
                        p = s * h,
                        A = r * c,
                        g = r * h,
                        m = a * h,
                        f = o * l,
                        v = o * c,
                        y = o * h,
                        x = i.x,
                        w = i.y,
                        _ = i.z;
                    return (n[0] = (1 - (A + m)) * x), (n[1] = (d + y) * x), (n[2] = (p - v) * x), (n[3] = 0), (n[4] = (d - y) * w), (n[5] = (1 - (u + m)) * w), (n[6] = (g + f) * w), (n[7] = 0), (n[8] = (p + v) * _), (n[9] = (g - f) * _), (n[10] = (1 - (u + A)) * _), (n[11] = 0), (n[12] = t.x), (n[13] = t.y), (n[14] = t.z), (n[15] = 1), this;
                }
                decompose(t, e, i) {
                    const n = this.elements;
                    let s = re.set(n[0], n[1], n[2]).length();
                    const r = re.set(n[4], n[5], n[6]).length(),
                        a = re.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (s = -s), (t.x = n[12]), (t.y = n[13]), (t.z = n[14]), ae.copy(this);
                    const o = 1 / s,
                        l = 1 / r,
                        c = 1 / a;
                    return (ae.elements[0] *= o), (ae.elements[1] *= o), (ae.elements[2] *= o), (ae.elements[4] *= l), (ae.elements[5] *= l), (ae.elements[6] *= l), (ae.elements[8] *= c), (ae.elements[9] *= c), (ae.elements[10] *= c), e.setFromRotationMatrix(ae), (i.x = s), (i.y = r), (i.z = a), this;
                }
                makePerspective(t, e, i, n, s, r) {
                    const a = this.elements,
                        o = (2 * s) / (e - t),
                        l = (2 * s) / (i - n),
                        c = (e + t) / (e - t),
                        h = (i + n) / (i - n),
                        u = -(r + s) / (r - s),
                        d = (-2 * r * s) / (r - s);
                    return (a[0] = o), (a[4] = 0), (a[8] = c), (a[12] = 0), (a[1] = 0), (a[5] = l), (a[9] = h), (a[13] = 0), (a[2] = 0), (a[6] = 0), (a[10] = u), (a[14] = d), (a[3] = 0), (a[7] = 0), (a[11] = -1), (a[15] = 0), this;
                }
                makeOrthographic(t, e, i, n, s, r) {
                    const a = this.elements,
                        o = 1 / (e - t),
                        l = 1 / (i - n),
                        c = 1 / (r - s),
                        h = (e + t) * o,
                        u = (i + n) * l,
                        d = (r + s) * c;
                    return (a[0] = 2 * o), (a[4] = 0), (a[8] = 0), (a[12] = -h), (a[1] = 0), (a[5] = 2 * l), (a[9] = 0), (a[13] = -u), (a[2] = 0), (a[6] = 0), (a[10] = -2 * c), (a[14] = -d), (a[3] = 0), (a[7] = 0), (a[11] = 0), (a[15] = 1), this;
                }
                equals(t) {
                    const e = this.elements,
                        i = t.elements;
                    for (let t = 0; t < 16; t++) if (e[t] !== i[t]) return !1;
                    return !0;
                }
                fromArray(t, e = 0) {
                    for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
                    return this;
                }
                toArray(t = [], e = 0) {
                    const i = this.elements;
                    return (t[e] = i[0]), (t[e + 1] = i[1]), (t[e + 2] = i[2]), (t[e + 3] = i[3]), (t[e + 4] = i[4]), (t[e + 5] = i[5]), (t[e + 6] = i[6]), (t[e + 7] = i[7]), (t[e + 8] = i[8]), (t[e + 9] = i[9]), (t[e + 10] = i[10]), (t[e + 11] = i[11]), (t[e + 12] = i[12]), (t[e + 13] = i[13]), (t[e + 14] = i[14]), (t[e + 15] = i[15]), t;
                }
            }
            se.prototype.isMatrix4 = !0;
            const re = new bt(),
                ae = new se(),
                oe = new bt(0, 0, 0),
                le = new bt(1, 1, 1),
                ce = new bt(),
                he = new bt(),
                ue = new bt(),
                de = new se(),
                pe = new Et();
            class Ae {
                constructor(t = 0, e = 0, i = 0, n = Ae.DefaultOrder) {
                    (this._x = t), (this._y = e), (this._z = i), (this._order = n);
                }
                get x() {
                    return this._x;
                }
                set x(t) {
                    (this._x = t), this._onChangeCallback();
                }
                get y() {
                    return this._y;
                }
                set y(t) {
                    (this._y = t), this._onChangeCallback();
                }
                get z() {
                    return this._z;
                }
                set z(t) {
                    (this._z = t), this._onChangeCallback();
                }
                get order() {
                    return this._order;
                }
                set order(t) {
                    (this._order = t), this._onChangeCallback();
                }
                set(t, e, i, n = this._order) {
                    return (this._x = t), (this._y = e), (this._z = i), (this._order = n), this._onChangeCallback(), this;
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order);
                }
                copy(t) {
                    return (this._x = t._x), (this._y = t._y), (this._z = t._z), (this._order = t._order), this._onChangeCallback(), this;
                }
                setFromRotationMatrix(t, e = this._order, i = !0) {
                    const n = t.elements,
                        s = n[0],
                        r = n[4],
                        a = n[8],
                        o = n[1],
                        l = n[5],
                        c = n[9],
                        h = n[2],
                        u = n[6],
                        d = n[10];
                    switch (e) {
                        case "XYZ":
                            (this._y = Math.asin(ct(a, -1, 1))), Math.abs(a) < 0.9999999 ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-r, s))) : ((this._x = Math.atan2(u, l)), (this._z = 0));
                            break;
                        case "YXZ":
                            (this._x = Math.asin(-ct(c, -1, 1))), Math.abs(c) < 0.9999999 ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l))) : ((this._y = Math.atan2(-h, s)), (this._z = 0));
                            break;
                        case "ZXY":
                            (this._x = Math.asin(ct(u, -1, 1))), Math.abs(u) < 0.9999999 ? ((this._y = Math.atan2(-h, d)), (this._z = Math.atan2(-r, l))) : ((this._y = 0), (this._z = Math.atan2(o, s)));
                            break;
                        case "ZYX":
                            (this._y = Math.asin(-ct(h, -1, 1))), Math.abs(h) < 0.9999999 ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, s))) : ((this._x = 0), (this._z = Math.atan2(-r, l)));
                            break;
                        case "YZX":
                            (this._z = Math.asin(ct(o, -1, 1))), Math.abs(o) < 0.9999999 ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-h, s))) : ((this._x = 0), (this._y = Math.atan2(a, d)));
                            break;
                        case "XZY":
                            (this._z = Math.asin(-ct(r, -1, 1))), Math.abs(r) < 0.9999999 ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, s))) : ((this._x = Math.atan2(-c, d)), (this._y = 0));
                    }
                    return (this._order = e), !0 === i && this._onChangeCallback(), this;
                }
                setFromQuaternion(t, e, i) {
                    return de.makeRotationFromQuaternion(t), this.setFromRotationMatrix(de, e, i);
                }
                setFromVector3(t, e = this._order) {
                    return this.set(t.x, t.y, t.z, e);
                }
                reorder(t) {
                    return pe.setFromEuler(this), this.setFromQuaternion(pe, t);
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
                }
                fromArray(t) {
                    return (this._x = t[0]), (this._y = t[1]), (this._z = t[2]), void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this._x), (t[e + 1] = this._y), (t[e + 2] = this._z), (t[e + 3] = this._order), t;
                }
                toVector3(t) {
                    return t ? t.set(this._x, this._y, this._z) : new bt(this._x, this._y, this._z);
                }
                _onChange(t) {
                    return (this._onChangeCallback = t), this;
                }
                _onChangeCallback() {}
            }
            (Ae.prototype.isEuler = !0), (Ae.DefaultOrder = "XYZ"), (Ae.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
            class ge {
                constructor() {
                    this.mask = 1;
                }
                set(t) {
                    this.mask = 1 << t;
                }
                enable(t) {
                    this.mask |= 1 << t;
                }
                enableAll() {
                    this.mask = -1;
                }
                toggle(t) {
                    this.mask ^= 1 << t;
                }
                disable(t) {
                    this.mask &= ~(1 << t);
                }
                disableAll() {
                    this.mask = 0;
                }
                test(t) {
                    return !!(this.mask & t.mask);
                }
            }
            let me = 0;
            const fe = new bt(),
                ve = new Et(),
                ye = new se(),
                xe = new bt(),
                we = new bt(),
                _e = new bt(),
                Ie = new Et(),
                Ce = new bt(1, 0, 0),
                Me = new bt(0, 1, 0),
                Ee = new bt(0, 0, 1),
                be = { type: "added" },
                Se = { type: "removed" };
            class Be extends nt {
                constructor() {
                    super(), Object.defineProperty(this, "id", { value: me++ }), (this.uuid = lt()), (this.name = ""), (this.type = "Object3D"), (this.parent = null), (this.children = []), (this.up = Be.DefaultUp.clone());
                    const t = new bt(),
                        e = new Ae(),
                        i = new Et(),
                        n = new bt(1, 1, 1);
                    e._onChange(function () {
                        i.setFromEuler(e, !1);
                    }),
                        i._onChange(function () {
                            e.setFromQuaternion(i, void 0, !1);
                        }),
                        Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: n }, modelViewMatrix: { value: new se() }, normalMatrix: { value: new ft() } }),
                        (this.matrix = new se()),
                        (this.matrixWorld = new se()),
                        (this.matrixAutoUpdate = Be.DefaultMatrixAutoUpdate),
                        (this.matrixWorldNeedsUpdate = !1),
                        (this.layers = new ge()),
                        (this.visible = !0),
                        (this.castShadow = !1),
                        (this.receiveShadow = !1),
                        (this.frustumCulled = !0),
                        (this.renderOrder = 0),
                        (this.animations = []),
                        (this.userData = {});
                }
                onBeforeRender() {}
                onAfterRender() {}
                applyMatrix4(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
                }
                applyQuaternion(t) {
                    return this.quaternion.premultiply(t), this;
                }
                setRotationFromAxisAngle(t, e) {
                    this.quaternion.setFromAxisAngle(t, e);
                }
                setRotationFromEuler(t) {
                    this.quaternion.setFromEuler(t, !0);
                }
                setRotationFromMatrix(t) {
                    this.quaternion.setFromRotationMatrix(t);
                }
                setRotationFromQuaternion(t) {
                    this.quaternion.copy(t);
                }
                rotateOnAxis(t, e) {
                    return ve.setFromAxisAngle(t, e), this.quaternion.multiply(ve), this;
                }
                rotateOnWorldAxis(t, e) {
                    return ve.setFromAxisAngle(t, e), this.quaternion.premultiply(ve), this;
                }
                rotateX(t) {
                    return this.rotateOnAxis(Ce, t);
                }
                rotateY(t) {
                    return this.rotateOnAxis(Me, t);
                }
                rotateZ(t) {
                    return this.rotateOnAxis(Ee, t);
                }
                translateOnAxis(t, e) {
                    return fe.copy(t).applyQuaternion(this.quaternion), this.position.add(fe.multiplyScalar(e)), this;
                }
                translateX(t) {
                    return this.translateOnAxis(Ce, t);
                }
                translateY(t) {
                    return this.translateOnAxis(Me, t);
                }
                translateZ(t) {
                    return this.translateOnAxis(Ee, t);
                }
                localToWorld(t) {
                    return t.applyMatrix4(this.matrixWorld);
                }
                worldToLocal(t) {
                    return t.applyMatrix4(ye.copy(this.matrixWorld).invert());
                }
                lookAt(t, e, i) {
                    t.isVector3 ? xe.copy(t) : xe.set(t, e, i);
                    const n = this.parent;
                    this.updateWorldMatrix(!0, !1), we.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ye.lookAt(we, xe, this.up) : ye.lookAt(xe, we, this.up), this.quaternion.setFromRotationMatrix(ye), n && (ye.extractRotation(n.matrixWorld), ve.setFromRotationMatrix(ye), this.quaternion.premultiply(ve.invert()));
                }
                add(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this;
                    }
                    return t === this || (t && t.isObject3D && (null !== t.parent && t.parent.remove(t), (t.parent = this), this.children.push(t), t.dispatchEvent(be))), this;
                }
                remove(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this;
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && ((t.parent = null), this.children.splice(e, 1), t.dispatchEvent(Se)), this;
                }
                removeFromParent() {
                    const t = this.parent;
                    return null !== t && t.remove(this), this;
                }
                clear() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        (e.parent = null), e.dispatchEvent(Se);
                    }
                    return (this.children.length = 0), this;
                }
                attach(t) {
                    return this.updateWorldMatrix(!0, !1), ye.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), ye.multiply(t.parent.matrixWorld)), t.applyMatrix4(ye), this.add(t), t.updateWorldMatrix(!1, !0), this;
                }
                getObjectById(t) {
                    return this.getObjectByProperty("id", t);
                }
                getObjectByName(t) {
                    return this.getObjectByProperty("name", t);
                }
                getObjectByProperty(t, e) {
                    if (this[t] === e) return this;
                    for (let i = 0, n = this.children.length; i < n; i++) {
                        const n = this.children[i].getObjectByProperty(t, e);
                        if (void 0 !== n) return n;
                    }
                }
                getWorldPosition(t) {
                    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
                }
                getWorldQuaternion(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(we, t, _e), t;
                }
                getWorldScale(t) {
                    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(we, Ie, t), t;
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize();
                }
                raycast() {}
                traverse(t) {
                    t(this);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t);
                }
                traverseVisible(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t);
                }
                traverseAncestors(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t));
                }
                updateMatrix() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), (this.matrixWorldNeedsUpdate = !0);
                }
                updateMatrixWorld(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), (this.matrixWorldNeedsUpdate = !1), (t = !0));
                    const e = this.children;
                    for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t);
                }
                updateWorldMatrix(t, e) {
                    const i = this.parent;
                    if ((!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)) {
                        const t = this.children;
                        for (let e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0);
                    }
                }
                toJSON(t) {
                    const e = void 0 === t || "string" == typeof t,
                        i = {};
                    e && ((t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }), (i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }));
                    const n = {};
                    function s(e, i) {
                        return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid;
                    }
                    if (((n.uuid = this.uuid), (n.type = this.type), "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), (n.layers = this.layers.mask), (n.matrix = this.matrix.toArray()), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isInstancedMesh && ((n.type = "InstancedMesh"), (n.count = this.count), (n.instanceMatrix = this.instanceMatrix.toJSON()), null !== this.instanceColor && (n.instanceColor = this.instanceColor.toJSON())), this.isScene)) this.background && (this.background.isColor ? (n.background = this.background.toJSON()) : this.background.isTexture && (n.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (n.environment = this.environment.toJSON(t).uuid);
                    else if (this.isMesh || this.isLine || this.isPoints) {
                        n.geometry = s(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const i = e.shapes;
                            if (Array.isArray(i))
                                for (let e = 0, n = i.length; e < n; e++) {
                                    const n = i[e];
                                    s(t.shapes, n);
                                }
                            else s(t.shapes, i);
                        }
                    }
                    if ((this.isSkinnedMesh && ((n.bindMode = this.bindMode), (n.bindMatrix = this.bindMatrix.toArray()), void 0 !== this.skeleton && (s(t.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))), void 0 !== this.material))
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let i = 0, n = this.material.length; i < n; i++) e.push(s(t.materials, this.material[i]));
                            n.material = e;
                        } else n.material = s(t.materials, this.material);
                    if (this.children.length > 0) {
                        n.children = [];
                        for (let e = 0; e < this.children.length; e++) n.children.push(this.children[e].toJSON(t).object);
                    }
                    if (this.animations.length > 0) {
                        n.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            const i = this.animations[e];
                            n.animations.push(s(t.animations, i));
                        }
                    }
                    if (e) {
                        const e = r(t.geometries),
                            n = r(t.materials),
                            s = r(t.textures),
                            a = r(t.images),
                            o = r(t.shapes),
                            l = r(t.skeletons),
                            c = r(t.animations);
                        e.length > 0 && (i.geometries = e), n.length > 0 && (i.materials = n), s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a), o.length > 0 && (i.shapes = o), l.length > 0 && (i.skeletons = l), c.length > 0 && (i.animations = c);
                    }
                    return (i.object = n), i;
                    function r(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            delete n.metadata, e.push(n);
                        }
                        return e;
                    }
                }
                clone(t) {
                    return new this.constructor().copy(this, t);
                }
                copy(t, e = !0) {
                    if (((this.name = t.name), this.up.copy(t.up), this.position.copy(t.position), (this.rotation.order = t.rotation.order), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), (this.matrixAutoUpdate = t.matrixAutoUpdate), (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate), (this.layers.mask = t.layers.mask), (this.visible = t.visible), (this.castShadow = t.castShadow), (this.receiveShadow = t.receiveShadow), (this.frustumCulled = t.frustumCulled), (this.renderOrder = t.renderOrder), (this.userData = JSON.parse(JSON.stringify(t.userData))), !0 === e))
                        for (let e = 0; e < t.children.length; e++) {
                            const i = t.children[e];
                            this.add(i.clone());
                        }
                    return this;
                }
            }
            (Be.DefaultUp = new bt(0, 1, 0)), (Be.DefaultMatrixAutoUpdate = !0), (Be.prototype.isObject3D = !0);
            const Te = new bt(),
                Le = new bt(),
                De = new bt(),
                Qe = new bt(),
                Re = new bt(),
                Pe = new bt(),
                Ne = new bt(),
                Fe = new bt(),
                Ue = new bt(),
                ke = new bt();
            class Oe {
                constructor(t = new bt(), e = new bt(), i = new bt()) {
                    (this.a = t), (this.b = e), (this.c = i);
                }
                static getNormal(t, e, i, n) {
                    n.subVectors(i, e), Te.subVectors(t, e), n.cross(Te);
                    const s = n.lengthSq();
                    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
                }
                static getBarycoord(t, e, i, n, s) {
                    Te.subVectors(n, e), Le.subVectors(i, e), De.subVectors(t, e);
                    const r = Te.dot(Te),
                        a = Te.dot(Le),
                        o = Te.dot(De),
                        l = Le.dot(Le),
                        c = Le.dot(De),
                        h = r * l - a * a;
                    if (0 === h) return s.set(-2, -1, -1);
                    const u = 1 / h,
                        d = (l * o - a * c) * u,
                        p = (r * c - a * o) * u;
                    return s.set(1 - d - p, p, d);
                }
                static containsPoint(t, e, i, n) {
                    return this.getBarycoord(t, e, i, n, Qe), Qe.x >= 0 && Qe.y >= 0 && Qe.x + Qe.y <= 1;
                }
                static getUV(t, e, i, n, s, r, a, o) {
                    return this.getBarycoord(t, e, i, n, Qe), o.set(0, 0), o.addScaledVector(s, Qe.x), o.addScaledVector(r, Qe.y), o.addScaledVector(a, Qe.z), o;
                }
                static isFrontFacing(t, e, i, n) {
                    return Te.subVectors(i, e), Le.subVectors(t, e), Te.cross(Le).dot(n) < 0;
                }
                set(t, e, i) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
                }
                setFromPointsAndIndices(t, e, i, n) {
                    return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
                }
                getArea() {
                    return Te.subVectors(this.c, this.b), Le.subVectors(this.a, this.b), 0.5 * Te.cross(Le).length();
                }
                getMidpoint(t) {
                    return t
                        .addVectors(this.a, this.b)
                        .add(this.c)
                        .multiplyScalar(1 / 3);
                }
                getNormal(t) {
                    return Oe.getNormal(this.a, this.b, this.c, t);
                }
                getPlane(t) {
                    return t.setFromCoplanarPoints(this.a, this.b, this.c);
                }
                getBarycoord(t, e) {
                    return Oe.getBarycoord(t, this.a, this.b, this.c, e);
                }
                getUV(t, e, i, n, s) {
                    return Oe.getUV(t, this.a, this.b, this.c, e, i, n, s);
                }
                containsPoint(t) {
                    return Oe.containsPoint(t, this.a, this.b, this.c);
                }
                isFrontFacing(t) {
                    return Oe.isFrontFacing(this.a, this.b, this.c, t);
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this);
                }
                closestPointToPoint(t, e) {
                    const i = this.a,
                        n = this.b,
                        s = this.c;
                    let r, a;
                    Re.subVectors(n, i), Pe.subVectors(s, i), Fe.subVectors(t, i);
                    const o = Re.dot(Fe),
                        l = Pe.dot(Fe);
                    if (o <= 0 && l <= 0) return e.copy(i);
                    Ue.subVectors(t, n);
                    const c = Re.dot(Ue),
                        h = Pe.dot(Ue);
                    if (c >= 0 && h <= c) return e.copy(n);
                    const u = o * h - c * l;
                    if (u <= 0 && o >= 0 && c <= 0) return (r = o / (o - c)), e.copy(i).addScaledVector(Re, r);
                    ke.subVectors(t, s);
                    const d = Re.dot(ke),
                        p = Pe.dot(ke);
                    if (p >= 0 && d <= p) return e.copy(s);
                    const A = d * l - o * p;
                    if (A <= 0 && l >= 0 && p <= 0) return (a = l / (l - p)), e.copy(i).addScaledVector(Pe, a);
                    const g = c * p - d * h;
                    if (g <= 0 && h - c >= 0 && d - p >= 0) return Ne.subVectors(s, n), (a = (h - c) / (h - c + (d - p))), e.copy(n).addScaledVector(Ne, a);
                    const m = 1 / (g + A + u);
                    return (r = A * m), (a = u * m), e.copy(i).addScaledVector(Re, r).addScaledVector(Pe, a);
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
                }
            }
            let Ge = 0;
            class ze extends nt {
                constructor() {
                    super(), Object.defineProperty(this, "id", { value: Ge++ }), (this.uuid = lt()), (this.name = ""), (this.type = "Material"), (this.fog = !0), (this.blending = 1), (this.side = 0), (this.vertexColors = !1), (this.opacity = 1), (this.transparent = !1), (this.blendSrc = 204), (this.blendDst = 205), (this.blendEquation = 100), (this.blendSrcAlpha = null), (this.blendDstAlpha = null), (this.blendEquationAlpha = null), (this.depthFunc = 3), (this.depthTest = !0), (this.depthWrite = !0), (this.stencilWriteMask = 255), (this.stencilFunc = 519), (this.stencilRef = 0), (this.stencilFuncMask = 255), (this.stencilFail = 7680), (this.stencilZFail = 7680), (this.stencilZPass = 7680), (this.stencilWrite = !1), (this.clippingPlanes = null), (this.clipIntersection = !1), (this.clipShadows = !1), (this.shadowSide = null), (this.colorWrite = !0), (this.precision = null), (this.polygonOffset = !1), (this.polygonOffsetFactor = 0), (this.polygonOffsetUnits = 0), (this.dithering = !1), (this.alphaTest = 0), (this.alphaToCoverage = !1), (this.premultipliedAlpha = !1), (this.visible = !0), (this.toneMapped = !0), (this.userData = {}), (this.version = 0);
                }
                onBuild() {}
                onBeforeCompile() {}
                customProgramCacheKey() {
                    return this.onBeforeCompile.toString();
                }
                setValues(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const i = t[e];
                            if (void 0 === i) continue;
                            if ("shading" === e) {
                                this.flatShading = 1 === i;
                                continue;
                            }
                            const n = this[e];
                            void 0 !== n && (n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : (this[e] = i));
                        }
                }
                toJSON(t) {
                    const e = void 0 === t || "string" == typeof t;
                    e && (t = { textures: {}, images: {} });
                    const i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
                    function n(t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            delete n.metadata, e.push(n);
                        }
                        return e;
                    }
                    if (
                        ((i.uuid = this.uuid),
                        (i.type = this.type),
                        "" !== this.name && (i.name = this.name),
                        this.color && this.color.isColor && (i.color = this.color.getHex()),
                        void 0 !== this.roughness && (i.roughness = this.roughness),
                        void 0 !== this.metalness && (i.metalness = this.metalness),
                        this.sheen && this.sheen.isColor && (i.sheen = this.sheen.getHex()),
                        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
                        this.emissiveIntensity && 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
                        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
                        void 0 !== this.specularIntensity && (i.specularIntensity = this.specularIntensity),
                        this.specularTint && this.specularTint.isColor && (i.specularTint = this.specularTint.getHex()),
                        void 0 !== this.shininess && (i.shininess = this.shininess),
                        void 0 !== this.clearcoat && (i.clearcoat = this.clearcoat),
                        void 0 !== this.clearcoatRoughness && (i.clearcoatRoughness = this.clearcoatRoughness),
                        this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
                        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid),
                        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid), (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
                        this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
                        this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(t).uuid),
                        this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid),
                        this.lightMap && this.lightMap.isTexture && ((i.lightMap = this.lightMap.toJSON(t).uuid), (i.lightMapIntensity = this.lightMapIntensity)),
                        this.aoMap && this.aoMap.isTexture && ((i.aoMap = this.aoMap.toJSON(t).uuid), (i.aoMapIntensity = this.aoMapIntensity)),
                        this.bumpMap && this.bumpMap.isTexture && ((i.bumpMap = this.bumpMap.toJSON(t).uuid), (i.bumpScale = this.bumpScale)),
                        this.normalMap && this.normalMap.isTexture && ((i.normalMap = this.normalMap.toJSON(t).uuid), (i.normalMapType = this.normalMapType), (i.normalScale = this.normalScale.toArray())),
                        this.displacementMap && this.displacementMap.isTexture && ((i.displacementMap = this.displacementMap.toJSON(t).uuid), (i.displacementScale = this.displacementScale), (i.displacementBias = this.displacementBias)),
                        this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
                        this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
                        this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
                        this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid),
                        this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
                        this.specularTintMap && this.specularTintMap.isTexture && (i.specularTintMap = this.specularTintMap.toJSON(t).uuid),
                        this.envMap && this.envMap.isTexture && ((i.envMap = this.envMap.toJSON(t).uuid), void 0 !== this.combine && (i.combine = this.combine)),
                        void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity),
                        void 0 !== this.reflectivity && (i.reflectivity = this.reflectivity),
                        void 0 !== this.refractionRatio && (i.refractionRatio = this.refractionRatio),
                        this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid),
                        void 0 !== this.transmission && (i.transmission = this.transmission),
                        this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(t).uuid),
                        void 0 !== this.thickness && (i.thickness = this.thickness),
                        this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(t).uuid),
                        void 0 !== this.attenuationDistance && (i.attenuationDistance = this.attenuationDistance),
                        void 0 !== this.attenuationTint && (i.attenuationTint = this.attenuationTint.getHex()),
                        void 0 !== this.size && (i.size = this.size),
                        null !== this.shadowSide && (i.shadowSide = this.shadowSide),
                        void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
                        1 !== this.blending && (i.blending = this.blending),
                        0 !== this.side && (i.side = this.side),
                        this.vertexColors && (i.vertexColors = !0),
                        this.opacity < 1 && (i.opacity = this.opacity),
                        !0 === this.transparent && (i.transparent = this.transparent),
                        (i.depthFunc = this.depthFunc),
                        (i.depthTest = this.depthTest),
                        (i.depthWrite = this.depthWrite),
                        (i.colorWrite = this.colorWrite),
                        (i.stencilWrite = this.stencilWrite),
                        (i.stencilWriteMask = this.stencilWriteMask),
                        (i.stencilFunc = this.stencilFunc),
                        (i.stencilRef = this.stencilRef),
                        (i.stencilFuncMask = this.stencilFuncMask),
                        (i.stencilFail = this.stencilFail),
                        (i.stencilZFail = this.stencilZFail),
                        (i.stencilZPass = this.stencilZPass),
                        this.rotation && 0 !== this.rotation && (i.rotation = this.rotation),
                        !0 === this.polygonOffset && (i.polygonOffset = !0),
                        0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor),
                        0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
                        this.linewidth && 1 !== this.linewidth && (i.linewidth = this.linewidth),
                        void 0 !== this.dashSize && (i.dashSize = this.dashSize),
                        void 0 !== this.gapSize && (i.gapSize = this.gapSize),
                        void 0 !== this.scale && (i.scale = this.scale),
                        !0 === this.dithering && (i.dithering = !0),
                        this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
                        !0 === this.alphaToCoverage && (i.alphaToCoverage = this.alphaToCoverage),
                        !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha),
                        !0 === this.wireframe && (i.wireframe = this.wireframe),
                        this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth),
                        "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
                        "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin),
                        !0 === this.flatShading && (i.flatShading = this.flatShading),
                        !1 === this.visible && (i.visible = !1),
                        !1 === this.toneMapped && (i.toneMapped = !1),
                        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
                        e)
                    ) {
                        const e = n(t.textures),
                            s = n(t.images);
                        e.length > 0 && (i.textures = e), s.length > 0 && (i.images = s);
                    }
                    return i;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    (this.name = t.name), (this.fog = t.fog), (this.blending = t.blending), (this.side = t.side), (this.vertexColors = t.vertexColors), (this.opacity = t.opacity), (this.transparent = t.transparent), (this.blendSrc = t.blendSrc), (this.blendDst = t.blendDst), (this.blendEquation = t.blendEquation), (this.blendSrcAlpha = t.blendSrcAlpha), (this.blendDstAlpha = t.blendDstAlpha), (this.blendEquationAlpha = t.blendEquationAlpha), (this.depthFunc = t.depthFunc), (this.depthTest = t.depthTest), (this.depthWrite = t.depthWrite), (this.stencilWriteMask = t.stencilWriteMask), (this.stencilFunc = t.stencilFunc), (this.stencilRef = t.stencilRef), (this.stencilFuncMask = t.stencilFuncMask), (this.stencilFail = t.stencilFail), (this.stencilZFail = t.stencilZFail), (this.stencilZPass = t.stencilZPass), (this.stencilWrite = t.stencilWrite);
                    const e = t.clippingPlanes;
                    let i = null;
                    if (null !== e) {
                        const t = e.length;
                        i = new Array(t);
                        for (let n = 0; n !== t; ++n) i[n] = e[n].clone();
                    }
                    return (this.clippingPlanes = i), (this.clipIntersection = t.clipIntersection), (this.clipShadows = t.clipShadows), (this.shadowSide = t.shadowSide), (this.colorWrite = t.colorWrite), (this.precision = t.precision), (this.polygonOffset = t.polygonOffset), (this.polygonOffsetFactor = t.polygonOffsetFactor), (this.polygonOffsetUnits = t.polygonOffsetUnits), (this.dithering = t.dithering), (this.alphaTest = t.alphaTest), (this.alphaToCoverage = t.alphaToCoverage), (this.premultipliedAlpha = t.premultipliedAlpha), (this.visible = t.visible), (this.toneMapped = t.toneMapped), (this.userData = JSON.parse(JSON.stringify(t.userData))), this;
                }
                dispose() {
                    this.dispatchEvent({ type: "dispose" });
                }
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
            }
            ze.prototype.isMaterial = !0;
            const Ve = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074,
                },
                He = { h: 0, s: 0, l: 0 },
                We = { h: 0, s: 0, l: 0 };
            function qe(t, e, i) {
                return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t;
            }
            function je(t) {
                return t < 0.04045 ? 0.0773993808 * t : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
            }
            function Ye(t) {
                return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
            }
            class Je {
                constructor(t, e, i) {
                    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i);
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this;
                }
                setScalar(t) {
                    return (this.r = t), (this.g = t), (this.b = t), this;
                }
                setHex(t) {
                    return (t = Math.floor(t)), (this.r = ((t >> 16) & 255) / 255), (this.g = ((t >> 8) & 255) / 255), (this.b = (255 & t) / 255), this;
                }
                setRGB(t, e, i) {
                    return (this.r = t), (this.g = e), (this.b = i), this;
                }
                setHSL(t, e, i) {
                    if (((t = ht(t, 1)), (e = ct(e, 0, 1)), (i = ct(i, 0, 1)), 0 === e)) this.r = this.g = this.b = i;
                    else {
                        const n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
                            s = 2 * i - n;
                        (this.r = qe(s, n, t + 1 / 3)), (this.g = qe(s, n, t)), (this.b = qe(s, n, t - 1 / 3));
                    }
                    return this;
                }
                setStyle(t) {
                    function e(t) {
                        void 0 !== t && parseFloat(t);
                    }
                    let i;
                    if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
                        let t;
                        const n = i[1],
                            s = i[2];
                        switch (n) {
                            case "rgb":
                            case "rgba":
                                if ((t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))) return (this.r = Math.min(255, parseInt(t[1], 10)) / 255), (this.g = Math.min(255, parseInt(t[2], 10)) / 255), (this.b = Math.min(255, parseInt(t[3], 10)) / 255), e(t[4]), this;
                                if ((t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))) return (this.r = Math.min(100, parseInt(t[1], 10)) / 100), (this.g = Math.min(100, parseInt(t[2], 10)) / 100), (this.b = Math.min(100, parseInt(t[3], 10)) / 100), e(t[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if ((t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))) {
                                    const i = parseFloat(t[1]) / 360,
                                        n = parseInt(t[2], 10) / 100,
                                        s = parseInt(t[3], 10) / 100;
                                    return e(t[4]), this.setHSL(i, n, s);
                                }
                        }
                    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
                        const t = i[1],
                            e = t.length;
                        if (3 === e) return (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255), (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255), (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255), this;
                        if (6 === e) return (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255), (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255), (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255), this;
                    }
                    return t && t.length > 0 ? this.setColorName(t) : this;
                }
                setColorName(t) {
                    const e = Ve[t.toLowerCase()];
                    return void 0 !== e && this.setHex(e), this;
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b);
                }
                copy(t) {
                    return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
                }
                copyGammaToLinear(t, e = 2) {
                    return (this.r = Math.pow(t.r, e)), (this.g = Math.pow(t.g, e)), (this.b = Math.pow(t.b, e)), this;
                }
                copyLinearToGamma(t, e = 2) {
                    const i = e > 0 ? 1 / e : 1;
                    return (this.r = Math.pow(t.r, i)), (this.g = Math.pow(t.g, i)), (this.b = Math.pow(t.b, i)), this;
                }
                convertGammaToLinear(t) {
                    return this.copyGammaToLinear(this, t), this;
                }
                convertLinearToGamma(t) {
                    return this.copyLinearToGamma(this, t), this;
                }
                copySRGBToLinear(t) {
                    return (this.r = je(t.r)), (this.g = je(t.g)), (this.b = je(t.b)), this;
                }
                copyLinearToSRGB(t) {
                    return (this.r = Ye(t.r)), (this.g = Ye(t.g)), (this.b = Ye(t.b)), this;
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this;
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this;
                }
                getHex() {
                    return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ (255 * this.b);
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6);
                }
                getHSL(t) {
                    const e = this.r,
                        i = this.g,
                        n = this.b,
                        s = Math.max(e, i, n),
                        r = Math.min(e, i, n);
                    let a, o;
                    const l = (r + s) / 2;
                    if (r === s) (a = 0), (o = 0);
                    else {
                        const t = s - r;
                        switch (((o = l <= 0.5 ? t / (s + r) : t / (2 - s - r)), s)) {
                            case e:
                                a = (i - n) / t + (i < n ? 6 : 0);
                                break;
                            case i:
                                a = (n - e) / t + 2;
                                break;
                            case n:
                                a = (e - i) / t + 4;
                        }
                        a /= 6;
                    }
                    return (t.h = a), (t.s = o), (t.l = l), t;
                }
                getStyle() {
                    return "rgb(" + ((255 * this.r) | 0) + "," + ((255 * this.g) | 0) + "," + ((255 * this.b) | 0) + ")";
                }
                offsetHSL(t, e, i) {
                    return this.getHSL(He), (He.h += t), (He.s += e), (He.l += i), this.setHSL(He.h, He.s, He.l), this;
                }
                add(t) {
                    return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
                }
                addColors(t, e) {
                    return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
                }
                addScalar(t) {
                    return (this.r += t), (this.g += t), (this.b += t), this;
                }
                sub(t) {
                    return (this.r = Math.max(0, this.r - t.r)), (this.g = Math.max(0, this.g - t.g)), (this.b = Math.max(0, this.b - t.b)), this;
                }
                multiply(t) {
                    return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
                }
                multiplyScalar(t) {
                    return (this.r *= t), (this.g *= t), (this.b *= t), this;
                }
                lerp(t, e) {
                    return (this.r += (t.r - this.r) * e), (this.g += (t.g - this.g) * e), (this.b += (t.b - this.b) * e), this;
                }
                lerpColors(t, e, i) {
                    return (this.r = t.r + (e.r - t.r) * i), (this.g = t.g + (e.g - t.g) * i), (this.b = t.b + (e.b - t.b) * i), this;
                }
                lerpHSL(t, e) {
                    this.getHSL(He), t.getHSL(We);
                    const i = ut(He.h, We.h, e),
                        n = ut(He.s, We.s, e),
                        s = ut(He.l, We.l, e);
                    return this.setHSL(i, n, s), this;
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b;
                }
                fromArray(t, e = 0) {
                    return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
                }
                toArray(t = [], e = 0) {
                    return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
                }
                fromBufferAttribute(t, e) {
                    return (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), !0 === t.normalized && ((this.r /= 255), (this.g /= 255), (this.b /= 255)), this;
                }
                toJSON() {
                    return this.getHex();
                }
            }
            (Je.NAMES = Ve), (Je.prototype.isColor = !0), (Je.prototype.r = 1), (Je.prototype.g = 1), (Je.prototype.b = 1);
            class Xe extends ze {
                constructor(t) {
                    super(), (this.type = "MeshBasicMaterial"), (this.color = new Je(16777215)), (this.map = null), (this.lightMap = null), (this.lightMapIntensity = 1), (this.aoMap = null), (this.aoMapIntensity = 1), (this.specularMap = null), (this.alphaMap = null), (this.envMap = null), (this.combine = 0), (this.reflectivity = 1), (this.refractionRatio = 0.98), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.wireframeLinecap = "round"), (this.wireframeLinejoin = "round"), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.lightMap = t.lightMap), (this.lightMapIntensity = t.lightMapIntensity), (this.aoMap = t.aoMap), (this.aoMapIntensity = t.aoMapIntensity), (this.specularMap = t.specularMap), (this.alphaMap = t.alphaMap), (this.envMap = t.envMap), (this.combine = t.combine), (this.reflectivity = t.reflectivity), (this.refractionRatio = t.refractionRatio), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.wireframeLinecap = t.wireframeLinecap), (this.wireframeLinejoin = t.wireframeLinejoin), this;
                }
            }
            Xe.prototype.isMeshBasicMaterial = !0;
            const Ke = new bt(),
                Ze = new mt();
            class $e {
                constructor(t, e, i) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    (this.name = ""), (this.array = t), (this.itemSize = e), (this.count = void 0 !== t ? t.length / e : 0), (this.normalized = !0 === i), (this.usage = 35044), (this.updateRange = { offset: 0, count: -1 }), (this.version = 0);
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
                setUsage(t) {
                    return (this.usage = t), this;
                }
                copy(t) {
                    return (this.name = t.name), (this.array = new t.array.constructor(t.array)), (this.itemSize = t.itemSize), (this.count = t.count), (this.normalized = t.normalized), (this.usage = t.usage), this;
                }
                copyAt(t, e, i) {
                    (t *= this.itemSize), (i *= e.itemSize);
                    for (let n = 0, s = this.itemSize; n < s; n++) this.array[t + n] = e.array[i + n];
                    return this;
                }
                copyArray(t) {
                    return this.array.set(t), this;
                }
                copyColorsArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, s = t.length; n < s; n++) {
                        let s = t[n];
                        void 0 === s && (s = new Je()), (e[i++] = s.r), (e[i++] = s.g), (e[i++] = s.b);
                    }
                    return this;
                }
                copyVector2sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, s = t.length; n < s; n++) {
                        let s = t[n];
                        void 0 === s && (s = new mt()), (e[i++] = s.x), (e[i++] = s.y);
                    }
                    return this;
                }
                copyVector3sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, s = t.length; n < s; n++) {
                        let s = t[n];
                        void 0 === s && (s = new bt()), (e[i++] = s.x), (e[i++] = s.y), (e[i++] = s.z);
                    }
                    return this;
                }
                copyVector4sArray(t) {
                    const e = this.array;
                    let i = 0;
                    for (let n = 0, s = t.length; n < s; n++) {
                        let s = t[n];
                        void 0 === s && (s = new It()), (e[i++] = s.x), (e[i++] = s.y), (e[i++] = s.z), (e[i++] = s.w);
                    }
                    return this;
                }
                applyMatrix3(t) {
                    if (2 === this.itemSize) for (let e = 0, i = this.count; e < i; e++) Ze.fromBufferAttribute(this, e), Ze.applyMatrix3(t), this.setXY(e, Ze.x, Ze.y);
                    else if (3 === this.itemSize) for (let e = 0, i = this.count; e < i; e++) Ke.fromBufferAttribute(this, e), Ke.applyMatrix3(t), this.setXYZ(e, Ke.x, Ke.y, Ke.z);
                    return this;
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.count; e < i; e++) (Ke.x = this.getX(e)), (Ke.y = this.getY(e)), (Ke.z = this.getZ(e)), Ke.applyMatrix4(t), this.setXYZ(e, Ke.x, Ke.y, Ke.z);
                    return this;
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) (Ke.x = this.getX(e)), (Ke.y = this.getY(e)), (Ke.z = this.getZ(e)), Ke.applyNormalMatrix(t), this.setXYZ(e, Ke.x, Ke.y, Ke.z);
                    return this;
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) (Ke.x = this.getX(e)), (Ke.y = this.getY(e)), (Ke.z = this.getZ(e)), Ke.transformDirection(t), this.setXYZ(e, Ke.x, Ke.y, Ke.z);
                    return this;
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this;
                }
                getX(t) {
                    return this.array[t * this.itemSize];
                }
                setX(t, e) {
                    return (this.array[t * this.itemSize] = e), this;
                }
                getY(t) {
                    return this.array[t * this.itemSize + 1];
                }
                setY(t, e) {
                    return (this.array[t * this.itemSize + 1] = e), this;
                }
                getZ(t) {
                    return this.array[t * this.itemSize + 2];
                }
                setZ(t, e) {
                    return (this.array[t * this.itemSize + 2] = e), this;
                }
                getW(t) {
                    return this.array[t * this.itemSize + 3];
                }
                setW(t, e) {
                    return (this.array[t * this.itemSize + 3] = e), this;
                }
                setXY(t, e, i) {
                    return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), this;
                }
                setXYZ(t, e, i, n) {
                    return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), (this.array[t + 2] = n), this;
                }
                setXYZW(t, e, i, n, s) {
                    return (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), (this.array[t + 2] = n), (this.array[t + 3] = s), this;
                }
                onUpload(t) {
                    return (this.onUploadCallback = t), this;
                }
                clone() {
                    return new this.constructor(this.array, this.itemSize).copy(this);
                }
                toJSON() {
                    const t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
                    return "" !== this.name && (t.name = this.name), 35044 !== this.usage && (t.usage = this.usage), (0 === this.updateRange.offset && -1 === this.updateRange.count) || (t.updateRange = this.updateRange), t;
                }
            }
            $e.prototype.isBufferAttribute = !0;
            class ti extends $e {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i);
                }
            }
            class ei extends $e {
                constructor(t, e, i) {
                    super(new Uint32Array(t), e, i);
                }
            }
            (class extends $e {
                constructor(t, e, i) {
                    super(new Uint16Array(t), e, i);
                }
            }).prototype.isFloat16BufferAttribute = !0;
            class ii extends $e {
                constructor(t, e, i) {
                    super(new Float32Array(t), e, i);
                }
            }
            function ni(t) {
                if (0 === t.length) return -1 / 0;
                let e = t[0];
                for (let i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
                return e;
            }
            let si = 0;
            const ri = new se(),
                ai = new Be(),
                oi = new bt(),
                li = new Tt(),
                ci = new Tt(),
                hi = new bt();
            class ui extends nt {
                constructor() {
                    super(), Object.defineProperty(this, "id", { value: si++ }), (this.uuid = lt()), (this.name = ""), (this.type = "BufferGeometry"), (this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.morphTargetsRelative = !1), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null), (this.drawRange = { start: 0, count: 1 / 0 }), (this.userData = {});
                }
                getIndex() {
                    return this.index;
                }
                setIndex(t) {
                    return Array.isArray(t) ? (this.index = new (ni(t) > 65535 ? ei : ti)(t, 1)) : (this.index = t), this;
                }
                getAttribute(t) {
                    return this.attributes[t];
                }
                setAttribute(t, e) {
                    return (this.attributes[t] = e), this;
                }
                deleteAttribute(t) {
                    return delete this.attributes[t], this;
                }
                hasAttribute(t) {
                    return void 0 !== this.attributes[t];
                }
                addGroup(t, e, i = 0) {
                    this.groups.push({ start: t, count: e, materialIndex: i });
                }
                clearGroups() {
                    this.groups = [];
                }
                setDrawRange(t, e) {
                    (this.drawRange.start = t), (this.drawRange.count = e);
                }
                applyMatrix4(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
                    const i = this.attributes.normal;
                    if (void 0 !== i) {
                        const e = new ft().getNormalMatrix(t);
                        i.applyNormalMatrix(e), (i.needsUpdate = !0);
                    }
                    const n = this.attributes.tangent;
                    return void 0 !== n && (n.transformDirection(t), (n.needsUpdate = !0)), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
                }
                applyQuaternion(t) {
                    return ri.makeRotationFromQuaternion(t), this.applyMatrix4(ri), this;
                }
                rotateX(t) {
                    return ri.makeRotationX(t), this.applyMatrix4(ri), this;
                }
                rotateY(t) {
                    return ri.makeRotationY(t), this.applyMatrix4(ri), this;
                }
                rotateZ(t) {
                    return ri.makeRotationZ(t), this.applyMatrix4(ri), this;
                }
                translate(t, e, i) {
                    return ri.makeTranslation(t, e, i), this.applyMatrix4(ri), this;
                }
                scale(t, e, i) {
                    return ri.makeScale(t, e, i), this.applyMatrix4(ri), this;
                }
                lookAt(t) {
                    return ai.lookAt(t), ai.updateMatrix(), this.applyMatrix4(ai.matrix), this;
                }
                center() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(oi).negate(), this.translate(oi.x, oi.y, oi.z), this;
                }
                setFromPoints(t) {
                    const e = [];
                    for (let i = 0, n = t.length; i < n; i++) {
                        const n = t[i];
                        e.push(n.x, n.y, n.z || 0);
                    }
                    return this.setAttribute("position", new ii(e, 3)), this;
                }
                computeBoundingBox() {
                    null === this.boundingBox && (this.boundingBox = new Tt());
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) this.boundingBox.set(new bt(-1 / 0, -1 / 0, -1 / 0), new bt(1 / 0, 1 / 0, 1 / 0));
                    else {
                        if (void 0 !== t) {
                            if ((this.boundingBox.setFromBufferAttribute(t), e))
                                for (let t = 0, i = e.length; t < i; t++) {
                                    const i = e[t];
                                    li.setFromBufferAttribute(i), this.morphTargetsRelative ? (hi.addVectors(this.boundingBox.min, li.min), this.boundingBox.expandByPoint(hi), hi.addVectors(this.boundingBox.max, li.max), this.boundingBox.expandByPoint(hi)) : (this.boundingBox.expandByPoint(li.min), this.boundingBox.expandByPoint(li.max));
                                }
                        } else this.boundingBox.makeEmpty();
                        isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z);
                    }
                }
                computeBoundingSphere() {
                    null === this.boundingSphere && (this.boundingSphere = new Jt());
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) this.boundingSphere.set(new bt(), 1 / 0);
                    else if (t) {
                        const i = this.boundingSphere.center;
                        if ((li.setFromBufferAttribute(t), e))
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                ci.setFromBufferAttribute(i), this.morphTargetsRelative ? (hi.addVectors(li.min, ci.min), li.expandByPoint(hi), hi.addVectors(li.max, ci.max), li.expandByPoint(hi)) : (li.expandByPoint(ci.min), li.expandByPoint(ci.max));
                            }
                        li.getCenter(i);
                        let n = 0;
                        for (let e = 0, s = t.count; e < s; e++) hi.fromBufferAttribute(t, e), (n = Math.max(n, i.distanceToSquared(hi)));
                        if (e)
                            for (let s = 0, r = e.length; s < r; s++) {
                                const r = e[s],
                                    a = this.morphTargetsRelative;
                                for (let e = 0, s = r.count; e < s; e++) hi.fromBufferAttribute(r, e), a && (oi.fromBufferAttribute(t, e), hi.add(oi)), (n = Math.max(n, i.distanceToSquared(hi)));
                            }
                        (this.boundingSphere.radius = Math.sqrt(n)), isNaN(this.boundingSphere.radius);
                    }
                }
                computeFaceNormals() {}
                computeTangents() {
                    const t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return;
                    const i = t.array,
                        n = e.position.array,
                        s = e.normal.array,
                        r = e.uv.array,
                        a = n.length / 3;
                    void 0 === e.tangent && this.setAttribute("tangent", new $e(new Float32Array(4 * a), 4));
                    const o = e.tangent.array,
                        l = [],
                        c = [];
                    for (let t = 0; t < a; t++) (l[t] = new bt()), (c[t] = new bt());
                    const h = new bt(),
                        u = new bt(),
                        d = new bt(),
                        p = new mt(),
                        A = new mt(),
                        g = new mt(),
                        m = new bt(),
                        f = new bt();
                    function v(t, e, i) {
                        h.fromArray(n, 3 * t), u.fromArray(n, 3 * e), d.fromArray(n, 3 * i), p.fromArray(r, 2 * t), A.fromArray(r, 2 * e), g.fromArray(r, 2 * i), u.sub(h), d.sub(h), A.sub(p), g.sub(p);
                        const s = 1 / (A.x * g.y - g.x * A.y);
                        isFinite(s) && (m.copy(u).multiplyScalar(g.y).addScaledVector(d, -A.y).multiplyScalar(s), f.copy(d).multiplyScalar(A.x).addScaledVector(u, -g.x).multiplyScalar(s), l[t].add(m), l[e].add(m), l[i].add(m), c[t].add(f), c[e].add(f), c[i].add(f));
                    }
                    let y = this.groups;
                    0 === y.length && (y = [{ start: 0, count: i.length }]);
                    for (let t = 0, e = y.length; t < e; ++t) {
                        const e = y[t],
                            n = e.start;
                        for (let t = n, s = n + e.count; t < s; t += 3) v(i[t + 0], i[t + 1], i[t + 2]);
                    }
                    const x = new bt(),
                        w = new bt(),
                        _ = new bt(),
                        I = new bt();
                    function C(t) {
                        _.fromArray(s, 3 * t), I.copy(_);
                        const e = l[t];
                        x.copy(e), x.sub(_.multiplyScalar(_.dot(e))).normalize(), w.crossVectors(I, e);
                        const i = w.dot(c[t]) < 0 ? -1 : 1;
                        (o[4 * t] = x.x), (o[4 * t + 1] = x.y), (o[4 * t + 2] = x.z), (o[4 * t + 3] = i);
                    }
                    for (let t = 0, e = y.length; t < e; ++t) {
                        const e = y[t],
                            n = e.start;
                        for (let t = n, s = n + e.count; t < s; t += 3) C(i[t + 0]), C(i[t + 1]), C(i[t + 2]);
                    }
                }
                computeVertexNormals() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let i = this.getAttribute("normal");
                        if (void 0 === i) (i = new $e(new Float32Array(3 * e.count), 3)), this.setAttribute("normal", i);
                        else for (let t = 0, e = i.count; t < e; t++) i.setXYZ(t, 0, 0, 0);
                        const n = new bt(),
                            s = new bt(),
                            r = new bt(),
                            a = new bt(),
                            o = new bt(),
                            l = new bt(),
                            c = new bt(),
                            h = new bt();
                        if (t)
                            for (let u = 0, d = t.count; u < d; u += 3) {
                                const d = t.getX(u + 0),
                                    p = t.getX(u + 1),
                                    A = t.getX(u + 2);
                                n.fromBufferAttribute(e, d), s.fromBufferAttribute(e, p), r.fromBufferAttribute(e, A), c.subVectors(r, s), h.subVectors(n, s), c.cross(h), a.fromBufferAttribute(i, d), o.fromBufferAttribute(i, p), l.fromBufferAttribute(i, A), a.add(c), o.add(c), l.add(c), i.setXYZ(d, a.x, a.y, a.z), i.setXYZ(p, o.x, o.y, o.z), i.setXYZ(A, l.x, l.y, l.z);
                            }
                        else for (let t = 0, a = e.count; t < a; t += 3) n.fromBufferAttribute(e, t + 0), s.fromBufferAttribute(e, t + 1), r.fromBufferAttribute(e, t + 2), c.subVectors(r, s), h.subVectors(n, s), c.cross(h), i.setXYZ(t + 0, c.x, c.y, c.z), i.setXYZ(t + 1, c.x, c.y, c.z), i.setXYZ(t + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), (i.needsUpdate = !0);
                    }
                }
                merge(t, e) {
                    if (!t || !t.isBufferGeometry) return;
                    void 0 === e && (e = 0);
                    const i = this.attributes;
                    for (const n in i) {
                        if (void 0 === t.attributes[n]) continue;
                        const s = i[n].array,
                            r = t.attributes[n],
                            a = r.array,
                            o = r.itemSize * e,
                            l = Math.min(a.length, s.length - o);
                        for (let t = 0, e = o; t < l; t++, e++) s[e] = a[t];
                    }
                    return this;
                }
                normalizeNormals() {
                    const t = this.attributes.normal;
                    for (let e = 0, i = t.count; e < i; e++) hi.fromBufferAttribute(t, e), hi.normalize(), t.setXYZ(e, hi.x, hi.y, hi.z);
                }
                toNonIndexed() {
                    function t(t, e) {
                        const i = t.array,
                            n = t.itemSize,
                            s = t.normalized,
                            r = new i.constructor(e.length * n);
                        let a = 0,
                            o = 0;
                        for (let s = 0, l = e.length; s < l; s++) {
                            a = t.isInterleavedBufferAttribute ? e[s] * t.data.stride + t.offset : e[s] * n;
                            for (let t = 0; t < n; t++) r[o++] = i[a++];
                        }
                        return new $e(r, n, s);
                    }
                    if (null === this.index) return this;
                    const e = new ui(),
                        i = this.index.array,
                        n = this.attributes;
                    for (const s in n) {
                        const r = t(n[s], i);
                        e.setAttribute(s, r);
                    }
                    const s = this.morphAttributes;
                    for (const n in s) {
                        const r = [],
                            a = s[n];
                        for (let e = 0, n = a.length; e < n; e++) {
                            const n = t(a[e], i);
                            r.push(n);
                        }
                        e.morphAttributes[n] = r;
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const r = this.groups;
                    for (let t = 0, i = r.length; t < i; t++) {
                        const i = r[t];
                        e.addGroup(i.start, i.count, i.materialIndex);
                    }
                    return e;
                }
                toJSON() {
                    const t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
                    if (((t.uuid = this.uuid), (t.type = this.type), "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters)) {
                        const e = this.parameters;
                        for (const i in e) void 0 !== e[i] && (t[i] = e[i]);
                        return t;
                    }
                    t.data = { attributes: {} };
                    const e = this.index;
                    null !== e && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
                    const i = this.attributes;
                    for (const e in i) {
                        const n = i[e];
                        t.data.attributes[e] = n.toJSON(t.data);
                    }
                    const n = {};
                    let s = !1;
                    for (const e in this.morphAttributes) {
                        const i = this.morphAttributes[e],
                            r = [];
                        for (let e = 0, n = i.length; e < n; e++) {
                            const n = i[e];
                            r.push(n.toJSON(t.data));
                        }
                        r.length > 0 && ((n[e] = r), (s = !0));
                    }
                    s && ((t.data.morphAttributes = n), (t.data.morphTargetsRelative = this.morphTargetsRelative));
                    const r = this.groups;
                    r.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(r)));
                    const a = this.boundingSphere;
                    return null !== a && (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), t;
                }
                clone() {
                    return new ui().copy(this);
                }
                copy(t) {
                    (this.index = null), (this.attributes = {}), (this.morphAttributes = {}), (this.groups = []), (this.boundingBox = null), (this.boundingSphere = null);
                    const e = {};
                    this.name = t.name;
                    const i = t.index;
                    null !== i && this.setIndex(i.clone(e));
                    const n = t.attributes;
                    for (const t in n) {
                        const i = n[t];
                        this.setAttribute(t, i.clone(e));
                    }
                    const s = t.morphAttributes;
                    for (const t in s) {
                        const i = [],
                            n = s[t];
                        for (let t = 0, s = n.length; t < s; t++) i.push(n[t].clone(e));
                        this.morphAttributes[t] = i;
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const r = t.groups;
                    for (let t = 0, e = r.length; t < e; t++) {
                        const e = r[t];
                        this.addGroup(e.start, e.count, e.materialIndex);
                    }
                    const a = t.boundingBox;
                    null !== a && (this.boundingBox = a.clone());
                    const o = t.boundingSphere;
                    return null !== o && (this.boundingSphere = o.clone()), (this.drawRange.start = t.drawRange.start), (this.drawRange.count = t.drawRange.count), (this.userData = t.userData), this;
                }
                dispose() {
                    this.dispatchEvent({ type: "dispose" });
                }
            }
            ui.prototype.isBufferGeometry = !0;
            const di = new se(),
                pi = new ne(),
                Ai = new Jt(),
                gi = new bt(),
                mi = new bt(),
                fi = new bt(),
                vi = new bt(),
                yi = new bt(),
                xi = new bt(),
                wi = new bt(),
                _i = new bt(),
                Ii = new bt(),
                Ci = new mt(),
                Mi = new mt(),
                Ei = new mt(),
                bi = new bt(),
                Si = new bt();
            class Bi extends Be {
                constructor(t = new ui(), e = new Xe()) {
                    super(), (this.type = "Mesh"), (this.geometry = t), (this.material = e), this.updateMorphTargets();
                }
                copy(t) {
                    return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), (this.material = t.material), (this.geometry = t.geometry), this;
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = e);
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length;
                    }
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.material,
                        s = this.matrixWorld;
                    if (void 0 === n) return;
                    if ((null === i.boundingSphere && i.computeBoundingSphere(), Ai.copy(i.boundingSphere), Ai.applyMatrix4(s), !1 === t.ray.intersectsSphere(Ai))) return;
                    if ((di.copy(s).invert(), pi.copy(t.ray).applyMatrix4(di), null !== i.boundingBox && !1 === pi.intersectsBox(i.boundingBox))) return;
                    let r;
                    if (i.isBufferGeometry) {
                        const s = i.index,
                            a = i.attributes.position,
                            o = i.morphAttributes.position,
                            l = i.morphTargetsRelative,
                            c = i.attributes.uv,
                            h = i.attributes.uv2,
                            u = i.groups,
                            d = i.drawRange;
                        if (null !== s)
                            if (Array.isArray(n))
                                for (let i = 0, p = u.length; i < p; i++) {
                                    const p = u[i],
                                        A = n[p.materialIndex];
                                    for (let i = Math.max(p.start, d.start), n = Math.min(p.start + p.count, d.start + d.count); i < n; i += 3) {
                                        const n = s.getX(i),
                                            u = s.getX(i + 1),
                                            d = s.getX(i + 2);
                                        (r = Ti(this, A, t, pi, a, o, l, c, h, n, u, d)), r && ((r.faceIndex = Math.floor(i / 3)), (r.face.materialIndex = p.materialIndex), e.push(r));
                                    }
                                }
                            else
                                for (let i = Math.max(0, d.start), u = Math.min(s.count, d.start + d.count); i < u; i += 3) {
                                    const u = s.getX(i),
                                        d = s.getX(i + 1),
                                        p = s.getX(i + 2);
                                    (r = Ti(this, n, t, pi, a, o, l, c, h, u, d, p)), r && ((r.faceIndex = Math.floor(i / 3)), e.push(r));
                                }
                        else if (void 0 !== a)
                            if (Array.isArray(n))
                                for (let i = 0, s = u.length; i < s; i++) {
                                    const s = u[i],
                                        p = n[s.materialIndex];
                                    for (let i = Math.max(s.start, d.start), n = Math.min(s.start + s.count, d.start + d.count); i < n; i += 3) (r = Ti(this, p, t, pi, a, o, l, c, h, i, i + 1, i + 2)), r && ((r.faceIndex = Math.floor(i / 3)), (r.face.materialIndex = s.materialIndex), e.push(r));
                                }
                            else for (let i = Math.max(0, d.start), s = Math.min(a.count, d.start + d.count); i < s; i += 3) (r = Ti(this, n, t, pi, a, o, l, c, h, i, i + 1, i + 2)), r && ((r.faceIndex = Math.floor(i / 3)), e.push(r));
                    } else i.isGeometry;
                }
            }
            function Ti(t, e, i, n, s, r, a, o, l, c, h, u) {
                gi.fromBufferAttribute(s, c), mi.fromBufferAttribute(s, h), fi.fromBufferAttribute(s, u);
                const d = t.morphTargetInfluences;
                if (r && d) {
                    wi.set(0, 0, 0), _i.set(0, 0, 0), Ii.set(0, 0, 0);
                    for (let t = 0, e = r.length; t < e; t++) {
                        const e = d[t],
                            i = r[t];
                        0 !== e && (vi.fromBufferAttribute(i, c), yi.fromBufferAttribute(i, h), xi.fromBufferAttribute(i, u), a ? (wi.addScaledVector(vi, e), _i.addScaledVector(yi, e), Ii.addScaledVector(xi, e)) : (wi.addScaledVector(vi.sub(gi), e), _i.addScaledVector(yi.sub(mi), e), Ii.addScaledVector(xi.sub(fi), e)));
                    }
                    gi.add(wi), mi.add(_i), fi.add(Ii);
                }
                t.isSkinnedMesh && (t.boneTransform(c, gi), t.boneTransform(h, mi), t.boneTransform(u, fi));
                const p = (function (t, e, i, n, s, r, a, o) {
                    let l;
                    if (((l = 1 === e.side ? n.intersectTriangle(a, r, s, !0, o) : n.intersectTriangle(s, r, a, 2 !== e.side, o)), null === l)) return null;
                    Si.copy(o), Si.applyMatrix4(t.matrixWorld);
                    const c = i.ray.origin.distanceTo(Si);
                    return c < i.near || c > i.far ? null : { distance: c, point: Si.clone(), object: t };
                })(t, e, i, n, gi, mi, fi, bi);
                if (p) {
                    o && (Ci.fromBufferAttribute(o, c), Mi.fromBufferAttribute(o, h), Ei.fromBufferAttribute(o, u), (p.uv = Oe.getUV(bi, gi, mi, fi, Ci, Mi, Ei, new mt()))), l && (Ci.fromBufferAttribute(l, c), Mi.fromBufferAttribute(l, h), Ei.fromBufferAttribute(l, u), (p.uv2 = Oe.getUV(bi, gi, mi, fi, Ci, Mi, Ei, new mt())));
                    const t = { a: c, b: h, c: u, normal: new bt(), materialIndex: 0 };
                    Oe.getNormal(gi, mi, fi, t.normal), (p.face = t);
                }
                return p;
            }
            Bi.prototype.isMesh = !0;
            class Li extends ui {
                constructor(t = 1, e = 1, i = 1, n = 1, s = 1, r = 1) {
                    super(), (this.type = "BoxGeometry"), (this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: s, depthSegments: r });
                    const a = this;
                    (n = Math.floor(n)), (s = Math.floor(s)), (r = Math.floor(r));
                    const o = [],
                        l = [],
                        c = [],
                        h = [];
                    let u = 0,
                        d = 0;
                    function p(t, e, i, n, s, r, p, A, g, m, f) {
                        const v = r / g,
                            y = p / m,
                            x = r / 2,
                            w = p / 2,
                            _ = A / 2,
                            I = g + 1,
                            C = m + 1;
                        let M = 0,
                            E = 0;
                        const b = new bt();
                        for (let r = 0; r < C; r++) {
                            const a = r * y - w;
                            for (let o = 0; o < I; o++) {
                                const u = o * v - x;
                                (b[t] = u * n), (b[e] = a * s), (b[i] = _), l.push(b.x, b.y, b.z), (b[t] = 0), (b[e] = 0), (b[i] = A > 0 ? 1 : -1), c.push(b.x, b.y, b.z), h.push(o / g), h.push(1 - r / m), (M += 1);
                            }
                        }
                        for (let t = 0; t < m; t++)
                            for (let e = 0; e < g; e++) {
                                const i = u + e + I * t,
                                    n = u + e + I * (t + 1),
                                    s = u + (e + 1) + I * (t + 1),
                                    r = u + (e + 1) + I * t;
                                o.push(i, n, r), o.push(n, s, r), (E += 6);
                            }
                        a.addGroup(d, E, f), (d += E), (u += M);
                    }
                    p("z", "y", "x", -1, -1, i, e, t, r, s, 0), p("z", "y", "x", 1, -1, i, e, -t, r, s, 1), p("x", "z", "y", 1, 1, t, i, e, n, r, 2), p("x", "z", "y", 1, -1, t, i, -e, n, r, 3), p("x", "y", "z", 1, -1, t, e, i, n, s, 4), p("x", "y", "z", -1, -1, t, e, -i, n, s, 5), this.setIndex(o), this.setAttribute("position", new ii(l, 3)), this.setAttribute("normal", new ii(c, 3)), this.setAttribute("uv", new ii(h, 2));
                }
                static fromJSON(t) {
                    return new Li(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
                }
            }
            function Di(t) {
                const e = {};
                for (const i in t) {
                    e[i] = {};
                    for (const n in t[i]) {
                        const s = t[i][n];
                        s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? (e[i][n] = s.clone()) : Array.isArray(s) ? (e[i][n] = s.slice()) : (e[i][n] = s);
                    }
                }
                return e;
            }
            function Qi(t) {
                const e = {};
                for (let i = 0; i < t.length; i++) {
                    const n = Di(t[i]);
                    for (const t in n) e[t] = n[t];
                }
                return e;
            }
            const Ri = { clone: Di, merge: Qi };
            class Pi extends ze {
                constructor(t) {
                    super(), (this.type = "ShaderMaterial"), (this.defines = {}), (this.uniforms = {}), (this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"), (this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"), (this.linewidth = 1), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.fog = !1), (this.lights = !1), (this.clipping = !1), (this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }), (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }), (this.index0AttributeName = void 0), (this.uniformsNeedUpdate = !1), (this.glslVersion = null), void 0 !== t && (t.attributes, this.setValues(t));
                }
                copy(t) {
                    return super.copy(t), (this.fragmentShader = t.fragmentShader), (this.vertexShader = t.vertexShader), (this.uniforms = Di(t.uniforms)), (this.defines = Object.assign({}, t.defines)), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.lights = t.lights), (this.clipping = t.clipping), (this.extensions = Object.assign({}, t.extensions)), (this.glslVersion = t.glslVersion), this;
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    (e.glslVersion = this.glslVersion), (e.uniforms = {});
                    for (const i in this.uniforms) {
                        const n = this.uniforms[i].value;
                        n && n.isTexture ? (e.uniforms[i] = { type: "t", value: n.toJSON(t).uuid }) : n && n.isColor ? (e.uniforms[i] = { type: "c", value: n.getHex() }) : n && n.isVector2 ? (e.uniforms[i] = { type: "v2", value: n.toArray() }) : n && n.isVector3 ? (e.uniforms[i] = { type: "v3", value: n.toArray() }) : n && n.isVector4 ? (e.uniforms[i] = { type: "v4", value: n.toArray() }) : n && n.isMatrix3 ? (e.uniforms[i] = { type: "m3", value: n.toArray() }) : n && n.isMatrix4 ? (e.uniforms[i] = { type: "m4", value: n.toArray() }) : (e.uniforms[i] = { value: n });
                    }
                    Object.keys(this.defines).length > 0 && (e.defines = this.defines), (e.vertexShader = this.vertexShader), (e.fragmentShader = this.fragmentShader);
                    const i = {};
                    for (const t in this.extensions) !0 === this.extensions[t] && (i[t] = !0);
                    return Object.keys(i).length > 0 && (e.extensions = i), e;
                }
            }
            Pi.prototype.isShaderMaterial = !0;
            class Ni extends Be {
                constructor() {
                    super(), (this.type = "Camera"), (this.matrixWorldInverse = new se()), (this.projectionMatrix = new se()), (this.projectionMatrixInverse = new se());
                }
                copy(t, e) {
                    return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
                }
                getWorldDirection(t) {
                    this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize();
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
                updateWorldMatrix(t, e) {
                    super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            Ni.prototype.isCamera = !0;
            class Fi extends Ni {
                constructor(t = 50, e = 1, i = 0.1, n = 2e3) {
                    super(), (this.type = "PerspectiveCamera"), (this.fov = t), (this.zoom = 1), (this.near = i), (this.far = n), (this.focus = 10), (this.aspect = e), (this.view = null), (this.filmGauge = 35), (this.filmOffset = 0), this.updateProjectionMatrix();
                }
                copy(t, e) {
                    return super.copy(t, e), (this.fov = t.fov), (this.zoom = t.zoom), (this.near = t.near), (this.far = t.far), (this.focus = t.focus), (this.aspect = t.aspect), (this.view = null === t.view ? null : Object.assign({}, t.view)), (this.filmGauge = t.filmGauge), (this.filmOffset = t.filmOffset), this;
                }
                setFocalLength(t) {
                    const e = (0.5 * this.getFilmHeight()) / t;
                    (this.fov = 2 * ot * Math.atan(e)), this.updateProjectionMatrix();
                }
                getFocalLength() {
                    const t = Math.tan(0.5 * at * this.fov);
                    return (0.5 * this.getFilmHeight()) / t;
                }
                getEffectiveFOV() {
                    return 2 * ot * Math.atan(Math.tan(0.5 * at * this.fov) / this.zoom);
                }
                getFilmWidth() {
                    return this.filmGauge * Math.min(this.aspect, 1);
                }
                getFilmHeight() {
                    return this.filmGauge / Math.max(this.aspect, 1);
                }
                setViewOffset(t, e, i, n, s, r) {
                    (this.aspect = t / e), null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), (this.view.enabled = !0), (this.view.fullWidth = t), (this.view.fullHeight = e), (this.view.offsetX = i), (this.view.offsetY = n), (this.view.width = s), (this.view.height = r), this.updateProjectionMatrix();
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                    const t = this.near;
                    let e = (t * Math.tan(0.5 * at * this.fov)) / this.zoom,
                        i = 2 * e,
                        n = this.aspect * i,
                        s = -0.5 * n;
                    const r = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = r.fullWidth,
                            a = r.fullHeight;
                        (s += (r.offsetX * n) / t), (e -= (r.offsetY * i) / a), (n *= r.width / t), (i *= r.height / a);
                    }
                    const a = this.filmOffset;
                    0 !== a && (s += (t * a) / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, e, e - i, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (e.object.fov = this.fov), (e.object.zoom = this.zoom), (e.object.near = this.near), (e.object.far = this.far), (e.object.focus = this.focus), (e.object.aspect = this.aspect), null !== this.view && (e.object.view = Object.assign({}, this.view)), (e.object.filmGauge = this.filmGauge), (e.object.filmOffset = this.filmOffset), e;
                }
            }
            Fi.prototype.isPerspectiveCamera = !0;
            class Ui extends Be {
                constructor(t, e, i) {
                    if ((super(), (this.type = "CubeCamera"), !0 !== i.isWebGLCubeRenderTarget)) return;
                    this.renderTarget = i;
                    const n = new Fi(90, 1, t, e);
                    (n.layers = this.layers), n.up.set(0, -1, 0), n.lookAt(new bt(1, 0, 0)), this.add(n);
                    const s = new Fi(90, 1, t, e);
                    (s.layers = this.layers), s.up.set(0, -1, 0), s.lookAt(new bt(-1, 0, 0)), this.add(s);
                    const r = new Fi(90, 1, t, e);
                    (r.layers = this.layers), r.up.set(0, 0, 1), r.lookAt(new bt(0, 1, 0)), this.add(r);
                    const a = new Fi(90, 1, t, e);
                    (a.layers = this.layers), a.up.set(0, 0, -1), a.lookAt(new bt(0, -1, 0)), this.add(a);
                    const o = new Fi(90, 1, t, e);
                    (o.layers = this.layers), o.up.set(0, -1, 0), o.lookAt(new bt(0, 0, 1)), this.add(o);
                    const l = new Fi(90, 1, t, e);
                    (l.layers = this.layers), l.up.set(0, -1, 0), l.lookAt(new bt(0, 0, -1)), this.add(l);
                }
                update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const i = this.renderTarget,
                        [n, s, r, a, o, l] = this.children,
                        c = t.xr.enabled,
                        h = t.getRenderTarget();
                    t.xr.enabled = !1;
                    const u = i.texture.generateMipmaps;
                    (i.texture.generateMipmaps = !1), t.setRenderTarget(i, 0), t.render(e, n), t.setRenderTarget(i, 1), t.render(e, s), t.setRenderTarget(i, 2), t.render(e, r), t.setRenderTarget(i, 3), t.render(e, a), t.setRenderTarget(i, 4), t.render(e, o), (i.texture.generateMipmaps = u), t.setRenderTarget(i, 5), t.render(e, l), t.setRenderTarget(h), (t.xr.enabled = c);
                }
            }
            class ki extends wt {
                constructor(t, e, i, n, s, r, a, o, l, c) {
                    super((t = void 0 !== t ? t : []), (e = void 0 !== e ? e : 301), i, n, s, r, (a = void 0 !== a ? a : 1022), o, l, c), (this.flipY = !1);
                }
                get images() {
                    return this.image;
                }
                set images(t) {
                    this.image = t;
                }
            }
            ki.prototype.isCubeTexture = !0;
            class Oi extends Ct {
                constructor(t, e, i) {
                    Number.isInteger(e) && (e = i), super(t, t, e), (e = e || {}), (this.texture = new ki(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding)), (this.texture.isRenderTargetTexture = !0), (this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps), (this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : 1006), (this.texture._needsFlipEnvMap = !1);
                }
                fromEquirectangularTexture(t, e) {
                    (this.texture.type = e.type), (this.texture.format = 1023), (this.texture.encoding = e.encoding), (this.texture.generateMipmaps = e.generateMipmaps), (this.texture.minFilter = e.minFilter), (this.texture.magFilter = e.magFilter);
                    const i = { tEquirect: { value: null } },
                        n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        s = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                        r = new Li(5, 5, 5),
                        a = new Pi({ name: "CubemapFromEquirect", uniforms: Di(i), vertexShader: n, fragmentShader: s, side: 1, blending: 0 });
                    a.uniforms.tEquirect.value = e;
                    const o = new Bi(r, a),
                        l = e.minFilter;
                    return 1008 === e.minFilter && (e.minFilter = 1006), new Ui(1, 10, this).update(t, o), (e.minFilter = l), o.geometry.dispose(), o.material.dispose(), this;
                }
                clear(t, e, i, n) {
                    const s = t.getRenderTarget();
                    for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, i, n);
                    t.setRenderTarget(s);
                }
            }
            Oi.prototype.isWebGLCubeRenderTarget = !0;
            const Gi = new bt(),
                zi = new bt(),
                Vi = new ft();
            class Hi {
                constructor(t = new bt(1, 0, 0), e = 0) {
                    (this.normal = t), (this.constant = e);
                }
                set(t, e) {
                    return this.normal.copy(t), (this.constant = e), this;
                }
                setComponents(t, e, i, n) {
                    return this.normal.set(t, e, i), (this.constant = n), this;
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
                }
                setFromCoplanarPoints(t, e, i) {
                    const n = Gi.subVectors(i, e).cross(zi.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(n, t), this;
                }
                copy(t) {
                    return this.normal.copy(t.normal), (this.constant = t.constant), this;
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), (this.constant *= t), this;
                }
                negate() {
                    return (this.constant *= -1), this.normal.negate(), this;
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant;
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius;
                }
                projectPoint(t, e) {
                    return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
                }
                intersectLine(t, e) {
                    const i = t.delta(Gi),
                        n = this.normal.dot(i);
                    if (0 === n) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
                    const s = -(t.start.dot(this.normal) + this.constant) / n;
                    return s < 0 || s > 1 ? null : e.copy(i).multiplyScalar(s).add(t.start);
                }
                intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                        i = this.distanceToPoint(t.end);
                    return (e < 0 && i > 0) || (i < 0 && e > 0);
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this);
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this);
                }
                coplanarPoint(t) {
                    return t.copy(this.normal).multiplyScalar(-this.constant);
                }
                applyMatrix4(t, e) {
                    const i = e || Vi.getNormalMatrix(t),
                        n = this.coplanarPoint(Gi).applyMatrix4(t),
                        s = this.normal.applyMatrix3(i).normalize();
                    return (this.constant = -n.dot(s)), this;
                }
                translate(t) {
                    return (this.constant -= t.dot(this.normal)), this;
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            Hi.prototype.isPlane = !0;
            const Wi = new Jt(),
                qi = new bt();
            class ji {
                constructor(t = new Hi(), e = new Hi(), i = new Hi(), n = new Hi(), s = new Hi(), r = new Hi()) {
                    this.planes = [t, e, i, n, s, r];
                }
                set(t, e, i, n, s, r) {
                    const a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(s), a[5].copy(r), this;
                }
                copy(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
                    return this;
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        i = t.elements,
                        n = i[0],
                        s = i[1],
                        r = i[2],
                        a = i[3],
                        o = i[4],
                        l = i[5],
                        c = i[6],
                        h = i[7],
                        u = i[8],
                        d = i[9],
                        p = i[10],
                        A = i[11],
                        g = i[12],
                        m = i[13],
                        f = i[14],
                        v = i[15];
                    return e[0].setComponents(a - n, h - o, A - u, v - g).normalize(), e[1].setComponents(a + n, h + o, A + u, v + g).normalize(), e[2].setComponents(a + s, h + l, A + d, v + m).normalize(), e[3].setComponents(a - s, h - l, A - d, v - m).normalize(), e[4].setComponents(a - r, h - c, A - p, v - f).normalize(), e[5].setComponents(a + r, h + c, A + p, v + f).normalize(), this;
                }
                intersectsObject(t) {
                    const e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), Wi.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Wi);
                }
                intersectsSprite(t) {
                    return Wi.center.set(0, 0, 0), (Wi.radius = 0.7071067811865476), Wi.applyMatrix4(t.matrixWorld), this.intersectsSphere(Wi);
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        i = t.center,
                        n = -t.radius;
                    for (let t = 0; t < 6; t++) if (e[t].distanceToPoint(i) < n) return !1;
                    return !0;
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) {
                        const n = e[i];
                        if (((qi.x = n.normal.x > 0 ? t.max.x : t.min.x), (qi.y = n.normal.y > 0 ? t.max.y : t.min.y), (qi.z = n.normal.z > 0 ? t.max.z : t.min.z), n.distanceToPoint(qi) < 0)) return !1;
                    }
                    return !0;
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let i = 0; i < 6; i++) if (e[i].distanceToPoint(t) < 0) return !1;
                    return !0;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            function Yi() {
                let t = null,
                    e = !1,
                    i = null,
                    n = null;
                function s(e, r) {
                    i(e, r), (n = t.requestAnimationFrame(s));
                }
                return {
                    start: function () {
                        !0 !== e && null !== i && ((n = t.requestAnimationFrame(s)), (e = !0));
                    },
                    stop: function () {
                        t.cancelAnimationFrame(n), (e = !1);
                    },
                    setAnimationLoop: function (t) {
                        i = t;
                    },
                    setContext: function (e) {
                        t = e;
                    },
                };
            }
            function Ji(t, e) {
                const i = e.isWebGL2,
                    n = new WeakMap();
                return {
                    get: function (t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), n.get(t);
                    },
                    remove: function (e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const i = n.get(e);
                        i && (t.deleteBuffer(i.buffer), n.delete(e));
                    },
                    update: function (e, s) {
                        if (e.isGLBufferAttribute) {
                            const t = n.get(e);
                            return void ((!t || t.version < e.version) && n.set(e, { buffer: e.buffer, type: e.type, bytesPerElement: e.elementSize, version: e.version }));
                        }
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const r = n.get(e);
                        void 0 === r
                            ? n.set(
                                  e,
                                  (function (e, n) {
                                      const s = e.array,
                                          r = e.usage,
                                          a = t.createBuffer();
                                      t.bindBuffer(n, a), t.bufferData(n, s, r), e.onUploadCallback();
                                      let o = 5126;
                                      return s instanceof Float32Array ? (o = 5126) : s instanceof Float64Array || (s instanceof Uint16Array ? (e.isFloat16BufferAttribute ? i && (o = 5131) : (o = 5123)) : s instanceof Int16Array ? (o = 5122) : s instanceof Uint32Array ? (o = 5125) : s instanceof Int32Array ? (o = 5124) : s instanceof Int8Array ? (o = 5120) : (s instanceof Uint8Array || s instanceof Uint8ClampedArray) && (o = 5121)), { buffer: a, type: o, bytesPerElement: s.BYTES_PER_ELEMENT, version: e.version };
                                  })(e, s),
                              )
                            : r.version < e.version &&
                              ((function (e, n, s) {
                                  const r = n.array,
                                      a = n.updateRange;
                                  t.bindBuffer(s, e), -1 === a.count ? t.bufferSubData(s, 0, r) : (i ? t.bufferSubData(s, a.offset * r.BYTES_PER_ELEMENT, r, a.offset, a.count) : t.bufferSubData(s, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)), (a.count = -1));
                              })(r.buffer, e, s),
                              (r.version = e.version));
                    },
                };
            }
            class Xi extends ui {
                constructor(t = 1, e = 1, i = 1, n = 1) {
                    super(), (this.type = "PlaneGeometry"), (this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n });
                    const s = t / 2,
                        r = e / 2,
                        a = Math.floor(i),
                        o = Math.floor(n),
                        l = a + 1,
                        c = o + 1,
                        h = t / a,
                        u = e / o,
                        d = [],
                        p = [],
                        A = [],
                        g = [];
                    for (let t = 0; t < c; t++) {
                        const e = t * u - r;
                        for (let i = 0; i < l; i++) {
                            const n = i * h - s;
                            p.push(n, -e, 0), A.push(0, 0, 1), g.push(i / a), g.push(1 - t / o);
                        }
                    }
                    for (let t = 0; t < o; t++)
                        for (let e = 0; e < a; e++) {
                            const i = e + l * t,
                                n = e + l * (t + 1),
                                s = e + 1 + l * (t + 1),
                                r = e + 1 + l * t;
                            d.push(i, n, r), d.push(n, s, r);
                        }
                    this.setIndex(d), this.setAttribute("position", new ii(p, 3)), this.setAttribute("normal", new ii(A, 3)), this.setAttribute("uv", new ii(g, 2));
                }
                static fromJSON(t) {
                    return new Xi(t.width, t.height, t.widthSegments, t.heightSegments);
                }
            }
            const Ki = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment:
                        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment:
                        "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment:
                        "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex:
                        "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin:
                        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment:
                        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment:
                        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin:
                        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment:
                        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif",
                    transmission_pars_fragment:
                        "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag:
                        "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag:
                        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag:
                        "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                },
                Zi = {
                    common: { diffuse: { value: new Je(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new ft() }, uv2Transform: { value: new ft() }, alphaMap: { value: null } },
                    specularmap: { specularMap: { value: null } },
                    envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } },
                    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
                    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
                    emissivemap: { emissiveMap: { value: null } },
                    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
                    normalmap: { normalMap: { value: null }, normalScale: { value: new mt(1, 1) } },
                    displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } },
                    roughnessmap: { roughnessMap: { value: null } },
                    metalnessmap: { metalnessMap: { value: null } },
                    gradientmap: { gradientMap: { value: null } },
                    fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Je(16777215) } },
                    lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } },
                    points: { diffuse: { value: new Je(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ft() } },
                    sprite: { diffuse: { value: new Je(16777215) }, opacity: { value: 1 }, center: { value: new mt(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new ft() } },
                },
                $i = {
                    basic: { uniforms: Qi([Zi.common, Zi.specularmap, Zi.envmap, Zi.aomap, Zi.lightmap, Zi.fog]), vertexShader: Ki.meshbasic_vert, fragmentShader: Ki.meshbasic_frag },
                    lambert: { uniforms: Qi([Zi.common, Zi.specularmap, Zi.envmap, Zi.aomap, Zi.lightmap, Zi.emissivemap, Zi.fog, Zi.lights, { emissive: { value: new Je(0) } }]), vertexShader: Ki.meshlambert_vert, fragmentShader: Ki.meshlambert_frag },
                    phong: { uniforms: Qi([Zi.common, Zi.specularmap, Zi.envmap, Zi.aomap, Zi.lightmap, Zi.emissivemap, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, Zi.fog, Zi.lights, { emissive: { value: new Je(0) }, specular: { value: new Je(1118481) }, shininess: { value: 30 } }]), vertexShader: Ki.meshphong_vert, fragmentShader: Ki.meshphong_frag },
                    standard: { uniforms: Qi([Zi.common, Zi.envmap, Zi.aomap, Zi.lightmap, Zi.emissivemap, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, Zi.roughnessmap, Zi.metalnessmap, Zi.fog, Zi.lights, { emissive: { value: new Je(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: Ki.meshphysical_vert, fragmentShader: Ki.meshphysical_frag },
                    toon: { uniforms: Qi([Zi.common, Zi.aomap, Zi.lightmap, Zi.emissivemap, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, Zi.gradientmap, Zi.fog, Zi.lights, { emissive: { value: new Je(0) } }]), vertexShader: Ki.meshtoon_vert, fragmentShader: Ki.meshtoon_frag },
                    matcap: { uniforms: Qi([Zi.common, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, Zi.fog, { matcap: { value: null } }]), vertexShader: Ki.meshmatcap_vert, fragmentShader: Ki.meshmatcap_frag },
                    points: { uniforms: Qi([Zi.points, Zi.fog]), vertexShader: Ki.points_vert, fragmentShader: Ki.points_frag },
                    dashed: { uniforms: Qi([Zi.common, Zi.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: Ki.linedashed_vert, fragmentShader: Ki.linedashed_frag },
                    depth: { uniforms: Qi([Zi.common, Zi.displacementmap]), vertexShader: Ki.depth_vert, fragmentShader: Ki.depth_frag },
                    normal: { uniforms: Qi([Zi.common, Zi.bumpmap, Zi.normalmap, Zi.displacementmap, { opacity: { value: 1 } }]), vertexShader: Ki.normal_vert, fragmentShader: Ki.normal_frag },
                    sprite: { uniforms: Qi([Zi.sprite, Zi.fog]), vertexShader: Ki.sprite_vert, fragmentShader: Ki.sprite_frag },
                    background: { uniforms: { uvTransform: { value: new ft() }, t2D: { value: null } }, vertexShader: Ki.background_vert, fragmentShader: Ki.background_frag },
                    cube: { uniforms: Qi([Zi.envmap, { opacity: { value: 1 } }]), vertexShader: Ki.cube_vert, fragmentShader: Ki.cube_frag },
                    equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: Ki.equirect_vert, fragmentShader: Ki.equirect_frag },
                    distanceRGBA: { uniforms: Qi([Zi.common, Zi.displacementmap, { referencePosition: { value: new bt() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: Ki.distanceRGBA_vert, fragmentShader: Ki.distanceRGBA_frag },
                    shadow: { uniforms: Qi([Zi.lights, Zi.fog, { color: { value: new Je(0) }, opacity: { value: 1 } }]), vertexShader: Ki.shadow_vert, fragmentShader: Ki.shadow_frag },
                };
            function tn(t, e, i, n, s) {
                const r = new Je(0);
                let a,
                    o,
                    l = 0,
                    c = null,
                    h = 0,
                    u = null;
                function d(t, e) {
                    i.buffers.color.setClear(t.r, t.g, t.b, e, s);
                }
                return {
                    getClearColor: function () {
                        return r;
                    },
                    setClearColor: function (t, e = 1) {
                        r.set(t), (l = e), d(r, l);
                    },
                    getClearAlpha: function () {
                        return l;
                    },
                    setClearAlpha: function (t) {
                        (l = t), d(r, l);
                    },
                    render: function (i, s) {
                        let p = !1,
                            A = !0 === s.isScene ? s.background : null;
                        A && A.isTexture && (A = e.get(A));
                        const g = t.xr,
                            m = g.getSession && g.getSession();
                        m && "additive" === m.environmentBlendMode && (A = null),
                            null === A ? d(r, l) : A && A.isColor && (d(A, 1), (p = !0)),
                            (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
                            A && (A.isCubeTexture || 306 === A.mapping)
                                ? (void 0 === o &&
                                      ((o = new Bi(new Li(1, 1, 1), new Pi({ name: "BackgroundCubeMaterial", uniforms: Di($i.cube.uniforms), vertexShader: $i.cube.vertexShader, fragmentShader: $i.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))),
                                      o.geometry.deleteAttribute("normal"),
                                      o.geometry.deleteAttribute("uv"),
                                      (o.onBeforeRender = function (t, e, i) {
                                          this.matrixWorld.copyPosition(i.matrixWorld);
                                      }),
                                      Object.defineProperty(o.material, "envMap", {
                                          get: function () {
                                              return this.uniforms.envMap.value;
                                          },
                                      }),
                                      n.update(o)),
                                  (o.material.uniforms.envMap.value = A),
                                  (o.material.uniforms.flipEnvMap.value = A.isCubeTexture && !1 === A.isRenderTargetTexture ? -1 : 1),
                                  (c === A && h === A.version && u === t.toneMapping) || ((o.material.needsUpdate = !0), (c = A), (h = A.version), (u = t.toneMapping)),
                                  i.unshift(o, o.geometry, o.material, 0, 0, null))
                                : A &&
                                  A.isTexture &&
                                  (void 0 === a &&
                                      ((a = new Bi(new Xi(2, 2), new Pi({ name: "BackgroundMaterial", uniforms: Di($i.background.uniforms), vertexShader: $i.background.vertexShader, fragmentShader: $i.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))),
                                      a.geometry.deleteAttribute("normal"),
                                      Object.defineProperty(a.material, "map", {
                                          get: function () {
                                              return this.uniforms.t2D.value;
                                          },
                                      }),
                                      n.update(a)),
                                  (a.material.uniforms.t2D.value = A),
                                  !0 === A.matrixAutoUpdate && A.updateMatrix(),
                                  a.material.uniforms.uvTransform.value.copy(A.matrix),
                                  (c === A && h === A.version && u === t.toneMapping) || ((a.material.needsUpdate = !0), (c = A), (h = A.version), (u = t.toneMapping)),
                                  i.unshift(a, a.geometry, a.material, 0, 0, null));
                    },
                };
            }
            function en(t, e, i, n) {
                const s = t.getParameter(34921),
                    r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    a = n.isWebGL2 || null !== r,
                    o = {},
                    l = d(null);
                let c = l;
                function h(e) {
                    return n.isWebGL2 ? t.bindVertexArray(e) : r.bindVertexArrayOES(e);
                }
                function u(e) {
                    return n.isWebGL2 ? t.deleteVertexArray(e) : r.deleteVertexArrayOES(e);
                }
                function d(t) {
                    const e = [],
                        i = [],
                        n = [];
                    for (let t = 0; t < s; t++) (e[t] = 0), (i[t] = 0), (n[t] = 0);
                    return { geometry: null, program: null, wireframe: !1, newAttributes: e, enabledAttributes: i, attributeDivisors: n, object: t, attributes: {}, index: null };
                }
                function p() {
                    const t = c.newAttributes;
                    for (let e = 0, i = t.length; e < i; e++) t[e] = 0;
                }
                function A(t) {
                    g(t, 0);
                }
                function g(i, s) {
                    const r = c.newAttributes,
                        a = c.enabledAttributes,
                        o = c.attributeDivisors;
                    (r[i] = 1), 0 === a[i] && (t.enableVertexAttribArray(i), (a[i] = 1)), o[i] !== s && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, s), (o[i] = s));
                }
                function m() {
                    const e = c.newAttributes,
                        i = c.enabledAttributes;
                    for (let n = 0, s = i.length; n < s; n++) i[n] !== e[n] && (t.disableVertexAttribArray(n), (i[n] = 0));
                }
                function f(e, i, s, r, a, o) {
                    !0 !== n.isWebGL2 || (5124 !== s && 5125 !== s) ? t.vertexAttribPointer(e, i, s, r, a, o) : t.vertexAttribIPointer(e, i, s, a, o);
                }
                function v() {
                    y(), c !== l && ((c = l), h(c.object));
                }
                function y() {
                    (l.geometry = null), (l.program = null), (l.wireframe = !1);
                }
                return {
                    setup: function (s, l, u, v, y) {
                        let x = !1;
                        if (a) {
                            const e = (function (e, i, s) {
                                const a = !0 === s.wireframe;
                                let l = o[e.id];
                                void 0 === l && ((l = {}), (o[e.id] = l));
                                let c = l[i.id];
                                void 0 === c && ((c = {}), (l[i.id] = c));
                                let h = c[a];
                                return void 0 === h && ((h = d(n.isWebGL2 ? t.createVertexArray() : r.createVertexArrayOES())), (c[a] = h)), h;
                            })(v, u, l);
                            c !== e && ((c = e), h(c.object)),
                                (x = (function (t, e) {
                                    const i = c.attributes,
                                        n = t.attributes;
                                    let s = 0;
                                    for (const t in n) {
                                        const e = i[t],
                                            r = n[t];
                                        if (void 0 === e) return !0;
                                        if (e.attribute !== r) return !0;
                                        if (e.data !== r.data) return !0;
                                        s++;
                                    }
                                    return c.attributesNum !== s || c.index !== e;
                                })(v, y)),
                                x &&
                                    (function (t, e) {
                                        const i = {},
                                            n = t.attributes;
                                        let s = 0;
                                        for (const t in n) {
                                            const e = n[t],
                                                r = {};
                                            (r.attribute = e), e.data && (r.data = e.data), (i[t] = r), s++;
                                        }
                                        (c.attributes = i), (c.attributesNum = s), (c.index = e);
                                    })(v, y);
                        } else {
                            const t = !0 === l.wireframe;
                            (c.geometry === v.id && c.program === u.id && c.wireframe === t) || ((c.geometry = v.id), (c.program = u.id), (c.wireframe = t), (x = !0));
                        }
                        !0 === s.isInstancedMesh && (x = !0),
                            null !== y && i.update(y, 34963),
                            x &&
                                ((function (s, r, a, o) {
                                    if (!1 === n.isWebGL2 && (s.isInstancedMesh || o.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                                    p();
                                    const l = o.attributes,
                                        c = a.getAttributes(),
                                        h = r.defaultAttributeValues;
                                    for (const e in c) {
                                        const n = c[e];
                                        if (n >= 0) {
                                            const r = l[e];
                                            if (void 0 !== r) {
                                                const e = r.normalized,
                                                    s = r.itemSize,
                                                    a = i.get(r);
                                                if (void 0 === a) continue;
                                                const l = a.buffer,
                                                    c = a.type,
                                                    h = a.bytesPerElement;
                                                if (r.isInterleavedBufferAttribute) {
                                                    const i = r.data,
                                                        a = i.stride,
                                                        u = r.offset;
                                                    i && i.isInstancedInterleavedBuffer ? (g(n, i.meshPerAttribute), void 0 === o._maxInstanceCount && (o._maxInstanceCount = i.meshPerAttribute * i.count)) : A(n), t.bindBuffer(34962, l), f(n, s, c, e, a * h, u * h);
                                                } else r.isInstancedBufferAttribute ? (g(n, r.meshPerAttribute), void 0 === o._maxInstanceCount && (o._maxInstanceCount = r.meshPerAttribute * r.count)) : A(n), t.bindBuffer(34962, l), f(n, s, c, e, 0, 0);
                                            } else if ("instanceMatrix" === e) {
                                                const e = i.get(s.instanceMatrix);
                                                if (void 0 === e) continue;
                                                const r = e.buffer,
                                                    a = e.type;
                                                g(n + 0, 1), g(n + 1, 1), g(n + 2, 1), g(n + 3, 1), t.bindBuffer(34962, r), t.vertexAttribPointer(n + 0, 4, a, !1, 64, 0), t.vertexAttribPointer(n + 1, 4, a, !1, 64, 16), t.vertexAttribPointer(n + 2, 4, a, !1, 64, 32), t.vertexAttribPointer(n + 3, 4, a, !1, 64, 48);
                                            } else if ("instanceColor" === e) {
                                                const e = i.get(s.instanceColor);
                                                if (void 0 === e) continue;
                                                const r = e.buffer,
                                                    a = e.type;
                                                g(n, 1), t.bindBuffer(34962, r), t.vertexAttribPointer(n, 3, a, !1, 12, 0);
                                            } else if (void 0 !== h) {
                                                const i = h[e];
                                                if (void 0 !== i)
                                                    switch (i.length) {
                                                        case 2:
                                                            t.vertexAttrib2fv(n, i);
                                                            break;
                                                        case 3:
                                                            t.vertexAttrib3fv(n, i);
                                                            break;
                                                        case 4:
                                                            t.vertexAttrib4fv(n, i);
                                                            break;
                                                        default:
                                                            t.vertexAttrib1fv(n, i);
                                                    }
                                            }
                                        }
                                    }
                                    m();
                                })(s, l, u, v),
                                null !== y && t.bindBuffer(34963, i.get(y).buffer));
                    },
                    reset: v,
                    resetDefaultState: y,
                    dispose: function () {
                        v();
                        for (const t in o) {
                            const e = o[t];
                            for (const t in e) {
                                const i = e[t];
                                for (const t in i) u(i[t].object), delete i[t];
                                delete e[t];
                            }
                            delete o[t];
                        }
                    },
                    releaseStatesOfGeometry: function (t) {
                        if (void 0 === o[t.id]) return;
                        const e = o[t.id];
                        for (const t in e) {
                            const i = e[t];
                            for (const t in i) u(i[t].object), delete i[t];
                            delete e[t];
                        }
                        delete o[t.id];
                    },
                    releaseStatesOfProgram: function (t) {
                        for (const e in o) {
                            const i = o[e];
                            if (void 0 === i[t.id]) continue;
                            const n = i[t.id];
                            for (const t in n) u(n[t].object), delete n[t];
                            delete i[t.id];
                        }
                    },
                    initAttributes: p,
                    enableAttribute: A,
                    disableUnusedAttributes: m,
                };
            }
            function nn(t, e, i, n) {
                const s = n.isWebGL2;
                let r;
                (this.setMode = function (t) {
                    r = t;
                }),
                    (this.render = function (e, n) {
                        t.drawArrays(r, e, n), i.update(n, r, 1);
                    }),
                    (this.renderInstances = function (n, a, o) {
                        if (0 === o) return;
                        let l, c;
                        if (s) (l = t), (c = "drawArraysInstanced");
                        else if (((l = e.get("ANGLE_instanced_arrays")), (c = "drawArraysInstancedANGLE"), null === l)) return;
                        l[c](r, n, a, o), i.update(a, r, o);
                    });
            }
            function sn(t, e, i) {
                let n;
                function s(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump";
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
                }
                const r = ("undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext) || ("undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext);
                let a = void 0 !== i.precision ? i.precision : "highp";
                const o = s(a);
                o !== a && (a = o);
                const l = r || e.has("WEBGL_draw_buffers"),
                    c = !0 === i.logarithmicDepthBuffer,
                    h = t.getParameter(34930),
                    u = t.getParameter(35660),
                    d = t.getParameter(3379),
                    p = t.getParameter(34076),
                    A = t.getParameter(34921),
                    g = t.getParameter(36347),
                    m = t.getParameter(36348),
                    f = t.getParameter(36349),
                    v = u > 0,
                    y = r || e.has("OES_texture_float");
                return {
                    isWebGL2: r,
                    drawBuffers: l,
                    getMaxAnisotropy: function () {
                        if (void 0 !== n) return n;
                        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                            const i = e.get("EXT_texture_filter_anisotropic");
                            n = t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        } else n = 0;
                        return n;
                    },
                    getMaxPrecision: s,
                    precision: a,
                    logarithmicDepthBuffer: c,
                    maxTextures: h,
                    maxVertexTextures: u,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: A,
                    maxVertexUniforms: g,
                    maxVaryings: m,
                    maxFragmentUniforms: f,
                    vertexTextures: v,
                    floatFragmentTextures: y,
                    floatVertexTextures: v && y,
                    maxSamples: r ? t.getParameter(36183) : 0,
                };
            }
            function rn(t) {
                const e = this;
                let i = null,
                    n = 0,
                    s = !1,
                    r = !1;
                const a = new Hi(),
                    o = new ft(),
                    l = { value: null, needsUpdate: !1 };
                function c() {
                    l.value !== i && ((l.value = i), (l.needsUpdate = n > 0)), (e.numPlanes = n), (e.numIntersection = 0);
                }
                function h(t, i, n, s) {
                    const r = null !== t ? t.length : 0;
                    let c = null;
                    if (0 !== r) {
                        if (((c = l.value), !0 !== s || null === c)) {
                            const e = n + 4 * r,
                                s = i.matrixWorldInverse;
                            o.getNormalMatrix(s), (null === c || c.length < e) && (c = new Float32Array(e));
                            for (let e = 0, i = n; e !== r; ++e, i += 4) a.copy(t[e]).applyMatrix4(s, o), a.normal.toArray(c, i), (c[i + 3] = a.constant);
                        }
                        (l.value = c), (l.needsUpdate = !0);
                    }
                    return (e.numPlanes = r), (e.numIntersection = 0), c;
                }
                (this.uniform = l),
                    (this.numPlanes = 0),
                    (this.numIntersection = 0),
                    (this.init = function (t, e, r) {
                        const a = 0 !== t.length || e || 0 !== n || s;
                        return (s = e), (i = h(t, r, 0)), (n = t.length), a;
                    }),
                    (this.beginShadows = function () {
                        (r = !0), h(null);
                    }),
                    (this.endShadows = function () {
                        (r = !1), c();
                    }),
                    (this.setState = function (e, a, o) {
                        const u = e.clippingPlanes,
                            d = e.clipIntersection,
                            p = e.clipShadows,
                            A = t.get(e);
                        if (!s || null === u || 0 === u.length || (r && !p)) r ? h(null) : c();
                        else {
                            const t = r ? 0 : n,
                                e = 4 * t;
                            let s = A.clippingState || null;
                            (l.value = s), (s = h(u, a, e, o));
                            for (let t = 0; t !== e; ++t) s[t] = i[t];
                            (A.clippingState = s), (this.numIntersection = d ? this.numPlanes : 0), (this.numPlanes += t);
                        }
                    });
            }
            function an(t) {
                let e = new WeakMap();
                function i(t, e) {
                    return 303 === e ? (t.mapping = 301) : 304 === e && (t.mapping = 302), t;
                }
                function n(t) {
                    const i = t.target;
                    i.removeEventListener("dispose", n);
                    const s = e.get(i);
                    void 0 !== s && (e.delete(i), s.dispose());
                }
                return {
                    get: function (s) {
                        if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
                            const r = s.mapping;
                            if (303 === r || 304 === r) {
                                if (e.has(s)) return i(e.get(s).texture, s.mapping);
                                {
                                    const r = s.image;
                                    if (r && r.height > 0) {
                                        const a = t.getRenderTarget(),
                                            o = new Oi(r.height / 2);
                                        return o.fromEquirectangularTexture(t, s), e.set(s, o), t.setRenderTarget(a), s.addEventListener("dispose", n), i(o.texture, s.mapping);
                                    }
                                    return null;
                                }
                            }
                        }
                        return s;
                    },
                    dispose: function () {
                        e = new WeakMap();
                    },
                };
            }
            $i.physical = { uniforms: Qi([$i.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new mt(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Je(0) }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new mt() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationTint: { value: new Je(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularTint: { value: new Je(1, 1, 1) }, specularTintMap: { value: null } }]), vertexShader: Ki.meshphysical_vert, fragmentShader: Ki.meshphysical_frag };
            class on extends Ni {
                constructor(t = -1, e = 1, i = 1, n = -1, s = 0.1, r = 2e3) {
                    super(), (this.type = "OrthographicCamera"), (this.zoom = 1), (this.view = null), (this.left = t), (this.right = e), (this.top = i), (this.bottom = n), (this.near = s), (this.far = r), this.updateProjectionMatrix();
                }
                copy(t, e) {
                    return super.copy(t, e), (this.left = t.left), (this.right = t.right), (this.top = t.top), (this.bottom = t.bottom), (this.near = t.near), (this.far = t.far), (this.zoom = t.zoom), (this.view = null === t.view ? null : Object.assign({}, t.view)), this;
                }
                setViewOffset(t, e, i, n, s, r) {
                    null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), (this.view.enabled = !0), (this.view.fullWidth = t), (this.view.fullHeight = e), (this.view.offsetX = i), (this.view.offsetY = n), (this.view.width = s), (this.view.height = r), this.updateProjectionMatrix();
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
                }
                updateProjectionMatrix() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2;
                    let s = i - t,
                        r = i + t,
                        a = n + e,
                        o = n - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        (s += t * this.view.offsetX), (r = s + t * this.view.width), (a -= e * this.view.offsetY), (o = a - e * this.view.height);
                    }
                    this.projectionMatrix.makeOrthographic(s, r, a, o, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (e.object.zoom = this.zoom), (e.object.left = this.left), (e.object.right = this.right), (e.object.top = this.top), (e.object.bottom = this.bottom), (e.object.near = this.near), (e.object.far = this.far), null !== this.view && (e.object.view = Object.assign({}, this.view)), e;
                }
            }
            on.prototype.isOrthographicCamera = !0;
            class ln extends Pi {
                constructor(t) {
                    super(t), (this.type = "RawShaderMaterial");
                }
            }
            ln.prototype.isRawShaderMaterial = !0;
            const cn = Math.pow(2, 8),
                hn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
                un = 5 + hn.length,
                dn = { 3e3: 0, 3001: 1, 3002: 2, 3004: 3, 3005: 4, 3006: 5, 3007: 6 },
                pn = new Xe({ side: 1, depthWrite: !1, depthTest: !1 }),
                An = new Bi(new Li(), pn),
                gn = new on(),
                {
                    _lodPlanes: mn,
                    _sizeLods: fn,
                    _sigmas: vn,
                } = (function () {
                    const t = [],
                        e = [],
                        i = [];
                    let n = 8;
                    for (let s = 0; s < un; s++) {
                        const r = Math.pow(2, n);
                        e.push(r);
                        let a = 1 / r;
                        s > 4 ? (a = hn[s - 8 + 4 - 1]) : 0 == s && (a = 0), i.push(a);
                        const o = 1 / (r - 1),
                            l = -o / 2,
                            c = 1 + o / 2,
                            h = [l, l, c, l, c, c, l, l, c, c, l, c],
                            u = 6,
                            d = 6,
                            p = 3,
                            A = 2,
                            g = 1,
                            m = new Float32Array(p * d * u),
                            f = new Float32Array(A * d * u),
                            v = new Float32Array(g * d * u);
                        for (let t = 0; t < u; t++) {
                            const e = ((t % 3) * 2) / 3 - 1,
                                i = t > 2 ? 0 : -1,
                                n = [e, i, 0, e + 2 / 3, i, 0, e + 2 / 3, i + 1, 0, e, i, 0, e + 2 / 3, i + 1, 0, e, i + 1, 0];
                            m.set(n, p * d * t), f.set(h, A * d * t);
                            const s = [t, t, t, t, t, t];
                            v.set(s, g * d * t);
                        }
                        const y = new ui();
                        y.setAttribute("position", new $e(m, p)), y.setAttribute("uv", new $e(f, A)), y.setAttribute("faceIndex", new $e(v, g)), t.push(y), n > 4 && n--;
                    }
                    return { _lodPlanes: t, _sizeLods: e, _sigmas: i };
                })(),
                yn = new Je();
            let xn = null;
            const wn = (1 + Math.sqrt(5)) / 2,
                _n = 1 / wn,
                In = [new bt(1, 1, 1), new bt(-1, 1, 1), new bt(1, 1, -1), new bt(-1, 1, -1), new bt(0, wn, _n), new bt(0, wn, -_n), new bt(_n, 0, wn), new bt(-_n, 0, wn), new bt(wn, _n, 0), new bt(-wn, _n, 0)];
            function Cn(t) {
                const e = Math.max(t.r, t.g, t.b),
                    i = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
                return t.multiplyScalar(Math.pow(2, -i)), (i + 128) / 255;
            }
            class Mn {
                constructor(t) {
                    (this._renderer = t),
                        (this._pingPongRenderTarget = null),
                        (this._blurMaterial = (function () {
                            const t = new Float32Array(20),
                                e = new bt(0, 1, 0);
                            return new ln({
                                name: "SphericalGaussianBlur",
                                defines: { n: 20 },
                                uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: t }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: e }, inputEncoding: { value: dn[3e3] }, outputEncoding: { value: dn[3e3] } },
                                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                fragmentShader:
                                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1,
                            });
                        })()),
                        (this._equirectShader = null),
                        (this._cubemapShader = null),
                        this._compileMaterial(this._blurMaterial);
                }
                fromScene(t, e = 0, i = 0.1, n = 100) {
                    xn = this._renderer.getRenderTarget();
                    const s = this._allocateTargets();
                    return this._sceneToCubeUV(t, i, n, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s;
                }
                fromEquirectangular(t) {
                    return this._fromTexture(t);
                }
                fromCubemap(t) {
                    return this._fromTexture(t);
                }
                compileCubemapShader() {
                    null === this._cubemapShader && ((this._cubemapShader = Tn()), this._compileMaterial(this._cubemapShader));
                }
                compileEquirectangularShader() {
                    null === this._equirectShader && ((this._equirectShader = Bn()), this._compileMaterial(this._equirectShader));
                }
                dispose() {
                    this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
                    for (let t = 0; t < mn.length; t++) mn[t].dispose();
                }
                _cleanup(t) {
                    this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(xn), (t.scissorTest = !1), Sn(t, 0, 0, t.width, t.height);
                }
                _fromTexture(t) {
                    xn = this._renderer.getRenderTarget();
                    const e = this._allocateTargets(t);
                    return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
                }
                _allocateTargets(t) {
                    const e = { magFilter: 1003, minFilter: 1003, generateMipmaps: !1, type: 1009, format: 1023, encoding: En(t) ? t.encoding : 3002, depthBuffer: !1 },
                        i = bn(e);
                    return (i.depthBuffer = !t), (this._pingPongRenderTarget = bn(e)), i;
                }
                _compileMaterial(t) {
                    const e = new Bi(mn[0], t);
                    this._renderer.compile(e, gn);
                }
                _sceneToCubeUV(t, e, i, n) {
                    const s = new Fi(90, 1, e, i),
                        r = [1, -1, 1, 1, 1, 1],
                        a = [1, 1, 1, -1, -1, -1],
                        o = this._renderer,
                        l = o.autoClear,
                        c = o.outputEncoding,
                        h = o.toneMapping;
                    o.getClearColor(yn), (o.toneMapping = 0), (o.outputEncoding = 3e3), (o.autoClear = !1);
                    let u = !1;
                    const d = t.background;
                    if (d) {
                        if (d.isColor) {
                            pn.color.copy(d).convertSRGBToLinear(), (t.background = null);
                            const e = Cn(pn.color);
                            (pn.opacity = e), (u = !0);
                        }
                    } else {
                        pn.color.copy(yn).convertSRGBToLinear();
                        const t = Cn(pn.color);
                        (pn.opacity = t), (u = !0);
                    }
                    for (let e = 0; e < 6; e++) {
                        const i = e % 3;
                        0 == i ? (s.up.set(0, r[e], 0), s.lookAt(a[e], 0, 0)) : 1 == i ? (s.up.set(0, 0, r[e]), s.lookAt(0, a[e], 0)) : (s.up.set(0, r[e], 0), s.lookAt(0, 0, a[e])), Sn(n, i * cn, e > 2 ? cn : 0, cn, cn), o.setRenderTarget(n), u && o.render(An, s), o.render(t, s);
                    }
                    (o.toneMapping = h), (o.outputEncoding = c), (o.autoClear = l);
                }
                _textureToCubeUV(t, e) {
                    const i = this._renderer;
                    t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = Tn()) : null == this._equirectShader && (this._equirectShader = Bn());
                    const n = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
                        s = new Bi(mn[0], n),
                        r = n.uniforms;
                    (r.envMap.value = t), t.isCubeTexture || r.texelSize.value.set(1 / t.image.width, 1 / t.image.height), (r.inputEncoding.value = dn[t.encoding]), (r.outputEncoding.value = dn[e.texture.encoding]), Sn(e, 0, 0, 3 * cn, 2 * cn), i.setRenderTarget(e), i.render(s, gn);
                }
                _applyPMREM(t) {
                    const e = this._renderer,
                        i = e.autoClear;
                    e.autoClear = !1;
                    for (let e = 1; e < un; e++) {
                        const i = Math.sqrt(vn[e] * vn[e] - vn[e - 1] * vn[e - 1]),
                            n = In[(e - 1) % In.length];
                        this._blur(t, e - 1, e, i, n);
                    }
                    e.autoClear = i;
                }
                _blur(t, e, i, n, s) {
                    const r = this._pingPongRenderTarget;
                    this._halfBlur(t, r, e, i, n, "latitudinal", s), this._halfBlur(r, t, i, i, n, "longitudinal", s);
                }
                _halfBlur(t, e, i, n, s, r, a) {
                    const o = this._renderer,
                        l = this._blurMaterial,
                        c = new Bi(mn[n], l),
                        h = l.uniforms,
                        u = fn[i] - 1,
                        d = isFinite(s) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
                        p = s / d,
                        A = isFinite(s) ? 1 + Math.floor(3 * p) : 20,
                        g = [];
                    let m = 0;
                    for (let t = 0; t < 20; ++t) {
                        const e = t / p,
                            i = Math.exp((-e * e) / 2);
                        g.push(i), 0 == t ? (m += i) : t < A && (m += 2 * i);
                    }
                    for (let t = 0; t < g.length; t++) g[t] = g[t] / m;
                    (h.envMap.value = t.texture), (h.samples.value = A), (h.weights.value = g), (h.latitudinal.value = "latitudinal" === r), a && (h.poleAxis.value = a), (h.dTheta.value = d), (h.mipInt.value = 8 - i), (h.inputEncoding.value = dn[t.texture.encoding]), (h.outputEncoding.value = dn[t.texture.encoding]);
                    const f = fn[n];
                    Sn(e, 3 * Math.max(0, cn - 2 * f), (0 === n ? 0 : 2 * cn) + 2 * f * (n > 4 ? n - 8 + 4 : 0), 3 * f, 2 * f), o.setRenderTarget(e), o.render(c, gn);
                }
            }
            function En(t) {
                return void 0 !== t && 1009 === t.type && (3e3 === t.encoding || 3001 === t.encoding || 3007 === t.encoding);
            }
            function bn(t) {
                const e = new Ct(3 * cn, 3 * cn, t);
                return (e.texture.mapping = 306), (e.texture.name = "PMREM.cubeUv"), (e.scissorTest = !0), e;
            }
            function Sn(t, e, i, n, s) {
                t.viewport.set(e, i, n, s), t.scissor.set(e, i, n, s);
            }
            function Bn() {
                const t = new mt(1, 1);
                return new ln({
                    name: "EquirectangularToCubeUV",
                    uniforms: { envMap: { value: null }, texelSize: { value: t }, inputEncoding: { value: dn[3e3] }, outputEncoding: { value: dn[3e3] } },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader:
                        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                });
            }
            function Tn() {
                return new ln({
                    name: "CubemapToCubeUV",
                    uniforms: { envMap: { value: null }, inputEncoding: { value: dn[3e3] }, outputEncoding: { value: dn[3e3] } },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                });
            }
            function Ln(t) {
                let e = new WeakMap(),
                    i = null;
                function n(t) {
                    const i = t.target;
                    i.removeEventListener("dispose", n);
                    const s = e.get(i);
                    void 0 !== s && (s.delete(i), s.dispose());
                }
                return {
                    get: function (s) {
                        if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
                            const r = s.mapping,
                                a = 303 === r || 304 === r,
                                o = 301 === r || 302 === r;
                            if (a || o) {
                                if (e.has(s)) return e.get(s).texture;
                                {
                                    const r = s.image;
                                    if (
                                        (a && r && r.height > 0) ||
                                        (o &&
                                            r &&
                                            (function (t) {
                                                let e = 0;
                                                for (let i = 0; i < 6; i++) void 0 !== t[i] && e++;
                                                return 6 === e;
                                            })(r))
                                    ) {
                                        const r = t.getRenderTarget();
                                        null === i && (i = new Mn(t));
                                        const o = a ? i.fromEquirectangular(s) : i.fromCubemap(s);
                                        return e.set(s, o), t.setRenderTarget(r), s.addEventListener("dispose", n), o.texture;
                                    }
                                    return null;
                                }
                            }
                        }
                        return s;
                    },
                    dispose: function () {
                        (e = new WeakMap()), null !== i && (i.dispose(), (i = null));
                    },
                };
            }
            function Dn(t) {
                const e = {};
                function i(i) {
                    if (void 0 !== e[i]) return e[i];
                    let n;
                    switch (i) {
                        case "WEBGL_depth_texture":
                            n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            n = t.getExtension(i);
                    }
                    return (e[i] = n), n;
                }
                return {
                    has: function (t) {
                        return null !== i(t);
                    },
                    init: function (t) {
                        t.isWebGL2 ? i("EXT_color_buffer_float") : (i("WEBGL_depth_texture"), i("OES_texture_float"), i("OES_texture_half_float"), i("OES_texture_half_float_linear"), i("OES_standard_derivatives"), i("OES_element_index_uint"), i("OES_vertex_array_object"), i("ANGLE_instanced_arrays")), i("OES_texture_float_linear"), i("EXT_color_buffer_half_float");
                    },
                    get: function (t) {
                        const e = i(t);
                        return e;
                    },
                };
            }
            function Qn(t, e, i, n) {
                const s = {},
                    r = new WeakMap();
                function a(t) {
                    const o = t.target;
                    null !== o.index && e.remove(o.index);
                    for (const t in o.attributes) e.remove(o.attributes[t]);
                    o.removeEventListener("dispose", a), delete s[o.id];
                    const l = r.get(o);
                    l && (e.remove(l), r.delete(o)), n.releaseStatesOfGeometry(o), !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount, i.memory.geometries--;
                }
                function o(t) {
                    const i = [],
                        n = t.index,
                        s = t.attributes.position;
                    let a = 0;
                    if (null !== n) {
                        const t = n.array;
                        a = n.version;
                        for (let e = 0, n = t.length; e < n; e += 3) {
                            const n = t[e + 0],
                                s = t[e + 1],
                                r = t[e + 2];
                            i.push(n, s, s, r, r, n);
                        }
                    } else {
                        const t = s.array;
                        a = s.version;
                        for (let e = 0, n = t.length / 3 - 1; e < n; e += 3) {
                            const t = e + 0,
                                n = e + 1,
                                s = e + 2;
                            i.push(t, n, n, s, s, t);
                        }
                    }
                    const o = new (ni(i) > 65535 ? ei : ti)(i, 1);
                    o.version = a;
                    const l = r.get(t);
                    l && e.remove(l), r.set(t, o);
                }
                return {
                    get: function (t, e) {
                        return !0 === s[e.id] || (e.addEventListener("dispose", a), (s[e.id] = !0), i.memory.geometries++), e;
                    },
                    update: function (t) {
                        const i = t.attributes;
                        for (const t in i) e.update(i[t], 34962);
                        const n = t.morphAttributes;
                        for (const t in n) {
                            const i = n[t];
                            for (let t = 0, n = i.length; t < n; t++) e.update(i[t], 34962);
                        }
                    },
                    getWireframeAttribute: function (t) {
                        const e = r.get(t);
                        if (e) {
                            const i = t.index;
                            null !== i && e.version < i.version && o(t);
                        } else o(t);
                        return r.get(t);
                    },
                };
            }
            function Rn(t, e, i, n) {
                const s = n.isWebGL2;
                let r, a, o;
                (this.setMode = function (t) {
                    r = t;
                }),
                    (this.setIndex = function (t) {
                        (a = t.type), (o = t.bytesPerElement);
                    }),
                    (this.render = function (e, n) {
                        t.drawElements(r, n, a, e * o), i.update(n, r, 1);
                    }),
                    (this.renderInstances = function (n, l, c) {
                        if (0 === c) return;
                        let h, u;
                        if (s) (h = t), (u = "drawElementsInstanced");
                        else if (((h = e.get("ANGLE_instanced_arrays")), (u = "drawElementsInstancedANGLE"), null === h)) return;
                        h[u](r, l, a, n * o, c), i.update(l, r, c);
                    });
            }
            function Pn(t) {
                const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
                return {
                    memory: { geometries: 0, textures: 0 },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function () {
                        e.frame++, (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
                    },
                    update: function (t, i, n) {
                        switch ((e.calls++, i)) {
                            case 4:
                                e.triangles += n * (t / 3);
                                break;
                            case 1:
                                e.lines += n * (t / 2);
                                break;
                            case 3:
                                e.lines += n * (t - 1);
                                break;
                            case 2:
                                e.lines += n * t;
                                break;
                            case 0:
                                e.points += n * t;
                        }
                    },
                };
            }
            function Nn(t, e) {
                return t[0] - e[0];
            }
            function Fn(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1]);
            }
            function Un(t) {
                const e = {},
                    i = new Float32Array(8),
                    n = [];
                for (let t = 0; t < 8; t++) n[t] = [t, 0];
                return {
                    update: function (s, r, a, o) {
                        const l = s.morphTargetInfluences,
                            c = void 0 === l ? 0 : l.length;
                        let h = e[r.id];
                        if (void 0 === h || h.length !== c) {
                            h = [];
                            for (let t = 0; t < c; t++) h[t] = [t, 0];
                            e[r.id] = h;
                        }
                        for (let t = 0; t < c; t++) {
                            const e = h[t];
                            (e[0] = t), (e[1] = l[t]);
                        }
                        h.sort(Fn);
                        for (let t = 0; t < 8; t++) t < c && h[t][1] ? ((n[t][0] = h[t][0]), (n[t][1] = h[t][1])) : ((n[t][0] = Number.MAX_SAFE_INTEGER), (n[t][1] = 0));
                        n.sort(Nn);
                        const u = r.morphAttributes.position,
                            d = r.morphAttributes.normal;
                        let p = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = n[t],
                                s = e[0],
                                a = e[1];
                            s !== Number.MAX_SAFE_INTEGER && a ? (u && r.getAttribute("morphTarget" + t) !== u[s] && r.setAttribute("morphTarget" + t, u[s]), d && r.getAttribute("morphNormal" + t) !== d[s] && r.setAttribute("morphNormal" + t, d[s]), (i[t] = a), (p += a)) : (u && !0 === r.hasAttribute("morphTarget" + t) && r.deleteAttribute("morphTarget" + t), d && !0 === r.hasAttribute("morphNormal" + t) && r.deleteAttribute("morphNormal" + t), (i[t] = 0));
                        }
                        const A = r.morphTargetsRelative ? 1 : 1 - p;
                        o.getUniforms().setValue(t, "morphTargetBaseInfluence", A), o.getUniforms().setValue(t, "morphTargetInfluences", i);
                    },
                };
            }
            function kn(t, e, i, n) {
                let s = new WeakMap();
                function r(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", r), i.remove(e.instanceMatrix), null !== e.instanceColor && i.remove(e.instanceColor);
                }
                return {
                    update: function (t) {
                        const a = n.render.frame,
                            o = t.geometry,
                            l = e.get(t, o);
                        return s.get(l) !== a && (e.update(l), s.set(l, a)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", r) && t.addEventListener("dispose", r), i.update(t.instanceMatrix, 34962), null !== t.instanceColor && i.update(t.instanceColor, 34962)), l;
                    },
                    dispose: function () {
                        s = new WeakMap();
                    },
                };
            }
            class On extends wt {
                constructor(t = null, e = 1, i = 1, n = 1) {
                    super(null), (this.image = { data: t, width: e, height: i, depth: n }), (this.magFilter = 1003), (this.minFilter = 1003), (this.wrapR = 1001), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.needsUpdate = !0);
                }
            }
            On.prototype.isDataTexture2DArray = !0;
            class Gn extends wt {
                constructor(t = null, e = 1, i = 1, n = 1) {
                    super(null), (this.image = { data: t, width: e, height: i, depth: n }), (this.magFilter = 1003), (this.minFilter = 1003), (this.wrapR = 1001), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.needsUpdate = !0);
                }
            }
            Gn.prototype.isDataTexture3D = !0;
            const zn = new wt(),
                Vn = new On(),
                Hn = new Gn(),
                Wn = new ki(),
                qn = [],
                jn = [],
                Yn = new Float32Array(16),
                Jn = new Float32Array(9),
                Xn = new Float32Array(4);
            function Kn(t, e, i) {
                const n = t[0];
                if (n <= 0 || n > 0) return t;
                const s = e * i;
                let r = qn[s];
                if ((void 0 === r && ((r = new Float32Array(s)), (qn[s] = r)), 0 !== e)) {
                    n.toArray(r, 0);
                    for (let n = 1, s = 0; n !== e; ++n) (s += i), t[n].toArray(r, s);
                }
                return r;
            }
            function Zn(t, e) {
                if (t.length !== e.length) return !1;
                for (let i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
                return !0;
            }
            function $n(t, e) {
                for (let i = 0, n = e.length; i < n; i++) t[i] = e[i];
            }
            function ts(t, e) {
                let i = jn[e];
                void 0 === i && ((i = new Int32Array(e)), (jn[e] = i));
                for (let n = 0; n !== e; ++n) i[n] = t.allocateTextureUnit();
                return i;
            }
            function es(t, e) {
                const i = this.cache;
                i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e));
            }
            function is(t, e) {
                const i = this.cache;
                if (void 0 !== e.x) (i[0] === e.x && i[1] === e.y) || (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
                else {
                    if (Zn(i, e)) return;
                    t.uniform2fv(this.addr, e), $n(i, e);
                }
            }
            function ns(t, e) {
                const i = this.cache;
                if (void 0 !== e.x) (i[0] === e.x && i[1] === e.y && i[2] === e.z) || (t.uniform3f(this.addr, e.x, e.y, e.z), (i[0] = e.x), (i[1] = e.y), (i[2] = e.z));
                else if (void 0 !== e.r) (i[0] === e.r && i[1] === e.g && i[2] === e.b) || (t.uniform3f(this.addr, e.r, e.g, e.b), (i[0] = e.r), (i[1] = e.g), (i[2] = e.b));
                else {
                    if (Zn(i, e)) return;
                    t.uniform3fv(this.addr, e), $n(i, e);
                }
            }
            function ss(t, e) {
                const i = this.cache;
                if (void 0 !== e.x) (i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w) || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), (i[0] = e.x), (i[1] = e.y), (i[2] = e.z), (i[3] = e.w));
                else {
                    if (Zn(i, e)) return;
                    t.uniform4fv(this.addr, e), $n(i, e);
                }
            }
            function rs(t, e) {
                const i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Zn(i, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), $n(i, e);
                } else {
                    if (Zn(i, n)) return;
                    Xn.set(n), t.uniformMatrix2fv(this.addr, !1, Xn), $n(i, n);
                }
            }
            function as(t, e) {
                const i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Zn(i, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), $n(i, e);
                } else {
                    if (Zn(i, n)) return;
                    Jn.set(n), t.uniformMatrix3fv(this.addr, !1, Jn), $n(i, n);
                }
            }
            function os(t, e) {
                const i = this.cache,
                    n = e.elements;
                if (void 0 === n) {
                    if (Zn(i, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), $n(i, e);
                } else {
                    if (Zn(i, n)) return;
                    Yn.set(n), t.uniformMatrix4fv(this.addr, !1, Yn), $n(i, n);
                }
            }
            function ls(t, e) {
                const i = this.cache;
                i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e));
            }
            function cs(t, e) {
                const i = this.cache;
                Zn(i, e) || (t.uniform2iv(this.addr, e), $n(i, e));
            }
            function hs(t, e) {
                const i = this.cache;
                Zn(i, e) || (t.uniform3iv(this.addr, e), $n(i, e));
            }
            function us(t, e) {
                const i = this.cache;
                Zn(i, e) || (t.uniform4iv(this.addr, e), $n(i, e));
            }
            function ds(t, e) {
                const i = this.cache;
                i[0] !== e && (t.uniform1ui(this.addr, e), (i[0] = e));
            }
            function ps(t, e) {
                const i = this.cache;
                Zn(i, e) || (t.uniform2uiv(this.addr, e), $n(i, e));
            }
            function As(t, e) {
                const i = this.cache;
                Zn(i, e) || (t.uniform3uiv(this.addr, e), $n(i, e));
            }
            function gs(t, e) {
                const i = this.cache;
                Zn(i, e) || (t.uniform4uiv(this.addr, e), $n(i, e));
            }
            function ms(t, e, i) {
                const n = this.cache,
                    s = i.allocateTextureUnit();
                n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.safeSetTexture2D(e || zn, s);
            }
            function fs(t, e, i) {
                const n = this.cache,
                    s = i.allocateTextureUnit();
                n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.setTexture3D(e || Hn, s);
            }
            function vs(t, e, i) {
                const n = this.cache,
                    s = i.allocateTextureUnit();
                n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.safeSetTextureCube(e || Wn, s);
            }
            function ys(t, e, i) {
                const n = this.cache,
                    s = i.allocateTextureUnit();
                n[0] !== s && (t.uniform1i(this.addr, s), (n[0] = s)), i.setTexture2DArray(e || Vn, s);
            }
            function xs(t, e) {
                t.uniform1fv(this.addr, e);
            }
            function ws(t, e) {
                const i = Kn(e, this.size, 2);
                t.uniform2fv(this.addr, i);
            }
            function _s(t, e) {
                const i = Kn(e, this.size, 3);
                t.uniform3fv(this.addr, i);
            }
            function Is(t, e) {
                const i = Kn(e, this.size, 4);
                t.uniform4fv(this.addr, i);
            }
            function Cs(t, e) {
                const i = Kn(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, i);
            }
            function Ms(t, e) {
                const i = Kn(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, i);
            }
            function Es(t, e) {
                const i = Kn(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, i);
            }
            function bs(t, e) {
                t.uniform1iv(this.addr, e);
            }
            function Ss(t, e) {
                t.uniform2iv(this.addr, e);
            }
            function Bs(t, e) {
                t.uniform3iv(this.addr, e);
            }
            function Ts(t, e) {
                t.uniform4iv(this.addr, e);
            }
            function Ls(t, e) {
                t.uniform1uiv(this.addr, e);
            }
            function Ds(t, e) {
                t.uniform2uiv(this.addr, e);
            }
            function Qs(t, e) {
                t.uniform3uiv(this.addr, e);
            }
            function Rs(t, e) {
                t.uniform4uiv(this.addr, e);
            }
            function Ps(t, e, i) {
                const n = e.length,
                    s = ts(i, n);
                t.uniform1iv(this.addr, s);
                for (let t = 0; t !== n; ++t) i.safeSetTexture2D(e[t] || zn, s[t]);
            }
            function Ns(t, e, i) {
                const n = e.length,
                    s = ts(i, n);
                t.uniform1iv(this.addr, s);
                for (let t = 0; t !== n; ++t) i.safeSetTextureCube(e[t] || Wn, s[t]);
            }
            function Fs(t, e, i) {
                (this.id = t),
                    (this.addr = i),
                    (this.cache = []),
                    (this.setValue = (function (t) {
                        switch (t) {
                            case 5126:
                                return es;
                            case 35664:
                                return is;
                            case 35665:
                                return ns;
                            case 35666:
                                return ss;
                            case 35674:
                                return rs;
                            case 35675:
                                return as;
                            case 35676:
                                return os;
                            case 5124:
                            case 35670:
                                return ls;
                            case 35667:
                            case 35671:
                                return cs;
                            case 35668:
                            case 35672:
                                return hs;
                            case 35669:
                            case 35673:
                                return us;
                            case 5125:
                                return ds;
                            case 36294:
                                return ps;
                            case 36295:
                                return As;
                            case 36296:
                                return gs;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return ms;
                            case 35679:
                            case 36299:
                            case 36307:
                                return fs;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return vs;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return ys;
                        }
                    })(e.type));
            }
            function Us(t, e, i) {
                (this.id = t),
                    (this.addr = i),
                    (this.cache = []),
                    (this.size = e.size),
                    (this.setValue = (function (t) {
                        switch (t) {
                            case 5126:
                                return xs;
                            case 35664:
                                return ws;
                            case 35665:
                                return _s;
                            case 35666:
                                return Is;
                            case 35674:
                                return Cs;
                            case 35675:
                                return Ms;
                            case 35676:
                                return Es;
                            case 5124:
                            case 35670:
                                return bs;
                            case 35667:
                            case 35671:
                                return Ss;
                            case 35668:
                            case 35672:
                                return Bs;
                            case 35669:
                            case 35673:
                                return Ts;
                            case 5125:
                                return Ls;
                            case 36294:
                                return Ds;
                            case 36295:
                                return Qs;
                            case 36296:
                                return Rs;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Ps;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Ns;
                        }
                    })(e.type));
            }
            function ks(t) {
                (this.id = t), (this.seq = []), (this.map = {});
            }
            (Us.prototype.updateCache = function (t) {
                const e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), $n(e, t);
            }),
                (ks.prototype.setValue = function (t, e, i) {
                    const n = this.seq;
                    for (let s = 0, r = n.length; s !== r; ++s) {
                        const r = n[s];
                        r.setValue(t, e[r.id], i);
                    }
                });
            const Os = /(\w+)(\])?(\[|\.)?/g;
            function Gs(t, e) {
                t.seq.push(e), (t.map[e.id] = e);
            }
            function zs(t, e, i) {
                const n = t.name,
                    s = n.length;
                for (Os.lastIndex = 0; ; ) {
                    const r = Os.exec(n),
                        a = Os.lastIndex;
                    let o = r[1];
                    const l = "]" === r[2],
                        c = r[3];
                    if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === s))) {
                        Gs(i, void 0 === c ? new Fs(o, t, e) : new Us(o, t, e));
                        break;
                    }
                    {
                        let t = i.map[o];
                        void 0 === t && ((t = new ks(o)), Gs(i, t)), (i = t);
                    }
                }
            }
            function Vs(t, e) {
                (this.seq = []), (this.map = {});
                const i = t.getProgramParameter(e, 35718);
                for (let n = 0; n < i; ++n) {
                    const i = t.getActiveUniform(e, n);
                    zs(i, t.getUniformLocation(e, i.name), this);
                }
            }
            function Hs(t, e, i) {
                const n = t.createShader(e);
                return t.shaderSource(n, i), t.compileShader(n), n;
            }
            (Vs.prototype.setValue = function (t, e, i, n) {
                const s = this.map[e];
                void 0 !== s && s.setValue(t, i, n);
            }),
                (Vs.prototype.setOptional = function (t, e, i) {
                    const n = e[i];
                    void 0 !== n && this.setValue(t, i, n);
                }),
                (Vs.upload = function (t, e, i, n) {
                    for (let s = 0, r = e.length; s !== r; ++s) {
                        const r = e[s],
                            a = i[r.id];
                        !1 !== a.needsUpdate && r.setValue(t, a.value, n);
                    }
                }),
                (Vs.seqWithValue = function (t, e) {
                    const i = [];
                    for (let n = 0, s = t.length; n !== s; ++n) {
                        const s = t[n];
                        s.id in e && i.push(s);
                    }
                    return i;
                });
            let Ws = 0;
            function qs(t) {
                switch (t) {
                    case 3e3:
                    default:
                        return ["Linear", "( value )"];
                    case 3001:
                        return ["sRGB", "( value )"];
                    case 3002:
                        return ["RGBE", "( value )"];
                    case 3004:
                        return ["RGBM", "( value, 7.0 )"];
                    case 3005:
                        return ["RGBM", "( value, 16.0 )"];
                    case 3006:
                        return ["RGBD", "( value, 256.0 )"];
                    case 3007:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case 3003:
                        return ["LogLuv", "( value )"];
                }
            }
            function js(t, e, i) {
                const n = t.getShaderParameter(e, 35713),
                    s = t.getShaderInfoLog(e).trim();
                return n && "" === s
                    ? ""
                    : "THREE.WebGLShader: gl.getShaderInfoLog() " +
                          i +
                          "\n" +
                          s +
                          (function (t) {
                              const e = t.split("\n");
                              for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                              return e.join("\n");
                          })(t.getShaderSource(e));
            }
            function Ys(t, e) {
                const i = qs(e);
                return "vec4 " + t + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }";
            }
            function Js(t, e) {
                const i = qs(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
            }
            function Xs(t, e) {
                let i;
                switch (e) {
                    case 1:
                    default:
                        i = "Linear";
                        break;
                    case 2:
                        i = "Reinhard";
                        break;
                    case 3:
                        i = "OptimizedCineon";
                        break;
                    case 4:
                        i = "ACESFilmic";
                        break;
                    case 5:
                        i = "Custom";
                }
                return "vec3 " + t + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
            }
            function Ks(t) {
                return "" !== t;
            }
            function Zs(t, e) {
                return t
                    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
                    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
                    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
                    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
                    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
                    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
                    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
                    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
            }
            function $s(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
            }
            const tr = /^[ \t]*#include +<([\w\d./]+)>/gm;
            function er(t) {
                return t.replace(tr, ir);
            }
            function ir(t, e) {
                const i = Ki[e];
                if (void 0 === i) throw new Error("Can not resolve #include <" + e + ">");
                return er(i);
            }
            const nr = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                sr = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
            function rr(t) {
                return t.replace(sr, or).replace(nr, ar);
            }
            function ar(t, e, i, n) {
                return or(t, e, i, n);
            }
            function or(t, e, i, n) {
                let s = "";
                for (let t = parseInt(e); t < parseInt(i); t++) s += n.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                return s;
            }
            function lr(t) {
                let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? (e += "\n#define HIGH_PRECISION") : "mediump" === t.precision ? (e += "\n#define MEDIUM_PRECISION") : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e;
            }
            function cr(t, e, i, n) {
                const s = t.getContext(),
                    r = i.defines;
                let a = i.vertexShader,
                    o = i.fragmentShader;
                const l = (function (t) {
                        let e = "SHADOWMAP_TYPE_BASIC";
                        return 1 === t.shadowMapType ? (e = "SHADOWMAP_TYPE_PCF") : 2 === t.shadowMapType ? (e = "SHADOWMAP_TYPE_PCF_SOFT") : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e;
                    })(i),
                    c = (function (t) {
                        let e = "ENVMAP_TYPE_CUBE";
                        if (t.envMap)
                            switch (t.envMapMode) {
                                case 301:
                                case 302:
                                    e = "ENVMAP_TYPE_CUBE";
                                    break;
                                case 306:
                                case 307:
                                    e = "ENVMAP_TYPE_CUBE_UV";
                            }
                        return e;
                    })(i),
                    h = (function (t) {
                        let e = "ENVMAP_MODE_REFLECTION";
                        if (t.envMap)
                            switch (t.envMapMode) {
                                case 302:
                                case 307:
                                    e = "ENVMAP_MODE_REFRACTION";
                            }
                        return e;
                    })(i),
                    u = (function (t) {
                        let e = "ENVMAP_BLENDING_NONE";
                        if (t.envMap)
                            switch (t.combine) {
                                case 0:
                                    e = "ENVMAP_BLENDING_MULTIPLY";
                                    break;
                                case 1:
                                    e = "ENVMAP_BLENDING_MIX";
                                    break;
                                case 2:
                                    e = "ENVMAP_BLENDING_ADD";
                            }
                        return e;
                    })(i),
                    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    p = i.isWebGL2
                        ? ""
                        : (function (t) {
                              return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission > 0) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ks).join("\n");
                          })(i),
                    A = (function (t) {
                        const e = [];
                        for (const i in t) {
                            const n = t[i];
                            !1 !== n && e.push("#define " + i + " " + n);
                        }
                        return e.join("\n");
                    })(r),
                    g = s.createProgram();
                let m,
                    f,
                    v = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
                i.isRawShaderMaterial
                    ? ((m = [A].filter(Ks).join("\n")), m.length > 0 && (m += "\n"), (f = [p, A].filter(Ks).join("\n")), f.length > 0 && (f += "\n"))
                    : ((m = [
                          lr(i),
                          "#define SHADER_NAME " + i.shaderName,
                          A,
                          i.instancing ? "#define USE_INSTANCING" : "",
                          i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                          i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                          "#define GAMMA_FACTOR " + d,
                          "#define MAX_BONES " + i.maxBones,
                          i.useFog && i.fog ? "#define USE_FOG" : "",
                          i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
                          i.map ? "#define USE_MAP" : "",
                          i.envMap ? "#define USE_ENVMAP" : "",
                          i.envMap ? "#define " + h : "",
                          i.lightMap ? "#define USE_LIGHTMAP" : "",
                          i.aoMap ? "#define USE_AOMAP" : "",
                          i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                          i.bumpMap ? "#define USE_BUMPMAP" : "",
                          i.normalMap ? "#define USE_NORMALMAP" : "",
                          i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
                          i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
                          i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                          i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                          i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                          i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
                          i.specularMap ? "#define USE_SPECULARMAP" : "",
                          i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
                          i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
                          i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                          i.metalnessMap ? "#define USE_METALNESSMAP" : "",
                          i.alphaMap ? "#define USE_ALPHAMAP" : "",
                          i.transmission ? "#define USE_TRANSMISSION" : "",
                          i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                          i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                          i.vertexTangents ? "#define USE_TANGENT" : "",
                          i.vertexColors ? "#define USE_COLOR" : "",
                          i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                          i.vertexUvs ? "#define USE_UV" : "",
                          i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                          i.flatShading ? "#define FLAT_SHADED" : "",
                          i.skinning ? "#define USE_SKINNING" : "",
                          i.useVertexTexture ? "#define BONE_TEXTURE" : "",
                          i.morphTargets ? "#define USE_MORPHTARGETS" : "",
                          i.morphNormals && !1 === i.flatShading ? "#define USE_MORPHNORMALS" : "",
                          i.doubleSided ? "#define DOUBLE_SIDED" : "",
                          i.flipSided ? "#define FLIP_SIDED" : "",
                          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                          i.shadowMapEnabled ? "#define " + l : "",
                          i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                          i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                          i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
                          "uniform mat4 modelMatrix;",
                          "uniform mat4 modelViewMatrix;",
                          "uniform mat4 projectionMatrix;",
                          "uniform mat4 viewMatrix;",
                          "uniform mat3 normalMatrix;",
                          "uniform vec3 cameraPosition;",
                          "uniform bool isOrthographic;",
                          "#ifdef USE_INSTANCING",
                          "\tattribute mat4 instanceMatrix;",
                          "#endif",
                          "#ifdef USE_INSTANCING_COLOR",
                          "\tattribute vec3 instanceColor;",
                          "#endif",
                          "attribute vec3 position;",
                          "attribute vec3 normal;",
                          "attribute vec2 uv;",
                          "#ifdef USE_TANGENT",
                          "\tattribute vec4 tangent;",
                          "#endif",
                          "#if defined( USE_COLOR_ALPHA )",
                          "\tattribute vec4 color;",
                          "#elif defined( USE_COLOR )",
                          "\tattribute vec3 color;",
                          "#endif",
                          "#ifdef USE_MORPHTARGETS",
                          "\tattribute vec3 morphTarget0;",
                          "\tattribute vec3 morphTarget1;",
                          "\tattribute vec3 morphTarget2;",
                          "\tattribute vec3 morphTarget3;",
                          "\t#ifdef USE_MORPHNORMALS",
                          "\t\tattribute vec3 morphNormal0;",
                          "\t\tattribute vec3 morphNormal1;",
                          "\t\tattribute vec3 morphNormal2;",
                          "\t\tattribute vec3 morphNormal3;",
                          "\t#else",
                          "\t\tattribute vec3 morphTarget4;",
                          "\t\tattribute vec3 morphTarget5;",
                          "\t\tattribute vec3 morphTarget6;",
                          "\t\tattribute vec3 morphTarget7;",
                          "\t#endif",
                          "#endif",
                          "#ifdef USE_SKINNING",
                          "\tattribute vec4 skinIndex;",
                          "\tattribute vec4 skinWeight;",
                          "#endif",
                          "\n",
                      ]
                          .filter(Ks)
                          .join("\n")),
                      (f = [
                          p,
                          lr(i),
                          "#define SHADER_NAME " + i.shaderName,
                          A,
                          i.alphaTest ? "#define ALPHATEST " + i.alphaTest + (i.alphaTest % 1 ? "" : ".0") : "",
                          "#define GAMMA_FACTOR " + d,
                          i.useFog && i.fog ? "#define USE_FOG" : "",
                          i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
                          i.map ? "#define USE_MAP" : "",
                          i.matcap ? "#define USE_MATCAP" : "",
                          i.envMap ? "#define USE_ENVMAP" : "",
                          i.envMap ? "#define " + c : "",
                          i.envMap ? "#define " + h : "",
                          i.envMap ? "#define " + u : "",
                          i.lightMap ? "#define USE_LIGHTMAP" : "",
                          i.aoMap ? "#define USE_AOMAP" : "",
                          i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                          i.bumpMap ? "#define USE_BUMPMAP" : "",
                          i.normalMap ? "#define USE_NORMALMAP" : "",
                          i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
                          i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
                          i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                          i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
                          i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                          i.specularMap ? "#define USE_SPECULARMAP" : "",
                          i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
                          i.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
                          i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                          i.metalnessMap ? "#define USE_METALNESSMAP" : "",
                          i.alphaMap ? "#define USE_ALPHAMAP" : "",
                          i.sheen ? "#define USE_SHEEN" : "",
                          i.transmission ? "#define USE_TRANSMISSION" : "",
                          i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                          i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
                          i.vertexTangents ? "#define USE_TANGENT" : "",
                          i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "",
                          i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                          i.vertexUvs ? "#define USE_UV" : "",
                          i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                          i.gradientMap ? "#define USE_GRADIENTMAP" : "",
                          i.flatShading ? "#define FLAT_SHADED" : "",
                          i.doubleSided ? "#define DOUBLE_SIDED" : "",
                          i.flipSided ? "#define FLIP_SIDED" : "",
                          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                          i.shadowMapEnabled ? "#define " + l : "",
                          i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                          i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
                          i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                          i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
                          (i.extensionShaderTextureLOD || i.envMap) && i.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
                          "uniform mat4 viewMatrix;",
                          "uniform vec3 cameraPosition;",
                          "uniform bool isOrthographic;",
                          0 !== i.toneMapping ? "#define TONE_MAPPING" : "",
                          0 !== i.toneMapping ? Ki.tonemapping_pars_fragment : "",
                          0 !== i.toneMapping ? Xs("toneMapping", i.toneMapping) : "",
                          i.dithering ? "#define DITHERING" : "",
                          Ki.encodings_pars_fragment,
                          i.map ? Ys("mapTexelToLinear", i.mapEncoding) : "",
                          i.matcap ? Ys("matcapTexelToLinear", i.matcapEncoding) : "",
                          i.envMap ? Ys("envMapTexelToLinear", i.envMapEncoding) : "",
                          i.emissiveMap ? Ys("emissiveMapTexelToLinear", i.emissiveMapEncoding) : "",
                          i.specularTintMap ? Ys("specularTintMapTexelToLinear", i.specularTintMapEncoding) : "",
                          i.lightMap ? Ys("lightMapTexelToLinear", i.lightMapEncoding) : "",
                          Js("linearToOutputTexel", i.outputEncoding),
                          i.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
                          "\n",
                      ]
                          .filter(Ks)
                          .join("\n"))),
                    (a = er(a)),
                    (a = Zs(a, i)),
                    (a = $s(a, i)),
                    (o = er(o)),
                    (o = Zs(o, i)),
                    (o = $s(o, i)),
                    (a = rr(a)),
                    (o = rr(o)),
                    i.isWebGL2 && !0 !== i.isRawShaderMaterial && ((v = "#version 300 es\n"), (m = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m), (f = ["#define varying in", "300 es" === i.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === i.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + f));
                const y = v + f + o,
                    x = Hs(s, 35633, v + m + a),
                    w = Hs(s, 35632, y);
                if ((s.attachShader(g, x), s.attachShader(g, w), void 0 !== i.index0AttributeName ? s.bindAttribLocation(g, 0, i.index0AttributeName) : !0 === i.morphTargets && s.bindAttribLocation(g, 0, "position"), s.linkProgram(g), t.debug.checkShaderErrors)) {
                    const t = s.getProgramInfoLog(g).trim(),
                        e = s.getShaderInfoLog(x).trim(),
                        i = s.getShaderInfoLog(w).trim();
                    let n = !0,
                        r = !0;
                    if (!1 === s.getProgramParameter(g, 35714)) {
                        n = !1;
                        js(s, x, "vertex"), js(s, w, "fragment");
                    } else "" !== t || ("" !== e && "" !== i) || (r = !1);
                    r && (this.diagnostics = { runnable: n, programLog: t, vertexShader: { log: e, prefix: m }, fragmentShader: { log: i, prefix: f } });
                }
                let _, I;
                return (
                    s.deleteShader(x),
                    s.deleteShader(w),
                    (this.getUniforms = function () {
                        return void 0 === _ && (_ = new Vs(s, g)), _;
                    }),
                    (this.getAttributes = function () {
                        return (
                            void 0 === I &&
                                (I = (function (t, e) {
                                    const i = {},
                                        n = t.getProgramParameter(e, 35721);
                                    for (let s = 0; s < n; s++) {
                                        const n = t.getActiveAttrib(e, s).name;
                                        i[n] = t.getAttribLocation(e, n);
                                    }
                                    return i;
                                })(s, g)),
                            I
                        );
                    }),
                    (this.destroy = function () {
                        n.releaseStatesOfProgram(this), s.deleteProgram(g), (this.program = void 0);
                    }),
                    (this.name = i.shaderName),
                    (this.id = Ws++),
                    (this.cacheKey = e),
                    (this.usedTimes = 1),
                    (this.program = g),
                    (this.vertexShader = x),
                    (this.fragmentShader = w),
                    this
                );
            }
            function hr(t, e, i, n, s, r, a) {
                const o = [],
                    l = s.isWebGL2,
                    c = s.logarithmicDepthBuffer,
                    h = s.floatVertexTextures,
                    u = s.maxVertexUniforms,
                    d = s.vertexTextures;
                let p = s.precision;
                const A = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                    g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "specularIntensityMap", "specularTintMap", "specularTintMapEncoding", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmission", "transmissionMap", "thicknessMap"];
                function m(t) {
                    let e;
                    return (e = t && t.isTexture ? t.encoding : t && t.isWebGLRenderTarget ? t.texture.encoding : 3e3), e;
                }
                return {
                    getParameters: function (r, o, g, f, v) {
                        const y = f.fog,
                            x = r.isMeshStandardMaterial ? f.environment : null,
                            w = (r.isMeshStandardMaterial ? i : e).get(r.envMap || x),
                            _ = A[r.type],
                            I = v.isSkinnedMesh
                                ? (function (t) {
                                      const e = t.skeleton.bones;
                                      if (h) return 1024;
                                      {
                                          const t = u,
                                              i = Math.floor((t - 20) / 4),
                                              n = Math.min(i, e.length);
                                          return n < e.length ? 0 : n;
                                      }
                                  })(v)
                                : 0;
                        let C, M;
                        if ((null !== r.precision && ((p = s.getMaxPrecision(r.precision)), r.precision), _)) {
                            const t = $i[_];
                            (C = t.vertexShader), (M = t.fragmentShader);
                        } else (C = r.vertexShader), (M = r.fragmentShader);
                        const E = t.getRenderTarget();
                        return {
                            isWebGL2: l,
                            shaderID: _,
                            shaderName: r.type,
                            vertexShader: C,
                            fragmentShader: M,
                            defines: r.defines,
                            isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                            glslVersion: r.glslVersion,
                            precision: p,
                            instancing: !0 === v.isInstancedMesh,
                            instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                            supportsVertexTextures: d,
                            outputEncoding: null !== E ? m(E.texture) : t.outputEncoding,
                            map: !!r.map,
                            mapEncoding: m(r.map),
                            matcap: !!r.matcap,
                            matcapEncoding: m(r.matcap),
                            envMap: !!w,
                            envMapMode: w && w.mapping,
                            envMapEncoding: m(w),
                            envMapCubeUV: !!w && (306 === w.mapping || 307 === w.mapping),
                            lightMap: !!r.lightMap,
                            lightMapEncoding: m(r.lightMap),
                            aoMap: !!r.aoMap,
                            emissiveMap: !!r.emissiveMap,
                            emissiveMapEncoding: m(r.emissiveMap),
                            bumpMap: !!r.bumpMap,
                            normalMap: !!r.normalMap,
                            objectSpaceNormalMap: 1 === r.normalMapType,
                            tangentSpaceNormalMap: 0 === r.normalMapType,
                            clearcoatMap: !!r.clearcoatMap,
                            clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!r.clearcoatNormalMap,
                            displacementMap: !!r.displacementMap,
                            roughnessMap: !!r.roughnessMap,
                            metalnessMap: !!r.metalnessMap,
                            specularMap: !!r.specularMap,
                            specularIntensityMap: !!r.specularIntensityMap,
                            specularTintMap: !!r.specularTintMap,
                            specularTintMapEncoding: m(r.specularTintMap),
                            alphaMap: !!r.alphaMap,
                            gradientMap: !!r.gradientMap,
                            sheen: !!r.sheen,
                            transmission: !!r.transmission,
                            transmissionMap: !!r.transmissionMap,
                            thicknessMap: !!r.thicknessMap,
                            combine: r.combine,
                            vertexTangents: !!r.normalMap && !!v.geometry && !!v.geometry.attributes.tangent,
                            vertexColors: r.vertexColors,
                            vertexAlphas: !0 === r.vertexColors && !!v.geometry && !!v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize,
                            vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap || r.thicknessMap || r.specularIntensityMap || r.specularTintMap),
                            uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmission || r.transmissionMap || r.thicknessMap || r.specularIntensityMap || r.specularTintMap || !r.displacementMap),
                            fog: !!y,
                            useFog: r.fog,
                            fogExp2: y && y.isFogExp2,
                            flatShading: !!r.flatShading,
                            sizeAttenuation: r.sizeAttenuation,
                            logarithmicDepthBuffer: c,
                            skinning: !0 === v.isSkinnedMesh && I > 0,
                            maxBones: I,
                            useVertexTexture: h,
                            morphTargets: !!v.geometry && !!v.geometry.morphAttributes.position,
                            morphNormals: !!v.geometry && !!v.geometry.morphAttributes.normal,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: a.numPlanes,
                            numClipIntersection: a.numIntersection,
                            dithering: r.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && g.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: r.toneMapped ? t.toneMapping : 0,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: r.premultipliedAlpha,
                            alphaTest: r.alphaTest,
                            doubleSided: 2 === r.side,
                            flipSided: 1 === r.side,
                            depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                            index0AttributeName: r.index0AttributeName,
                            extensionDerivatives: r.extensions && r.extensions.derivatives,
                            extensionFragDepth: r.extensions && r.extensions.fragDepth,
                            extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                            extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: l || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: r.customProgramCacheKey(),
                        };
                    },
                    getProgramCacheKey: function (e) {
                        const i = [];
                        if ((e.shaderID ? i.push(e.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)) for (const t in e.defines) i.push(t), i.push(e.defines[t]);
                        if (!1 === e.isRawShaderMaterial) {
                            for (let t = 0; t < g.length; t++) i.push(e[g[t]]);
                            i.push(t.outputEncoding), i.push(t.gammaFactor);
                        }
                        return i.push(e.customProgramCacheKey), i.join();
                    },
                    getUniforms: function (t) {
                        const e = A[t.type];
                        let i;
                        if (e) {
                            const t = $i[e];
                            i = Ri.clone(t.uniforms);
                        } else i = t.uniforms;
                        return i;
                    },
                    acquireProgram: function (e, i) {
                        let n;
                        for (let t = 0, e = o.length; t < e; t++) {
                            const e = o[t];
                            if (e.cacheKey === i) {
                                (n = e), ++n.usedTimes;
                                break;
                            }
                        }
                        return void 0 === n && ((n = new cr(t, i, e, r)), o.push(n)), n;
                    },
                    releaseProgram: function (t) {
                        if (0 == --t.usedTimes) {
                            const e = o.indexOf(t);
                            (o[e] = o[o.length - 1]), o.pop(), t.destroy();
                        }
                    },
                    programs: o,
                };
            }
            function ur() {
                let t = new WeakMap();
                return {
                    get: function (e) {
                        let i = t.get(e);
                        return void 0 === i && ((i = {}), t.set(e, i)), i;
                    },
                    remove: function (e) {
                        t.delete(e);
                    },
                    update: function (e, i, n) {
                        t.get(e)[i] = n;
                    },
                    dispose: function () {
                        t = new WeakMap();
                    },
                };
            }
            function dr(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
            }
            function pr(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
            }
            function Ar(t) {
                const e = [];
                let i = 0;
                const n = [],
                    s = [],
                    r = [],
                    a = { id: -1 };
                function o(n, s, r, o, l, c) {
                    let h = e[i];
                    const u = t.get(r);
                    return void 0 === h ? ((h = { id: n.id, object: n, geometry: s, material: r, program: u.program || a, groupOrder: o, renderOrder: n.renderOrder, z: l, group: c }), (e[i] = h)) : ((h.id = n.id), (h.object = n), (h.geometry = s), (h.material = r), (h.program = u.program || a), (h.groupOrder = o), (h.renderOrder = n.renderOrder), (h.z = l), (h.group = c)), i++, h;
                }
                return {
                    opaque: n,
                    transmissive: s,
                    transparent: r,
                    init: function () {
                        (i = 0), (n.length = 0), (s.length = 0), (r.length = 0);
                    },
                    push: function (t, e, i, a, l, c) {
                        const h = o(t, e, i, a, l, c);
                        i.transmission > 0 ? s.push(h) : !0 === i.transparent ? r.push(h) : n.push(h);
                    },
                    unshift: function (t, e, i, a, l, c) {
                        const h = o(t, e, i, a, l, c);
                        i.transmission > 0 ? s.unshift(h) : !0 === i.transparent ? r.unshift(h) : n.unshift(h);
                    },
                    finish: function () {
                        for (let t = i, n = e.length; t < n; t++) {
                            const i = e[t];
                            if (null === i.id) break;
                            (i.id = null), (i.object = null), (i.geometry = null), (i.material = null), (i.program = null), (i.group = null);
                        }
                    },
                    sort: function (t, e) {
                        n.length > 1 && n.sort(t || dr), s.length > 1 && s.sort(e || pr), r.length > 1 && r.sort(e || pr);
                    },
                };
            }
            function gr(t) {
                let e = new WeakMap();
                return {
                    get: function (i, n) {
                        let s;
                        return !1 === e.has(i) ? ((s = new Ar(t)), e.set(i, [s])) : n >= e.get(i).length ? ((s = new Ar(t)), e.get(i).push(s)) : (s = e.get(i)[n]), s;
                    },
                    dispose: function () {
                        e = new WeakMap();
                    },
                };
            }
            function mr() {
                const t = {};
                return {
                    get: function (e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let i;
                        switch (e.type) {
                            case "DirectionalLight":
                                i = { direction: new bt(), color: new Je() };
                                break;
                            case "SpotLight":
                                i = { position: new bt(), direction: new bt(), color: new Je(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
                                break;
                            case "PointLight":
                                i = { position: new bt(), color: new Je(), distance: 0, decay: 0 };
                                break;
                            case "HemisphereLight":
                                i = { direction: new bt(), skyColor: new Je(), groundColor: new Je() };
                                break;
                            case "RectAreaLight":
                                i = { color: new Je(), position: new bt(), halfWidth: new bt(), halfHeight: new bt() };
                        }
                        return (t[e.id] = i), i;
                    },
                };
            }
            let fr = 0;
            function vr(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
            }
            function yr(t, e) {
                const i = new mr(),
                    n = (function () {
                        const t = {};
                        return {
                            get: function (e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let i;
                                switch (e.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        i = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new mt() };
                                        break;
                                    case "PointLight":
                                        i = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new mt(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
                                }
                                return (t[e.id] = i), i;
                            },
                        };
                    })(),
                    s = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
                for (let t = 0; t < 9; t++) s.probe.push(new bt());
                const r = new bt(),
                    a = new se(),
                    o = new se();
                return {
                    setup: function (r) {
                        let a = 0,
                            o = 0,
                            l = 0;
                        for (let t = 0; t < 9; t++) s.probe[t].set(0, 0, 0);
                        let c = 0,
                            h = 0,
                            u = 0,
                            d = 0,
                            p = 0,
                            A = 0,
                            g = 0,
                            m = 0;
                        r.sort(vr);
                        for (let t = 0, e = r.length; t < e; t++) {
                            const e = r[t],
                                f = e.color,
                                v = e.intensity,
                                y = e.distance,
                                x = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                            if (e.isAmbientLight) (a += f.r * v), (o += f.g * v), (l += f.b * v);
                            else if (e.isLightProbe) for (let t = 0; t < 9; t++) s.probe[t].addScaledVector(e.sh.coefficients[t], v);
                            else if (e.isDirectionalLight) {
                                const t = i.get(e);
                                if ((t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow)) {
                                    const t = e.shadow,
                                        i = n.get(e);
                                    (i.shadowBias = t.bias), (i.shadowNormalBias = t.normalBias), (i.shadowRadius = t.radius), (i.shadowMapSize = t.mapSize), (s.directionalShadow[c] = i), (s.directionalShadowMap[c] = x), (s.directionalShadowMatrix[c] = e.shadow.matrix), A++;
                                }
                                (s.directional[c] = t), c++;
                            } else if (e.isSpotLight) {
                                const t = i.get(e);
                                if ((t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(f).multiplyScalar(v), (t.distance = y), (t.coneCos = Math.cos(e.angle)), (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))), (t.decay = e.decay), e.castShadow)) {
                                    const t = e.shadow,
                                        i = n.get(e);
                                    (i.shadowBias = t.bias), (i.shadowNormalBias = t.normalBias), (i.shadowRadius = t.radius), (i.shadowMapSize = t.mapSize), (s.spotShadow[u] = i), (s.spotShadowMap[u] = x), (s.spotShadowMatrix[u] = e.shadow.matrix), m++;
                                }
                                (s.spot[u] = t), u++;
                            } else if (e.isRectAreaLight) {
                                const t = i.get(e);
                                t.color.copy(f).multiplyScalar(v), t.halfWidth.set(0.5 * e.width, 0, 0), t.halfHeight.set(0, 0.5 * e.height, 0), (s.rectArea[d] = t), d++;
                            } else if (e.isPointLight) {
                                const t = i.get(e);
                                if ((t.color.copy(e.color).multiplyScalar(e.intensity), (t.distance = e.distance), (t.decay = e.decay), e.castShadow)) {
                                    const t = e.shadow,
                                        i = n.get(e);
                                    (i.shadowBias = t.bias), (i.shadowNormalBias = t.normalBias), (i.shadowRadius = t.radius), (i.shadowMapSize = t.mapSize), (i.shadowCameraNear = t.camera.near), (i.shadowCameraFar = t.camera.far), (s.pointShadow[h] = i), (s.pointShadowMap[h] = x), (s.pointShadowMatrix[h] = e.shadow.matrix), g++;
                                }
                                (s.point[h] = t), h++;
                            } else if (e.isHemisphereLight) {
                                const t = i.get(e);
                                t.skyColor.copy(e.color).multiplyScalar(v), t.groundColor.copy(e.groundColor).multiplyScalar(v), (s.hemi[p] = t), p++;
                            }
                        }
                        d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? ((s.rectAreaLTC1 = Zi.LTC_FLOAT_1), (s.rectAreaLTC2 = Zi.LTC_FLOAT_2)) : !0 === t.has("OES_texture_half_float_linear") && ((s.rectAreaLTC1 = Zi.LTC_HALF_1), (s.rectAreaLTC2 = Zi.LTC_HALF_2))), (s.ambient[0] = a), (s.ambient[1] = o), (s.ambient[2] = l);
                        const f = s.hash;
                        (f.directionalLength === c && f.pointLength === h && f.spotLength === u && f.rectAreaLength === d && f.hemiLength === p && f.numDirectionalShadows === A && f.numPointShadows === g && f.numSpotShadows === m) || ((s.directional.length = c), (s.spot.length = u), (s.rectArea.length = d), (s.point.length = h), (s.hemi.length = p), (s.directionalShadow.length = A), (s.directionalShadowMap.length = A), (s.pointShadow.length = g), (s.pointShadowMap.length = g), (s.spotShadow.length = m), (s.spotShadowMap.length = m), (s.directionalShadowMatrix.length = A), (s.pointShadowMatrix.length = g), (s.spotShadowMatrix.length = m), (f.directionalLength = c), (f.pointLength = h), (f.spotLength = u), (f.rectAreaLength = d), (f.hemiLength = p), (f.numDirectionalShadows = A), (f.numPointShadows = g), (f.numSpotShadows = m), (s.version = fr++));
                    },
                    setupView: function (t, e) {
                        let i = 0,
                            n = 0,
                            l = 0,
                            c = 0,
                            h = 0;
                        const u = e.matrixWorldInverse;
                        for (let e = 0, d = t.length; e < d; e++) {
                            const d = t[e];
                            if (d.isDirectionalLight) {
                                const t = s.directional[i];
                                t.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(r), t.direction.transformDirection(u), i++;
                            } else if (d.isSpotLight) {
                                const t = s.spot[l];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(d.matrixWorld), r.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(r), t.direction.transformDirection(u), l++;
                            } else if (d.isRectAreaLight) {
                                const t = s.rectArea[c];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), o.identity(), a.copy(d.matrixWorld), a.premultiply(u), o.extractRotation(a), t.halfWidth.set(0.5 * d.width, 0, 0), t.halfHeight.set(0, 0.5 * d.height, 0), t.halfWidth.applyMatrix4(o), t.halfHeight.applyMatrix4(o), c++;
                            } else if (d.isPointLight) {
                                const t = s.point[n];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(u), n++;
                            } else if (d.isHemisphereLight) {
                                const t = s.hemi[h];
                                t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++;
                            }
                        }
                    },
                    state: s,
                };
            }
            function xr(t, e) {
                const i = new yr(t, e),
                    n = [],
                    s = [];
                return {
                    init: function () {
                        (n.length = 0), (s.length = 0);
                    },
                    state: { lightsArray: n, shadowsArray: s, lights: i },
                    setupLights: function () {
                        i.setup(n);
                    },
                    setupLightsView: function (t) {
                        i.setupView(n, t);
                    },
                    pushLight: function (t) {
                        n.push(t);
                    },
                    pushShadow: function (t) {
                        s.push(t);
                    },
                };
            }
            function wr(t, e) {
                let i = new WeakMap();
                return {
                    get: function (n, s = 0) {
                        let r;
                        return !1 === i.has(n) ? ((r = new xr(t, e)), i.set(n, [r])) : s >= i.get(n).length ? ((r = new xr(t, e)), i.get(n).push(r)) : (r = i.get(n)[s]), r;
                    },
                    dispose: function () {
                        i = new WeakMap();
                    },
                };
            }
            class _r extends ze {
                constructor(t) {
                    super(), (this.type = "MeshDepthMaterial"), (this.depthPacking = 3200), (this.map = null), (this.alphaMap = null), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.fog = !1), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), (this.depthPacking = t.depthPacking), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), this;
                }
            }
            _r.prototype.isMeshDepthMaterial = !0;
            class Ir extends ze {
                constructor(t) {
                    super(), (this.type = "MeshDistanceMaterial"), (this.referencePosition = new bt()), (this.nearDistance = 1), (this.farDistance = 1e3), (this.map = null), (this.alphaMap = null), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.fog = !1), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.referencePosition.copy(t.referencePosition), (this.nearDistance = t.nearDistance), (this.farDistance = t.farDistance), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), this;
                }
            }
            function Cr(t, e, i) {
                let n = new ji();
                const s = new mt(),
                    r = new mt(),
                    a = new It(),
                    o = new _r({ depthPacking: 3201 }),
                    l = new Ir(),
                    c = {},
                    h = i.maxTextureSize,
                    u = { 0: 1, 1: 0, 2: 2 },
                    d = new Pi({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new mt() }, radius: { value: 4 } }, vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }),
                    p = d.clone();
                p.defines.HORIZONTAL_PASS = 1;
                const A = new ui();
                A.setAttribute("position", new $e(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
                const g = new Bi(A, d),
                    m = this;
                function f(i, n) {
                    const s = e.update(g);
                    (d.uniforms.shadow_pass.value = i.map.texture), (d.uniforms.resolution.value = i.mapSize), (d.uniforms.radius.value = i.radius), t.setRenderTarget(i.mapPass), t.clear(), t.renderBufferDirect(n, null, s, d, g, null), (p.uniforms.shadow_pass.value = i.mapPass.texture), (p.uniforms.resolution.value = i.mapSize), (p.uniforms.radius.value = i.radius), t.setRenderTarget(i.map), t.clear(), t.renderBufferDirect(n, null, s, p, g, null);
                }
                function v(e, i, n, s, r, a, h) {
                    let d = null;
                    const p = !0 === s.isPointLight ? e.customDistanceMaterial : e.customDepthMaterial;
                    if (((d = void 0 !== p ? p : !0 === s.isPointLight ? l : o), t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length)) {
                        const t = d.uuid,
                            e = n.uuid;
                        let i = c[t];
                        void 0 === i && ((i = {}), (c[t] = i));
                        let s = i[e];
                        void 0 === s && ((s = d.clone()), (i[e] = s)), (d = s);
                    }
                    return (d.visible = n.visible), (d.wireframe = n.wireframe), (d.side = 3 === h ? (null !== n.shadowSide ? n.shadowSide : n.side) : null !== n.shadowSide ? n.shadowSide : u[n.side]), (d.clipShadows = n.clipShadows), (d.clippingPlanes = n.clippingPlanes), (d.clipIntersection = n.clipIntersection), (d.wireframeLinewidth = n.wireframeLinewidth), (d.linewidth = n.linewidth), !0 === s.isPointLight && !0 === d.isMeshDistanceMaterial && (d.referencePosition.setFromMatrixPosition(s.matrixWorld), (d.nearDistance = r), (d.farDistance = a)), d;
                }
                function y(i, s, r, a, o) {
                    if (!1 === i.visible) return;
                    if (i.layers.test(s.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || (i.receiveShadow && 3 === o)) && (!i.frustumCulled || n.intersectsObject(i))) {
                        i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                        const n = e.update(i),
                            s = i.material;
                        if (Array.isArray(s)) {
                            const e = n.groups;
                            for (let l = 0, c = e.length; l < c; l++) {
                                const c = e[l],
                                    h = s[c.materialIndex];
                                if (h && h.visible) {
                                    const e = v(i, 0, h, a, r.near, r.far, o);
                                    t.renderBufferDirect(r, null, n, e, i, c);
                                }
                            }
                        } else if (s.visible) {
                            const e = v(i, 0, s, a, r.near, r.far, o);
                            t.renderBufferDirect(r, null, n, e, i, null);
                        }
                    }
                    const l = i.children;
                    for (let t = 0, e = l.length; t < e; t++) y(l[t], s, r, a, o);
                }
                (this.enabled = !1),
                    (this.autoUpdate = !0),
                    (this.needsUpdate = !1),
                    (this.type = 1),
                    (this.render = function (e, i, o) {
                        if (!1 === m.enabled) return;
                        if (!1 === m.autoUpdate && !1 === m.needsUpdate) return;
                        if (0 === e.length) return;
                        const l = t.getRenderTarget(),
                            c = t.getActiveCubeFace(),
                            u = t.getActiveMipmapLevel(),
                            d = t.state;
                        d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                        for (let l = 0, c = e.length; l < c; l++) {
                            const c = e[l],
                                u = c.shadow;
                            if (void 0 === u) continue;
                            if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                            s.copy(u.mapSize);
                            const p = u.getFrameExtents();
                            if ((s.multiply(p), r.copy(u.mapSize), (s.x > h || s.y > h) && (s.x > h && ((r.x = Math.floor(h / p.x)), (s.x = r.x * p.x), (u.mapSize.x = r.x)), s.y > h && ((r.y = Math.floor(h / p.y)), (s.y = r.y * p.y), (u.mapSize.y = r.y))), null === u.map && !u.isPointLightShadow && 3 === this.type)) {
                                const t = { minFilter: 1006, magFilter: 1006, format: 1023 };
                                (u.map = new Ct(s.x, s.y, t)), (u.map.texture.name = c.name + ".shadowMap"), (u.mapPass = new Ct(s.x, s.y, t)), u.camera.updateProjectionMatrix();
                            }
                            if (null === u.map) {
                                const t = { minFilter: 1003, magFilter: 1003, format: 1023 };
                                (u.map = new Ct(s.x, s.y, t)), (u.map.texture.name = c.name + ".shadowMap"), u.camera.updateProjectionMatrix();
                            }
                            t.setRenderTarget(u.map), t.clear();
                            const A = u.getViewportCount();
                            for (let t = 0; t < A; t++) {
                                const e = u.getViewport(t);
                                a.set(r.x * e.x, r.y * e.y, r.x * e.z, r.y * e.w), d.viewport(a), u.updateMatrices(c, t), (n = u.getFrustum()), y(i, o, u.camera, c, this.type);
                            }
                            u.isPointLightShadow || 3 !== this.type || f(u, o), (u.needsUpdate = !1);
                        }
                        (m.needsUpdate = !1), t.setRenderTarget(l, c, u);
                    });
            }
            function Mr(t, e, i) {
                const n = i.isWebGL2,
                    s = new (function () {
                        let e = !1;
                        const i = new It();
                        let n = null;
                        const s = new It(0, 0, 0, 0);
                        return {
                            setMask: function (i) {
                                n === i || e || (t.colorMask(i, i, i, i), (n = i));
                            },
                            setLocked: function (t) {
                                e = t;
                            },
                            setClear: function (e, n, r, a, o) {
                                !0 === o && ((e *= a), (n *= a), (r *= a)), i.set(e, n, r, a), !1 === s.equals(i) && (t.clearColor(e, n, r, a), s.copy(i));
                            },
                            reset: function () {
                                (e = !1), (n = null), s.set(-1, 0, 0, 0);
                            },
                        };
                    })(),
                    r = new (function () {
                        let e = !1,
                            i = null,
                            n = null,
                            s = null;
                        return {
                            setTest: function (t) {
                                t ? F(2929) : U(2929);
                            },
                            setMask: function (n) {
                                i === n || e || (t.depthMask(n), (i = n));
                            },
                            setFunc: function (e) {
                                if (n !== e) {
                                    if (e)
                                        switch (e) {
                                            case 0:
                                                t.depthFunc(512);
                                                break;
                                            case 1:
                                                t.depthFunc(519);
                                                break;
                                            case 2:
                                                t.depthFunc(513);
                                                break;
                                            case 3:
                                            default:
                                                t.depthFunc(515);
                                                break;
                                            case 4:
                                                t.depthFunc(514);
                                                break;
                                            case 5:
                                                t.depthFunc(518);
                                                break;
                                            case 6:
                                                t.depthFunc(516);
                                                break;
                                            case 7:
                                                t.depthFunc(517);
                                        }
                                    else t.depthFunc(515);
                                    n = e;
                                }
                            },
                            setLocked: function (t) {
                                e = t;
                            },
                            setClear: function (e) {
                                s !== e && (t.clearDepth(e), (s = e));
                            },
                            reset: function () {
                                (e = !1), (i = null), (n = null), (s = null);
                            },
                        };
                    })(),
                    a = new (function () {
                        let e = !1,
                            i = null,
                            n = null,
                            s = null,
                            r = null,
                            a = null,
                            o = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function (t) {
                                e || (t ? F(2960) : U(2960));
                            },
                            setMask: function (n) {
                                i === n || e || (t.stencilMask(n), (i = n));
                            },
                            setFunc: function (e, i, a) {
                                (n === e && s === i && r === a) || (t.stencilFunc(e, i, a), (n = e), (s = i), (r = a));
                            },
                            setOp: function (e, i, n) {
                                (a === e && o === i && l === n) || (t.stencilOp(e, i, n), (a = e), (o = i), (l = n));
                            },
                            setLocked: function (t) {
                                e = t;
                            },
                            setClear: function (e) {
                                c !== e && (t.clearStencil(e), (c = e));
                            },
                            reset: function () {
                                (e = !1), (i = null), (n = null), (s = null), (r = null), (a = null), (o = null), (l = null), (c = null);
                            },
                        };
                    })();
                let o = {},
                    l = null,
                    c = {},
                    h = null,
                    u = !1,
                    d = null,
                    p = null,
                    A = null,
                    g = null,
                    m = null,
                    f = null,
                    v = null,
                    y = !1,
                    x = null,
                    w = null,
                    _ = null,
                    I = null,
                    C = null;
                const M = t.getParameter(35661);
                let E = !1,
                    b = 0;
                const S = t.getParameter(7938);
                -1 !== S.indexOf("WebGL") ? ((b = parseFloat(/^WebGL (\d)/.exec(S)[1])), (E = b >= 1)) : -1 !== S.indexOf("OpenGL ES") && ((b = parseFloat(/^OpenGL ES (\d)/.exec(S)[1])), (E = b >= 2));
                let B = null,
                    T = {};
                const L = t.getParameter(3088),
                    D = t.getParameter(2978),
                    Q = new It().fromArray(L),
                    R = new It().fromArray(D);
                function P(e, i, n) {
                    const s = new Uint8Array(4),
                        r = t.createTexture();
                    t.bindTexture(e, r), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let e = 0; e < n; e++) t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, s);
                    return r;
                }
                const N = {};
                function F(e) {
                    !0 !== o[e] && (t.enable(e), (o[e] = !0));
                }
                function U(e) {
                    !1 !== o[e] && (t.disable(e), (o[e] = !1));
                }
                (N[3553] = P(3553, 3553, 1)), (N[34067] = P(34067, 34069, 6)), s.setClear(0, 0, 0, 1), r.setClear(1), a.setClear(0), F(2929), r.setFunc(3), z(!1), V(1), F(2884), G(0);
                const k = { 100: 32774, 101: 32778, 102: 32779 };
                if (n) (k[103] = 32775), (k[104] = 32776);
                else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && ((k[103] = t.MIN_EXT), (k[104] = t.MAX_EXT));
                }
                const O = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
                function G(e, i, n, s, r, a, o, l) {
                    if (0 !== e) {
                        if ((!1 === u && (F(3042), (u = !0)), 5 === e)) (r = r || i), (a = a || n), (o = o || s), (i === p && r === m) || (t.blendEquationSeparate(k[i], k[r]), (p = i), (m = r)), (n === A && s === g && a === f && o === v) || (t.blendFuncSeparate(O[n], O[s], O[a], O[o]), (A = n), (g = s), (f = a), (v = o)), (d = e), (y = null);
                        else if (e !== d || l !== y) {
                            if (((100 === p && 100 === m) || (t.blendEquation(32774), (p = 100), (m = 100)), l))
                                switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(1, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(1, 1);
                                        break;
                                    case 3:
                                        t.blendFuncSeparate(0, 0, 769, 771);
                                        break;
                                    case 4:
                                        t.blendFuncSeparate(0, 768, 0, 770);
                                }
                            else
                                switch (e) {
                                    case 1:
                                        t.blendFuncSeparate(770, 771, 1, 771);
                                        break;
                                    case 2:
                                        t.blendFunc(770, 1);
                                        break;
                                    case 3:
                                        t.blendFunc(0, 769);
                                        break;
                                    case 4:
                                        t.blendFunc(0, 768);
                                }
                            (A = null), (g = null), (f = null), (v = null), (d = e), (y = l);
                        }
                    } else !0 === u && (U(3042), (u = !1));
                }
                function z(e) {
                    x !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (x = e));
                }
                function V(e) {
                    0 !== e ? (F(2884), e !== w && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : U(2884), (w = e);
                }
                function H(e, i, n) {
                    e ? (F(32823), (I === i && C === n) || (t.polygonOffset(i, n), (I = i), (C = n))) : U(32823);
                }
                function W(e) {
                    void 0 === e && (e = 33984 + M - 1), B !== e && (t.activeTexture(e), (B = e));
                }
                return {
                    buffers: { color: s, depth: r, stencil: a },
                    enable: F,
                    disable: U,
                    bindFramebuffer: function (e, i) {
                        return null === i && null !== l && (i = l), c[e] !== i && (t.bindFramebuffer(e, i), (c[e] = i), n && (36009 === e && (c[36160] = i), 36160 === e && (c[36009] = i)), !0);
                    },
                    bindXRFramebuffer: function (e) {
                        e !== l && (t.bindFramebuffer(36160, e), (l = e));
                    },
                    useProgram: function (e) {
                        return h !== e && (t.useProgram(e), (h = e), !0);
                    },
                    setBlending: G,
                    setMaterial: function (t, e) {
                        2 === t.side ? U(2884) : F(2884);
                        let i = 1 === t.side;
                        e && (i = !i), z(i), 1 === t.blending && !1 === t.transparent ? G(0) : G(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), r.setFunc(t.depthFunc), r.setTest(t.depthTest), r.setMask(t.depthWrite), s.setMask(t.colorWrite);
                        const n = t.stencilWrite;
                        a.setTest(n), n && (a.setMask(t.stencilWriteMask), a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? F(32926) : U(32926);
                    },
                    setFlipSided: z,
                    setCullFace: V,
                    setLineWidth: function (e) {
                        e !== _ && (E && t.lineWidth(e), (_ = e));
                    },
                    setPolygonOffset: H,
                    setScissorTest: function (t) {
                        t ? F(3089) : U(3089);
                    },
                    activeTexture: W,
                    bindTexture: function (e, i) {
                        null === B && W();
                        let n = T[B];
                        void 0 === n && ((n = { type: void 0, texture: void 0 }), (T[B] = n)), (n.type === e && n.texture === i) || (t.bindTexture(e, i || N[e]), (n.type = e), (n.texture = i));
                    },
                    unbindTexture: function () {
                        const e = T[B];
                        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), (e.type = void 0), (e.texture = void 0));
                    },
                    compressedTexImage2D: function () {
                        try {
                            t.compressedTexImage2D.apply(t, arguments);
                        } catch (t) {}
                    },
                    texImage2D: function () {
                        try {
                            t.texImage2D.apply(t, arguments);
                        } catch (t) {}
                    },
                    texImage3D: function () {
                        try {
                            t.texImage3D.apply(t, arguments);
                        } catch (t) {}
                    },
                    scissor: function (e) {
                        !1 === Q.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), Q.copy(e));
                    },
                    viewport: function (e) {
                        !1 === R.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), R.copy(e));
                    },
                    reset: function () {
                        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === n && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), (o = {}), (B = null), (T = {}), (l = null), (c = {}), (h = null), (u = !1), (d = null), (p = null), (A = null), (g = null), (m = null), (f = null), (v = null), (y = !1), (x = null), (w = null), (_ = null), (I = null), (C = null), Q.set(0, 0, t.canvas.width, t.canvas.height), R.set(0, 0, t.canvas.width, t.canvas.height), s.reset(), r.reset(), a.reset();
                    },
                };
            }
            function Er(t, e, i, n, s, r, a) {
                const o = s.isWebGL2,
                    l = (s.maxTextures, s.maxCubemapSize),
                    c = s.maxTextureSize,
                    h = s.maxSamples,
                    u = new WeakMap();
                let d,
                    p = !1;
                try {
                    p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
                } catch (t) {}
                function A(t, e) {
                    return p ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                }
                function g(t, e, i, n) {
                    let s = 1;
                    if (((t.width > n || t.height > n) && (s = n / Math.max(t.width, t.height)), s < 1 || !0 === e)) {
                        if (("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) || ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) || ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)) {
                            const n = e ? At : Math.floor,
                                r = n(s * t.width),
                                a = n(s * t.height);
                            void 0 === d && (d = A(r, a));
                            const o = i ? A(r, a) : d;
                            return (o.width = r), (o.height = a), o.getContext("2d").drawImage(t, 0, 0, r, a), o;
                        }
                        return t;
                    }
                    return t;
                }
                function m(t) {
                    return dt(t.width) && dt(t.height);
                }
                function f(t, e) {
                    return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter;
                }
                function v(e, i, s, r, a = 1) {
                    t.generateMipmap(e), (n.get(i).__maxMipLevel = Math.log2(Math.max(s, r, a)));
                }
                function y(i, n, s) {
                    if (!1 === o) return n;
                    if (null !== i && void 0 !== t[i]) return t[i];
                    let r = n;
                    return 6403 === n && (5126 === s && (r = 33326), 5131 === s && (r = 33325), 5121 === s && (r = 33321)), 6407 === n && (5126 === s && (r = 34837), 5131 === s && (r = 34843), 5121 === s && (r = 32849)), 6408 === n && (5126 === s && (r = 34836), 5131 === s && (r = 34842), 5121 === s && (r = 32856)), (33325 !== r && 33326 !== r && 34842 !== r && 34836 !== r) || e.get("EXT_color_buffer_float"), r;
                }
                function x(t) {
                    return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729;
                }
                function w(e) {
                    const i = e.target;
                    i.removeEventListener("dispose", w),
                        (function (e) {
                            const i = n.get(e);
                            void 0 !== i.__webglInit && (t.deleteTexture(i.__webglTexture), n.remove(e));
                        })(i),
                        i.isVideoTexture && u.delete(i),
                        a.memory.textures--;
                }
                function _(e) {
                    const i = e.target;
                    i.removeEventListener("dispose", _),
                        (function (e) {
                            const i = e.texture,
                                s = n.get(e),
                                r = n.get(i);
                            if (e) {
                                if ((void 0 !== r.__webglTexture && (t.deleteTexture(r.__webglTexture), a.memory.textures--), e.depthTexture && e.depthTexture.dispose(), e.isWebGLCubeRenderTarget)) for (let e = 0; e < 6; e++) t.deleteFramebuffer(s.__webglFramebuffer[e]), s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer[e]);
                                else t.deleteFramebuffer(s.__webglFramebuffer), s.__webglDepthbuffer && t.deleteRenderbuffer(s.__webglDepthbuffer), s.__webglMultisampledFramebuffer && t.deleteFramebuffer(s.__webglMultisampledFramebuffer), s.__webglColorRenderbuffer && t.deleteRenderbuffer(s.__webglColorRenderbuffer), s.__webglDepthRenderbuffer && t.deleteRenderbuffer(s.__webglDepthRenderbuffer);
                                if (e.isWebGLMultipleRenderTargets)
                                    for (let e = 0, s = i.length; e < s; e++) {
                                        const s = n.get(i[e]);
                                        s.__webglTexture && (t.deleteTexture(s.__webglTexture), a.memory.textures--), n.remove(i[e]);
                                    }
                                n.remove(i), n.remove(e);
                            }
                        })(i);
                }
                let I = 0;
                function C(t, e) {
                    const s = n.get(t);
                    if (
                        (t.isVideoTexture &&
                            (function (t) {
                                const e = a.render.frame;
                                u.get(t) !== e && (u.set(t, e), t.update());
                            })(t),
                        t.version > 0 && s.__version !== t.version)
                    ) {
                        const i = t.image;
                        if (void 0 === i);
                        else if (!1 !== i.complete) return void T(s, t, e);
                    }
                    i.activeTexture(33984 + e), i.bindTexture(3553, s.__webglTexture);
                }
                function M(e, s) {
                    const a = n.get(e);
                    e.version > 0 && a.__version !== e.version
                        ? (function (e, n, s) {
                              if (6 !== n.image.length) return;
                              B(e, n), i.activeTexture(33984 + s), i.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
                              const a = n && (n.isCompressedTexture || n.image[0].isCompressedTexture),
                                  c = n.image[0] && n.image[0].isDataTexture,
                                  h = [];
                              for (let t = 0; t < 6; t++) h[t] = a || c ? (c ? n.image[t].image : n.image[t]) : g(n.image[t], !1, !0, l);
                              const u = h[0],
                                  d = m(u) || o,
                                  p = r.convert(n.format),
                                  A = r.convert(n.type),
                                  x = y(n.internalFormat, p, A);
                              let w;
                              if ((S(34067, n, d), a)) {
                                  for (let t = 0; t < 6; t++) {
                                      w = h[t].mipmaps;
                                      for (let e = 0; e < w.length; e++) {
                                          const s = w[e];
                                          1023 !== n.format && 1022 !== n.format ? null !== p && i.compressedTexImage2D(34069 + t, e, x, s.width, s.height, 0, s.data) : i.texImage2D(34069 + t, e, x, s.width, s.height, 0, p, A, s.data);
                                      }
                                  }
                                  e.__maxMipLevel = w.length - 1;
                              } else {
                                  w = n.mipmaps;
                                  for (let t = 0; t < 6; t++)
                                      if (c) {
                                          i.texImage2D(34069 + t, 0, x, h[t].width, h[t].height, 0, p, A, h[t].data);
                                          for (let e = 0; e < w.length; e++) {
                                              const n = w[e].image[t].image;
                                              i.texImage2D(34069 + t, e + 1, x, n.width, n.height, 0, p, A, n.data);
                                          }
                                      } else {
                                          i.texImage2D(34069 + t, 0, x, p, A, h[t]);
                                          for (let e = 0; e < w.length; e++) {
                                              const n = w[e];
                                              i.texImage2D(34069 + t, e + 1, x, p, A, n.image[t]);
                                          }
                                      }
                                  e.__maxMipLevel = w.length;
                              }
                              f(n, d) && v(34067, n, u.width, u.height), (e.__version = n.version), n.onUpdate && n.onUpdate(n);
                          })(a, e, s)
                        : (i.activeTexture(33984 + s), i.bindTexture(34067, a.__webglTexture));
                }
                const E = { 1e3: 10497, 1001: 33071, 1002: 33648 },
                    b = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
                function S(i, r, a) {
                    if ((a ? (t.texParameteri(i, 10242, E[r.wrapS]), t.texParameteri(i, 10243, E[r.wrapT]), (32879 !== i && 35866 !== i) || t.texParameteri(i, 32882, E[r.wrapR]), t.texParameteri(i, 10240, b[r.magFilter]), t.texParameteri(i, 10241, b[r.minFilter])) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), (32879 !== i && 35866 !== i) || t.texParameteri(i, 32882, 33071), 1001 === r.wrapS && r.wrapT, t.texParameteri(i, 10240, x(r.magFilter)), t.texParameteri(i, 10241, x(r.minFilter)), 1003 !== r.minFilter && r.minFilter), !0 === e.has("EXT_texture_filter_anisotropic"))) {
                        const a = e.get("EXT_texture_filter_anisotropic");
                        if (1015 === r.type && !1 === e.has("OES_texture_float_linear")) return;
                        if (!1 === o && 1016 === r.type && !1 === e.has("OES_texture_half_float_linear")) return;
                        (r.anisotropy > 1 || n.get(r).__currentAnisotropy) && (t.texParameterf(i, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, s.getMaxAnisotropy())), (n.get(r).__currentAnisotropy = r.anisotropy));
                    }
                }
                function B(e, i) {
                    void 0 === e.__webglInit && ((e.__webglInit = !0), i.addEventListener("dispose", w), (e.__webglTexture = t.createTexture()), a.memory.textures++);
                }
                function T(e, n, s) {
                    let a = 3553;
                    n.isDataTexture2DArray && (a = 35866), n.isDataTexture3D && (a = 32879), B(e, n), i.activeTexture(33984 + s), i.bindTexture(a, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), t.pixelStorei(37443, 0);
                    const l =
                            (function (t) {
                                return !o && (1001 !== t.wrapS || 1001 !== t.wrapT || (1003 !== t.minFilter && 1006 !== t.minFilter));
                            })(n) && !1 === m(n.image),
                        h = g(n.image, l, !1, c),
                        u = m(h) || o,
                        d = r.convert(n.format);
                    let p,
                        A = r.convert(n.type),
                        x = y(n.internalFormat, d, A);
                    S(a, n, u);
                    const w = n.mipmaps;
                    if (n.isDepthTexture) (x = 6402), o ? (x = 1015 === n.type ? 36012 : 1014 === n.type ? 33190 : 1020 === n.type ? 35056 : 33189) : n.type, 1026 === n.format && 6402 === x && 1012 !== n.type && 1014 !== n.type && ((n.type = 1012), (A = r.convert(n.type))), 1027 === n.format && 6402 === x && ((x = 34041), 1020 !== n.type && ((n.type = 1020), (A = r.convert(n.type)))), i.texImage2D(3553, 0, x, h.width, h.height, 0, d, A, null);
                    else if (n.isDataTexture)
                        if (w.length > 0 && u) {
                            for (let t = 0, e = w.length; t < e; t++) (p = w[t]), i.texImage2D(3553, t, x, p.width, p.height, 0, d, A, p.data);
                            (n.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
                        } else i.texImage2D(3553, 0, x, h.width, h.height, 0, d, A, h.data), (e.__maxMipLevel = 0);
                    else if (n.isCompressedTexture) {
                        for (let t = 0, e = w.length; t < e; t++) (p = w[t]), 1023 !== n.format && 1022 !== n.format ? null !== d && i.compressedTexImage2D(3553, t, x, p.width, p.height, 0, p.data) : i.texImage2D(3553, t, x, p.width, p.height, 0, d, A, p.data);
                        e.__maxMipLevel = w.length - 1;
                    } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, x, h.width, h.height, h.depth, 0, d, A, h.data), (e.__maxMipLevel = 0);
                    else if (n.isDataTexture3D) i.texImage3D(32879, 0, x, h.width, h.height, h.depth, 0, d, A, h.data), (e.__maxMipLevel = 0);
                    else if (w.length > 0 && u) {
                        for (let t = 0, e = w.length; t < e; t++) (p = w[t]), i.texImage2D(3553, t, x, d, A, p);
                        (n.generateMipmaps = !1), (e.__maxMipLevel = w.length - 1);
                    } else i.texImage2D(3553, 0, x, d, A, h), (e.__maxMipLevel = 0);
                    f(n, u) && v(a, n, h.width, h.height), (e.__version = n.version), n.onUpdate && n.onUpdate(n);
                }
                function L(e, s, a, o, l) {
                    const c = r.convert(a.format),
                        h = r.convert(a.type),
                        u = y(a.internalFormat, c, h);
                    32879 === l || 35866 === l ? i.texImage3D(l, 0, u, s.width, s.height, s.depth, 0, c, h, null) : i.texImage2D(l, 0, u, s.width, s.height, 0, c, h, null), i.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, l, n.get(a).__webglTexture, 0), i.bindFramebuffer(36160, null);
                }
                function D(e, i, n) {
                    if ((t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer)) {
                        let s = 33189;
                        if (n) {
                            const e = i.depthTexture;
                            e && e.isDepthTexture && (1015 === e.type ? (s = 36012) : 1014 === e.type && (s = 33190));
                            const n = Q(i);
                            t.renderbufferStorageMultisample(36161, n, s, i.width, i.height);
                        } else t.renderbufferStorage(36161, s, i.width, i.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e);
                    } else if (i.depthBuffer && i.stencilBuffer) {
                        if (n) {
                            const e = Q(i);
                            t.renderbufferStorageMultisample(36161, e, 35056, i.width, i.height);
                        } else t.renderbufferStorage(36161, 34041, i.width, i.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e);
                    } else {
                        const e = !0 === i.isWebGLMultipleRenderTargets ? i.texture[0] : i.texture,
                            s = r.convert(e.format),
                            a = r.convert(e.type),
                            o = y(e.internalFormat, s, a);
                        if (n) {
                            const e = Q(i);
                            t.renderbufferStorageMultisample(36161, e, o, i.width, i.height);
                        } else t.renderbufferStorage(36161, o, i.width, i.height);
                    }
                    t.bindRenderbuffer(36161, null);
                }
                function Q(t) {
                    return o && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0;
                }
                let R = !1,
                    P = !1;
                (this.allocateTextureUnit = function () {
                    const t = I;
                    return (I += 1), t;
                }),
                    (this.resetTextureUnits = function () {
                        I = 0;
                    }),
                    (this.setTexture2D = C),
                    (this.setTexture2DArray = function (t, e) {
                        const s = n.get(t);
                        t.version > 0 && s.__version !== t.version ? T(s, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, s.__webglTexture));
                    }),
                    (this.setTexture3D = function (t, e) {
                        const s = n.get(t);
                        t.version > 0 && s.__version !== t.version ? T(s, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, s.__webglTexture));
                    }),
                    (this.setTextureCube = M),
                    (this.setupRenderTarget = function (e) {
                        const l = e.texture,
                            c = n.get(e),
                            h = n.get(l);
                        e.addEventListener("dispose", _), !0 !== e.isWebGLMultipleRenderTargets && ((h.__webglTexture = t.createTexture()), (h.__version = l.version), a.memory.textures++);
                        const u = !0 === e.isWebGLCubeRenderTarget,
                            d = !0 === e.isWebGLMultipleRenderTargets,
                            p = !0 === e.isWebGLMultisampleRenderTarget,
                            A = l.isDataTexture3D || l.isDataTexture2DArray,
                            g = m(e) || o;
                        if ((!o || 1022 !== l.format || (1015 !== l.type && 1016 !== l.type) || (l.format = 1023), u)) {
                            c.__webglFramebuffer = [];
                            for (let e = 0; e < 6; e++) c.__webglFramebuffer[e] = t.createFramebuffer();
                        } else if (((c.__webglFramebuffer = t.createFramebuffer()), d)) {
                            if (s.drawBuffers) {
                                const i = e.texture;
                                for (let e = 0, s = i.length; e < s; e++) {
                                    const s = n.get(i[e]);
                                    void 0 === s.__webglTexture && ((s.__webglTexture = t.createTexture()), a.memory.textures++);
                                }
                            }
                        } else if (p && o) {
                            (c.__webglMultisampledFramebuffer = t.createFramebuffer()), (c.__webglColorRenderbuffer = t.createRenderbuffer()), t.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                            const n = r.convert(l.format),
                                s = r.convert(l.type),
                                a = y(l.internalFormat, n, s),
                                o = Q(e);
                            t.renderbufferStorageMultisample(36161, o, a, e.width, e.height), i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && ((c.__webglDepthRenderbuffer = t.createRenderbuffer()), D(c.__webglDepthRenderbuffer, e, !0)), i.bindFramebuffer(36160, null);
                        }
                        if (u) {
                            i.bindTexture(34067, h.__webglTexture), S(34067, l, g);
                            for (let t = 0; t < 6; t++) L(c.__webglFramebuffer[t], e, l, 36064, 34069 + t);
                            f(l, g) && v(34067, l, e.width, e.height), i.bindTexture(34067, null);
                        } else if (d) {
                            const t = e.texture;
                            for (let s = 0, r = t.length; s < r; s++) {
                                const r = t[s],
                                    a = n.get(r);
                                i.bindTexture(3553, a.__webglTexture), S(3553, r, g), L(c.__webglFramebuffer, e, r, 36064 + s, 3553), f(r, g) && v(3553, r, e.width, e.height);
                            }
                            i.bindTexture(3553, null);
                        } else {
                            let t = 3553;
                            A && o && (t = l.isDataTexture3D ? 32879 : 35866), i.bindTexture(t, h.__webglTexture), S(t, l, g), L(c.__webglFramebuffer, e, l, 36064, t), f(l, g) && v(t, l, e.width, e.height, e.depth), i.bindTexture(t, null);
                        }
                        e.depthBuffer &&
                            (function (e) {
                                const s = n.get(e),
                                    r = !0 === e.isWebGLCubeRenderTarget;
                                if (e.depthTexture) {
                                    if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                                    !(function (e, s) {
                                        if (s && s.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                                        if ((i.bindFramebuffer(36160, e), !s.depthTexture || !s.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                                        (n.get(s.depthTexture).__webglTexture && s.depthTexture.image.width === s.width && s.depthTexture.image.height === s.height) || ((s.depthTexture.image.width = s.width), (s.depthTexture.image.height = s.height), (s.depthTexture.needsUpdate = !0)), C(s.depthTexture, 0);
                                        const r = n.get(s.depthTexture).__webglTexture;
                                        if (1026 === s.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                                        else {
                                            if (1027 !== s.depthTexture.format) throw new Error("Unknown depthTexture format");
                                            t.framebufferTexture2D(36160, 33306, 3553, r, 0);
                                        }
                                    })(s.__webglFramebuffer, e);
                                } else if (r) {
                                    s.__webglDepthbuffer = [];
                                    for (let n = 0; n < 6; n++) i.bindFramebuffer(36160, s.__webglFramebuffer[n]), (s.__webglDepthbuffer[n] = t.createRenderbuffer()), D(s.__webglDepthbuffer[n], e, !1);
                                } else i.bindFramebuffer(36160, s.__webglFramebuffer), (s.__webglDepthbuffer = t.createRenderbuffer()), D(s.__webglDepthbuffer, e, !1);
                                i.bindFramebuffer(36160, null);
                            })(e);
                    }),
                    (this.updateRenderTargetMipmap = function (t) {
                        const e = m(t) || o,
                            s = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
                        for (let r = 0, a = s.length; r < a; r++) {
                            const a = s[r];
                            if (f(a, e)) {
                                const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                                    s = n.get(a).__webglTexture;
                                i.bindTexture(e, s), v(e, a, t.width, t.height), i.bindTexture(e, null);
                            }
                        }
                    }),
                    (this.updateMultisampleRenderTarget = function (e) {
                        if (e.isWebGLMultisampleRenderTarget && o) {
                            const s = e.width,
                                r = e.height;
                            let a = 16384;
                            e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024);
                            const o = n.get(e);
                            i.bindFramebuffer(36008, o.__webglMultisampledFramebuffer), i.bindFramebuffer(36009, o.__webglFramebuffer), t.blitFramebuffer(0, 0, s, r, 0, 0, s, r, a, 9728), i.bindFramebuffer(36008, null), i.bindFramebuffer(36009, o.__webglMultisampledFramebuffer);
                        }
                    }),
                    (this.safeSetTexture2D = function (t, e) {
                        t && t.isWebGLRenderTarget && (!1 === R && (R = !0), (t = t.texture)), C(t, e);
                    }),
                    (this.safeSetTextureCube = function (t, e) {
                        t && t.isWebGLCubeRenderTarget && (!1 === P && (P = !0), (t = t.texture)), M(t, e);
                    });
            }
            function br(t, e, i) {
                const n = i.isWebGL2;
                return {
                    convert: function (t) {
                        let i;
                        if (1009 === t) return 5121;
                        if (1017 === t) return 32819;
                        if (1018 === t) return 32820;
                        if (1019 === t) return 33635;
                        if (1010 === t) return 5120;
                        if (1011 === t) return 5122;
                        if (1012 === t) return 5123;
                        if (1013 === t) return 5124;
                        if (1014 === t) return 5125;
                        if (1015 === t) return 5126;
                        if (1016 === t) return n ? 5131 : ((i = e.get("OES_texture_half_float")), null !== i ? i.HALF_FLOAT_OES : null);
                        if (1021 === t) return 6406;
                        if (1022 === t) return 6407;
                        if (1023 === t) return 6408;
                        if (1024 === t) return 6409;
                        if (1025 === t) return 6410;
                        if (1026 === t) return 6402;
                        if (1027 === t) return 34041;
                        if (1028 === t) return 6403;
                        if (1029 === t) return 36244;
                        if (1030 === t) return 33319;
                        if (1031 === t) return 33320;
                        if (1032 === t) return 36248;
                        if (1033 === t) return 36249;
                        if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                            if (((i = e.get("WEBGL_compressed_texture_s3tc")), null === i)) return null;
                            if (33776 === t) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (33777 === t) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (33778 === t) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (33779 === t) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        }
                        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                            if (((i = e.get("WEBGL_compressed_texture_pvrtc")), null === i)) return null;
                            if (35840 === t) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === t) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === t) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === t) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                        }
                        if (36196 === t) return (i = e.get("WEBGL_compressed_texture_etc1")), null !== i ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((37492 === t || 37496 === t) && ((i = e.get("WEBGL_compressed_texture_etc")), null !== i)) {
                            if (37492 === t) return i.COMPRESSED_RGB8_ETC2;
                            if (37496 === t) return i.COMPRESSED_RGBA8_ETC2_EAC;
                        }
                        return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? ((i = e.get("WEBGL_compressed_texture_astc")), null !== i ? t : null) : 36492 === t ? ((i = e.get("EXT_texture_compression_bptc")), null !== i ? t : null) : 1020 === t ? (n ? 34042 : ((i = e.get("WEBGL_depth_texture")), null !== i ? i.UNSIGNED_INT_24_8_WEBGL : null)) : void 0;
                    },
                };
            }
            Ir.prototype.isMeshDistanceMaterial = !0;
            class Sr extends Fi {
                constructor(t = []) {
                    super(), (this.cameras = t);
                }
            }
            Sr.prototype.isArrayCamera = !0;
            class Br extends Be {
                constructor() {
                    super(), (this.type = "Group");
                }
            }
            Br.prototype.isGroup = !0;
            const Tr = { type: "move" };
            class Lr {
                constructor() {
                    (this._targetRay = null), (this._grip = null), (this._hand = null);
                }
                getHandSpace() {
                    return null === this._hand && ((this._hand = new Br()), (this._hand.matrixAutoUpdate = !1), (this._hand.visible = !1), (this._hand.joints = {}), (this._hand.inputState = { pinching: !1 })), this._hand;
                }
                getTargetRaySpace() {
                    return null === this._targetRay && ((this._targetRay = new Br()), (this._targetRay.matrixAutoUpdate = !1), (this._targetRay.visible = !1), (this._targetRay.hasLinearVelocity = !1), (this._targetRay.linearVelocity = new bt()), (this._targetRay.hasAngularVelocity = !1), (this._targetRay.angularVelocity = new bt())), this._targetRay;
                }
                getGripSpace() {
                    return null === this._grip && ((this._grip = new Br()), (this._grip.matrixAutoUpdate = !1), (this._grip.visible = !1), (this._grip.hasLinearVelocity = !1), (this._grip.linearVelocity = new bt()), (this._grip.hasAngularVelocity = !1), (this._grip.angularVelocity = new bt())), this._grip;
                }
                dispatchEvent(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this;
                }
                disconnect(t) {
                    return this.dispatchEvent({ type: "disconnected", data: t }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this;
                }
                update(t, e, i) {
                    let n = null,
                        s = null,
                        r = null;
                    const a = this._targetRay,
                        o = this._grip,
                        l = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState)
                        if ((null !== a && ((n = e.getPose(t.targetRaySpace, i)), null !== n && (a.matrix.fromArray(n.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), n.linearVelocity ? ((a.hasLinearVelocity = !0), a.linearVelocity.copy(n.linearVelocity)) : (a.hasLinearVelocity = !1), n.angularVelocity ? ((a.hasAngularVelocity = !0), a.angularVelocity.copy(n.angularVelocity)) : (a.hasAngularVelocity = !1), this.dispatchEvent(Tr))), l && t.hand)) {
                            r = !0;
                            for (const n of t.hand.values()) {
                                const t = e.getJointPose(n, i);
                                if (void 0 === l.joints[n.jointName]) {
                                    const t = new Br();
                                    (t.matrixAutoUpdate = !1), (t.visible = !1), (l.joints[n.jointName] = t), l.add(t);
                                }
                                const s = l.joints[n.jointName];
                                null !== t && (s.matrix.fromArray(t.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), (s.jointRadius = t.radius)), (s.visible = null !== t);
                            }
                            const n = l.joints["index-finger-tip"],
                                s = l.joints["thumb-tip"],
                                a = n.position.distanceTo(s.position),
                                o = 0.02,
                                c = 0.005;
                            l.inputState.pinching && a > o + c ? ((l.inputState.pinching = !1), this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !l.inputState.pinching && a <= o - c && ((l.inputState.pinching = !0), this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }));
                        } else null !== o && t.gripSpace && ((s = e.getPose(t.gripSpace, i)), null !== s && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), s.linearVelocity ? ((o.hasLinearVelocity = !0), o.linearVelocity.copy(s.linearVelocity)) : (o.hasLinearVelocity = !1), s.angularVelocity ? ((o.hasAngularVelocity = !0), o.angularVelocity.copy(s.angularVelocity)) : (o.hasAngularVelocity = !1)));
                    return null !== a && (a.visible = null !== n), null !== o && (o.visible = null !== s), null !== l && (l.visible = null !== r), this;
                }
            }
            class Dr extends nt {
                constructor(t, e) {
                    super();
                    const i = this,
                        n = t.state;
                    let s = null,
                        r = 1,
                        a = null,
                        o = "local-floor",
                        l = null,
                        c = null,
                        h = null,
                        u = null,
                        d = null;
                    const p = [],
                        A = new Map(),
                        g = new Fi();
                    g.layers.enable(1), (g.viewport = new It());
                    const m = new Fi();
                    m.layers.enable(2), (m.viewport = new It());
                    const f = [g, m],
                        v = new Sr();
                    v.layers.enable(1), v.layers.enable(2);
                    let y = null,
                        x = null;
                    function w(t) {
                        const e = A.get(t.inputSource);
                        e && e.dispatchEvent({ type: t.type, data: t.inputSource });
                    }
                    function _() {
                        A.forEach(function (t, e) {
                            t.disconnect(e);
                        }),
                            A.clear(),
                            (y = null),
                            (x = null),
                            n.bindXRFramebuffer(null),
                            t.setRenderTarget(t.getRenderTarget()),
                            S.stop(),
                            (i.isPresenting = !1),
                            i.dispatchEvent({ type: "sessionend" });
                    }
                    function I(t) {
                        const e = s.inputSources;
                        for (let t = 0; t < p.length; t++) A.set(e[t], p[t]);
                        for (let e = 0; e < t.removed.length; e++) {
                            const i = t.removed[e],
                                n = A.get(i);
                            n && (n.dispatchEvent({ type: "disconnected", data: i }), A.delete(i));
                        }
                        for (let e = 0; e < t.added.length; e++) {
                            const i = t.added[e],
                                n = A.get(i);
                            n && n.dispatchEvent({ type: "connected", data: i });
                        }
                    }
                    (this.cameraAutoUpdate = !0),
                        (this.enabled = !1),
                        (this.isPresenting = !1),
                        (this.getController = function (t) {
                            let e = p[t];
                            return void 0 === e && ((e = new Lr()), (p[t] = e)), e.getTargetRaySpace();
                        }),
                        (this.getControllerGrip = function (t) {
                            let e = p[t];
                            return void 0 === e && ((e = new Lr()), (p[t] = e)), e.getGripSpace();
                        }),
                        (this.getHand = function (t) {
                            let e = p[t];
                            return void 0 === e && ((e = new Lr()), (p[t] = e)), e.getHandSpace();
                        }),
                        (this.setFramebufferScaleFactor = function (t) {
                            (r = t), i.isPresenting;
                        }),
                        (this.setReferenceSpaceType = function (t) {
                            (o = t), i.isPresenting;
                        }),
                        (this.getReferenceSpace = function () {
                            return a;
                        }),
                        (this.getSession = function () {
                            return s;
                        }),
                        (this.setSession = async function (t) {
                            if (((s = t), null !== s)) {
                                s.addEventListener("select", w), s.addEventListener("selectstart", w), s.addEventListener("selectend", w), s.addEventListener("squeeze", w), s.addEventListener("squeezestart", w), s.addEventListener("squeezeend", w), s.addEventListener("end", _), s.addEventListener("inputsourceschange", I);
                                const t = e.getContextAttributes();
                                if ((!0 !== t.xrCompatible && (await e.makeXRCompatible()), void 0 === s.renderState.layers)) {
                                    const i = { antialias: t.antialias, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: r };
                                    (d = new XRWebGLLayer(s, e, i)), s.updateRenderState({ baseLayer: d });
                                } else {
                                    let i = 0;
                                    if (t.antialias) {
                                        const i = { antialias: !0, alpha: t.alpha, depth: t.depth, stencil: t.stencil, framebufferScaleFactor: r };
                                        (d = new XRWebGLLayer(s, e, i)), s.updateRenderState({ layers: [d] });
                                    } else {
                                        t.depth && (i = t.stencil ? 34041 : 6402);
                                        const n = { colorFormat: t.alpha ? 6408 : 6407, depthFormat: i, scaleFactor: r };
                                        (c = new XRWebGLBinding(s, e)), (u = c.createProjectionLayer(n)), (h = e.createFramebuffer()), s.updateRenderState({ layers: [u] });
                                    }
                                }
                                (a = await s.requestReferenceSpace(o)), S.setContext(s), S.start(), (i.isPresenting = !0), i.dispatchEvent({ type: "sessionstart" });
                            }
                        });
                    const C = new bt(),
                        M = new bt();
                    function E(t, e) {
                        null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                    }
                    (this.updateCamera = function (t) {
                        if (null === s) return;
                        (v.near = m.near = g.near = t.near), (v.far = m.far = g.far = t.far), (y === v.near && x === v.far) || (s.updateRenderState({ depthNear: v.near, depthFar: v.far }), (y = v.near), (x = v.far));
                        const e = t.parent,
                            i = v.cameras;
                        E(v, e);
                        for (let t = 0; t < i.length; t++) E(i[t], e);
                        v.matrixWorld.decompose(v.position, v.quaternion, v.scale), t.position.copy(v.position), t.quaternion.copy(v.quaternion), t.scale.copy(v.scale), t.matrix.copy(v.matrix), t.matrixWorld.copy(v.matrixWorld);
                        const n = t.children;
                        for (let t = 0, e = n.length; t < e; t++) n[t].updateMatrixWorld(!0);
                        2 === i.length
                            ? (function (t, e, i) {
                                  C.setFromMatrixPosition(e.matrixWorld), M.setFromMatrixPosition(i.matrixWorld);
                                  const n = C.distanceTo(M),
                                      s = e.projectionMatrix.elements,
                                      r = i.projectionMatrix.elements,
                                      a = s[14] / (s[10] - 1),
                                      o = s[14] / (s[10] + 1),
                                      l = (s[9] + 1) / s[5],
                                      c = (s[9] - 1) / s[5],
                                      h = (s[8] - 1) / s[0],
                                      u = (r[8] + 1) / r[0],
                                      d = a * h,
                                      p = a * u,
                                      A = n / (-h + u),
                                      g = A * -h;
                                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(g), t.translateZ(A), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                                  const m = a + A,
                                      f = o + A,
                                      v = d - g,
                                      y = p + (n - g),
                                      x = ((l * o) / f) * m,
                                      w = ((c * o) / f) * m;
                                  t.projectionMatrix.makePerspective(v, y, x, w, m, f);
                              })(v, g, m)
                            : v.projectionMatrix.copy(g.projectionMatrix);
                    }),
                        (this.getCamera = function () {
                            return v;
                        }),
                        (this.getFoveation = function () {
                            return null !== u ? u.fixedFoveation : null !== d ? d.fixedFoveation : void 0;
                        }),
                        (this.setFoveation = function (t) {
                            null !== u && (u.fixedFoveation = t), null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = t);
                        });
                    let b = null;
                    const S = new Yi();
                    S.setAnimationLoop(function (t, i) {
                        if (((l = i.getViewerPose(a)), null !== l)) {
                            const t = l.views;
                            null !== d && n.bindXRFramebuffer(d.framebuffer);
                            let i = !1;
                            t.length !== v.cameras.length && ((v.cameras.length = 0), (i = !0));
                            for (let s = 0; s < t.length; s++) {
                                const r = t[s];
                                let a = null;
                                if (null !== d) a = d.getViewport(r);
                                else {
                                    const t = c.getViewSubImage(u, r);
                                    n.bindXRFramebuffer(h), void 0 !== t.depthStencilTexture && e.framebufferTexture2D(36160, 36096, 3553, t.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, t.colorTexture, 0), (a = t.viewport);
                                }
                                const o = f[s];
                                o.matrix.fromArray(r.transform.matrix), o.projectionMatrix.fromArray(r.projectionMatrix), o.viewport.set(a.x, a.y, a.width, a.height), 0 === s && v.matrix.copy(o.matrix), !0 === i && v.cameras.push(o);
                            }
                        }
                        const r = s.inputSources;
                        for (let t = 0; t < p.length; t++) {
                            const e = p[t],
                                n = r[t];
                            e.update(n, i, a);
                        }
                        b && b(t, i);
                    }),
                        (this.setAnimationLoop = function (t) {
                            b = t;
                        }),
                        (this.dispose = function () {});
                }
            }
            function Qr(t) {
                function e(e, i) {
                    (e.opacity.value = i.opacity), i.color && e.diffuse.value.copy(i.color), i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (e.map.value = i.map), i.alphaMap && (e.alphaMap.value = i.alphaMap), i.specularMap && (e.specularMap.value = i.specularMap);
                    const n = t.get(i).envMap;
                    if (n) {
                        (e.envMap.value = n), (e.flipEnvMap.value = n.isCubeTexture && !1 === n.isRenderTargetTexture ? -1 : 1), (e.reflectivity.value = i.reflectivity), (e.refractionRatio.value = i.refractionRatio);
                        const s = t.get(n).__maxMipLevel;
                        void 0 !== s && (e.maxMipLevel.value = s);
                    }
                    let s, r;
                    i.lightMap && ((e.lightMap.value = i.lightMap), (e.lightMapIntensity.value = i.lightMapIntensity)), i.aoMap && ((e.aoMap.value = i.aoMap), (e.aoMapIntensity.value = i.aoMapIntensity)), i.map ? (s = i.map) : i.specularMap ? (s = i.specularMap) : i.displacementMap ? (s = i.displacementMap) : i.normalMap ? (s = i.normalMap) : i.bumpMap ? (s = i.bumpMap) : i.roughnessMap ? (s = i.roughnessMap) : i.metalnessMap ? (s = i.metalnessMap) : i.alphaMap ? (s = i.alphaMap) : i.emissiveMap ? (s = i.emissiveMap) : i.clearcoatMap ? (s = i.clearcoatMap) : i.clearcoatNormalMap ? (s = i.clearcoatNormalMap) : i.clearcoatRoughnessMap ? (s = i.clearcoatRoughnessMap) : i.specularIntensityMap ? (s = i.specularIntensityMap) : i.specularTintMap && (s = i.specularTintMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uvTransform.value.copy(s.matrix)), i.aoMap ? (r = i.aoMap) : i.lightMap && (r = i.lightMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uv2Transform.value.copy(r.matrix));
                }
                function i(e, i) {
                    (e.roughness.value = i.roughness), (e.metalness.value = i.metalness), i.roughnessMap && (e.roughnessMap.value = i.roughnessMap), i.metalnessMap && (e.metalnessMap.value = i.metalnessMap), i.emissiveMap && (e.emissiveMap.value = i.emissiveMap), i.bumpMap && ((e.bumpMap.value = i.bumpMap), (e.bumpScale.value = i.bumpScale), 1 === i.side && (e.bumpScale.value *= -1)), i.normalMap && ((e.normalMap.value = i.normalMap), e.normalScale.value.copy(i.normalScale), 1 === i.side && e.normalScale.value.negate()), i.displacementMap && ((e.displacementMap.value = i.displacementMap), (e.displacementScale.value = i.displacementScale), (e.displacementBias.value = i.displacementBias)), t.get(i).envMap && (e.envMapIntensity.value = i.envMapIntensity);
                }
                return {
                    refreshFogUniforms: function (t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far)) : e.isFogExp2 && (t.fogDensity.value = e.density);
                    },
                    refreshMaterialUniforms: function (t, n, s, r, a) {
                        n.isMeshBasicMaterial
                            ? e(t, n)
                            : n.isMeshLambertMaterial
                              ? (e(t, n),
                                (function (t, e) {
                                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                                })(t, n))
                              : n.isMeshToonMaterial
                                ? (e(t, n),
                                  (function (t, e) {
                                      e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
                                  })(t, n))
                                : n.isMeshPhongMaterial
                                  ? (e(t, n),
                                    (function (t, e) {
                                        t.specular.value.copy(e.specular), (t.shininess.value = Math.max(e.shininess, 1e-4)), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
                                    })(t, n))
                                  : n.isMeshStandardMaterial
                                    ? (e(t, n),
                                      n.isMeshPhysicalMaterial
                                          ? (function (t, e, n) {
                                                i(t, e), (t.reflectivity.value = e.reflectivity), (t.clearcoat.value = e.clearcoat), (t.clearcoatRoughness.value = e.clearcoatRoughness), e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), (t.clearcoatNormalMap.value = e.clearcoatNormalMap), 1 === e.side && t.clearcoatNormalScale.value.negate()), (t.transmission.value = e.transmission), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), e.transmission > 0 && ((t.transmissionSamplerMap.value = n.texture), t.transmissionSamplerSize.value.set(n.width, n.height)), (t.thickness.value = e.thickness), e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), (t.attenuationDistance.value = e.attenuationDistance), t.attenuationTint.value.copy(e.attenuationTint), (t.specularIntensity.value = e.specularIntensity), t.specularTint.value.copy(e.specularTint), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap), e.specularTintMap && (t.specularTintMap.value = e.specularTintMap);
                                            })(t, n, a)
                                          : i(t, n))
                                    : n.isMeshMatcapMaterial
                                      ? (e(t, n),
                                        (function (t, e) {
                                            e.matcap && (t.matcap.value = e.matcap), e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
                                        })(t, n))
                                      : n.isMeshDepthMaterial
                                        ? (e(t, n),
                                          (function (t, e) {
                                              e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
                                          })(t, n))
                                        : n.isMeshDistanceMaterial
                                          ? (e(t, n),
                                            (function (t, e) {
                                                e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias)), t.referencePosition.value.copy(e.referencePosition), (t.nearDistance.value = e.nearDistance), (t.farDistance.value = e.farDistance);
                                            })(t, n))
                                          : n.isMeshNormalMaterial
                                            ? (e(t, n),
                                              (function (t, e) {
                                                  e.bumpMap && ((t.bumpMap.value = e.bumpMap), (t.bumpScale.value = e.bumpScale), 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && ((t.normalMap.value = e.normalMap), t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && ((t.displacementMap.value = e.displacementMap), (t.displacementScale.value = e.displacementScale), (t.displacementBias.value = e.displacementBias));
                                              })(t, n))
                                            : n.isLineBasicMaterial
                                              ? ((function (t, e) {
                                                    t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity);
                                                })(t, n),
                                                n.isLineDashedMaterial &&
                                                    (function (t, e) {
                                                        (t.dashSize.value = e.dashSize), (t.totalSize.value = e.dashSize + e.gapSize), (t.scale.value = e.scale);
                                                    })(t, n))
                                              : n.isPointsMaterial
                                                ? (function (t, e, i, n) {
                                                      let s;
                                                      t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity), (t.size.value = e.size * i), (t.scale.value = 0.5 * n), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? (s = e.map) : e.alphaMap && (s = e.alphaMap), void 0 !== s && (!0 === s.matrixAutoUpdate && s.updateMatrix(), t.uvTransform.value.copy(s.matrix));
                                                  })(t, n, s, r)
                                                : n.isSpriteMaterial
                                                  ? (function (t, e) {
                                                        let i;
                                                        t.diffuse.value.copy(e.color), (t.opacity.value = e.opacity), (t.rotation.value = e.rotation), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? (i = e.map) : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix));
                                                    })(t, n)
                                                  : n.isShadowMaterial
                                                    ? (t.color.value.copy(n.color), (t.opacity.value = n.opacity))
                                                    : n.isShaderMaterial && (n.uniformsNeedUpdate = !1);
                    },
                };
            }
            function Rr(t = {}) {
                const e =
                        void 0 !== t.canvas
                            ? t.canvas
                            : (function () {
                                  const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                                  return (t.style.display = "block"), t;
                              })(),
                    i = void 0 !== t.context ? t.context : null,
                    n = void 0 !== t.alpha && t.alpha,
                    s = void 0 === t.depth || t.depth,
                    r = void 0 === t.stencil || t.stencil,
                    a = void 0 !== t.antialias && t.antialias,
                    o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let u = null,
                    d = null;
                const p = [],
                    A = [];
                (this.domElement = e), (this.debug = { checkShaderErrors: !0 }), (this.autoClear = !0), (this.autoClearColor = !0), (this.autoClearDepth = !0), (this.autoClearStencil = !0), (this.sortObjects = !0), (this.clippingPlanes = []), (this.localClippingEnabled = !1), (this.gammaFactor = 2), (this.outputEncoding = 3e3), (this.physicallyCorrectLights = !1), (this.toneMapping = 0), (this.toneMappingExposure = 1);
                const g = this;
                let m = !1,
                    f = 0,
                    v = 0,
                    y = null,
                    x = -1,
                    w = null;
                const _ = new It(),
                    I = new It();
                let C = null,
                    M = e.width,
                    E = e.height,
                    b = 1,
                    S = null,
                    B = null;
                const T = new It(0, 0, M, E),
                    L = new It(0, 0, M, E);
                let D = !1;
                const Q = [],
                    R = new ji();
                let P = !1,
                    N = !1,
                    F = null;
                const U = new se(),
                    k = new bt(),
                    O = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
                function G() {
                    return null === y ? b : 1;
                }
                let z,
                    V,
                    H,
                    W,
                    q,
                    j,
                    Y,
                    J,
                    X,
                    K,
                    Z,
                    $,
                    tt,
                    et,
                    it,
                    nt,
                    st,
                    rt,
                    at,
                    ot,
                    lt,
                    ct,
                    ht,
                    ut = i;
                function dt(t, i) {
                    for (let n = 0; n < t.length; n++) {
                        const s = t[n],
                            r = e.getContext(s, i);
                        if (null !== r) return r;
                    }
                    return null;
                }
                try {
                    const t = { alpha: n, depth: s, stencil: r, antialias: a, premultipliedAlpha: o, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: h };
                    if ((e.addEventListener("webglcontextlost", gt, !1), e.addEventListener("webglcontextrestored", mt, !1), null === ut)) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if ((!0 === g.isWebGL1Renderer && e.shift(), (ut = dt(e, t)), null === ut)) throw dt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    }
                    void 0 === ut.getShaderPrecisionFormat &&
                        (ut.getShaderPrecisionFormat = function () {
                            return { rangeMin: 1, rangeMax: 1, precision: 1 };
                        });
                } catch (t) {
                    throw t;
                }
                function pt() {
                    (z = new Dn(ut)), (V = new sn(ut, z, t)), z.init(V), (ct = new br(ut, z, V)), (H = new Mr(ut, z, V)), (Q[0] = 1029), (W = new Pn(ut)), (q = new ur()), (j = new Er(ut, z, H, q, V, ct, W)), (Y = new an(g)), (J = new Ln(g)), (X = new Ji(ut, V)), (ht = new en(ut, z, X, V)), (K = new Qn(ut, X, W, ht)), (Z = new kn(ut, K, X, W)), (at = new Un(ut)), (nt = new rn(q)), ($ = new hr(g, Y, J, z, V, ht, nt)), (tt = new Qr(q)), (et = new gr(q)), (it = new wr(z, V)), (rt = new tn(g, Y, H, Z, o)), (st = new Cr(g, Z, V)), (ot = new nn(ut, z, W, V)), (lt = new Rn(ut, z, W, V)), (W.programs = $.programs), (g.capabilities = V), (g.extensions = z), (g.properties = q), (g.renderLists = et), (g.shadowMap = st), (g.state = H), (g.info = W);
                }
                pt();
                const At = new Dr(g, ut);
                function gt(t) {
                    t.preventDefault(), (m = !0);
                }
                function mt() {
                    m = !1;
                    const t = W.autoReset,
                        e = st.enabled,
                        i = st.autoUpdate,
                        n = st.needsUpdate,
                        s = st.type;
                    pt(), (W.autoReset = t), (st.enabled = e), (st.autoUpdate = i), (st.needsUpdate = n), (st.type = s);
                }
                function ft(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", ft),
                        (function (t) {
                            (function (t) {
                                const e = q.get(t).programs;
                                void 0 !== e &&
                                    e.forEach(function (t) {
                                        $.releaseProgram(t);
                                    });
                            })(t),
                                q.remove(t);
                        })(e);
                }
                (this.xr = At),
                    (this.getContext = function () {
                        return ut;
                    }),
                    (this.getContextAttributes = function () {
                        return ut.getContextAttributes();
                    }),
                    (this.forceContextLoss = function () {
                        const t = z.get("WEBGL_lose_context");
                        t && t.loseContext();
                    }),
                    (this.forceContextRestore = function () {
                        const t = z.get("WEBGL_lose_context");
                        t && t.restoreContext();
                    }),
                    (this.getPixelRatio = function () {
                        return b;
                    }),
                    (this.setPixelRatio = function (t) {
                        void 0 !== t && ((b = t), this.setSize(M, E, !1));
                    }),
                    (this.getSize = function (t) {
                        return t.set(M, E);
                    }),
                    (this.setSize = function (t, i, n) {
                        At.isPresenting || ((M = t), (E = i), (e.width = Math.floor(t * b)), (e.height = Math.floor(i * b)), !1 !== n && ((e.style.width = t + "px"), (e.style.height = i + "px")), this.setViewport(0, 0, t, i));
                    }),
                    (this.getDrawingBufferSize = function (t) {
                        return t.set(M * b, E * b).floor();
                    }),
                    (this.setDrawingBufferSize = function (t, i, n) {
                        (M = t), (E = i), (b = n), (e.width = Math.floor(t * n)), (e.height = Math.floor(i * n)), this.setViewport(0, 0, t, i);
                    }),
                    (this.getCurrentViewport = function (t) {
                        return t.copy(_);
                    }),
                    (this.getViewport = function (t) {
                        return t.copy(T);
                    }),
                    (this.setViewport = function (t, e, i, n) {
                        t.isVector4 ? T.set(t.x, t.y, t.z, t.w) : T.set(t, e, i, n), H.viewport(_.copy(T).multiplyScalar(b).floor());
                    }),
                    (this.getScissor = function (t) {
                        return t.copy(L);
                    }),
                    (this.setScissor = function (t, e, i, n) {
                        t.isVector4 ? L.set(t.x, t.y, t.z, t.w) : L.set(t, e, i, n), H.scissor(I.copy(L).multiplyScalar(b).floor());
                    }),
                    (this.getScissorTest = function () {
                        return D;
                    }),
                    (this.setScissorTest = function (t) {
                        H.setScissorTest((D = t));
                    }),
                    (this.setOpaqueSort = function (t) {
                        S = t;
                    }),
                    (this.setTransparentSort = function (t) {
                        B = t;
                    }),
                    (this.getClearColor = function (t) {
                        return t.copy(rt.getClearColor());
                    }),
                    (this.setClearColor = function () {
                        rt.setClearColor.apply(rt, arguments);
                    }),
                    (this.getClearAlpha = function () {
                        return rt.getClearAlpha();
                    }),
                    (this.setClearAlpha = function () {
                        rt.setClearAlpha.apply(rt, arguments);
                    }),
                    (this.clear = function (t, e, i) {
                        let n = 0;
                        (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), ut.clear(n);
                    }),
                    (this.clearColor = function () {
                        this.clear(!0, !1, !1);
                    }),
                    (this.clearDepth = function () {
                        this.clear(!1, !0, !1);
                    }),
                    (this.clearStencil = function () {
                        this.clear(!1, !1, !0);
                    }),
                    (this.dispose = function () {
                        e.removeEventListener("webglcontextlost", gt, !1), e.removeEventListener("webglcontextrestored", mt, !1), et.dispose(), it.dispose(), q.dispose(), Y.dispose(), J.dispose(), Z.dispose(), ht.dispose(), At.dispose(), At.removeEventListener("sessionstart", yt), At.removeEventListener("sessionend", xt), F && (F.dispose(), (F = null)), wt.stop();
                    }),
                    (this.renderBufferImmediate = function (t, e) {
                        ht.initAttributes();
                        const i = q.get(t);
                        t.hasPositions && !i.position && (i.position = ut.createBuffer()), t.hasNormals && !i.normal && (i.normal = ut.createBuffer()), t.hasUvs && !i.uv && (i.uv = ut.createBuffer()), t.hasColors && !i.color && (i.color = ut.createBuffer());
                        const n = e.getAttributes();
                        t.hasPositions && (ut.bindBuffer(34962, i.position), ut.bufferData(34962, t.positionArray, 35048), ht.enableAttribute(n.position), ut.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ut.bindBuffer(34962, i.normal), ut.bufferData(34962, t.normalArray, 35048), ht.enableAttribute(n.normal), ut.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ut.bindBuffer(34962, i.uv), ut.bufferData(34962, t.uvArray, 35048), ht.enableAttribute(n.uv), ut.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ut.bindBuffer(34962, i.color), ut.bufferData(34962, t.colorArray, 35048), ht.enableAttribute(n.color), ut.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), ht.disableUnusedAttributes(), ut.drawArrays(4, 0, t.count), (t.count = 0);
                    }),
                    (this.renderBufferDirect = function (t, e, i, n, s, r) {
                        null === e && (e = O);
                        const a = s.isMesh && s.matrixWorld.determinant() < 0,
                            o = Lt(t, e, n, s);
                        H.setMaterial(n, a);
                        let l = i.index;
                        const c = i.attributes.position;
                        if (null === l) {
                            if (void 0 === c || 0 === c.count) return;
                        } else if (0 === l.count) return;
                        let h,
                            u = 1;
                        !0 === n.wireframe && ((l = K.getWireframeAttribute(i)), (u = 2)), (void 0 === i.morphAttributes.position && void 0 === i.morphAttributes.normal) || at.update(s, i, n, o), ht.setup(s, n, o, i, l);
                        let d = ot;
                        null !== l && ((h = X.get(l)), (d = lt), d.setIndex(h));
                        const p = null !== l ? l.count : c.count,
                            A = i.drawRange.start * u,
                            g = i.drawRange.count * u,
                            m = null !== r ? r.start * u : 0,
                            f = null !== r ? r.count * u : 1 / 0,
                            v = Math.max(A, m),
                            y = Math.min(p, A + g, m + f) - 1,
                            x = Math.max(0, y - v + 1);
                        if (0 !== x) {
                            if (s.isMesh) !0 === n.wireframe ? (H.setLineWidth(n.wireframeLinewidth * G()), d.setMode(1)) : d.setMode(4);
                            else if (s.isLine) {
                                let t = n.linewidth;
                                void 0 === t && (t = 1), H.setLineWidth(t * G()), s.isLineSegments ? d.setMode(1) : s.isLineLoop ? d.setMode(2) : d.setMode(3);
                            } else s.isPoints ? d.setMode(0) : s.isSprite && d.setMode(4);
                            if (s.isInstancedMesh) d.renderInstances(v, x, s.count);
                            else if (i.isInstancedBufferGeometry) {
                                const t = Math.min(i.instanceCount, i._maxInstanceCount);
                                d.renderInstances(v, x, t);
                            } else d.render(v, x);
                        }
                    }),
                    (this.compile = function (t, e) {
                        (d = it.get(t)),
                            d.init(),
                            A.push(d),
                            t.traverseVisible(function (t) {
                                t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t));
                            }),
                            d.setupLights(),
                            t.traverse(function (e) {
                                const i = e.material;
                                if (i)
                                    if (Array.isArray(i)) for (let n = 0; n < i.length; n++) Bt(i[n], t, e);
                                    else Bt(i, t, e);
                            }),
                            A.pop(),
                            (d = null);
                    });
                let vt = null;
                function yt() {
                    wt.stop();
                }
                function xt() {
                    wt.start();
                }
                const wt = new Yi();
                function _t(t, e, i, n) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) i = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || R.intersectsSprite(t)) {
                                n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                                const e = Z.update(t),
                                    s = t.material;
                                s.visible && u.push(t, e, s, i, k.z, null);
                            }
                        } else if (t.isImmediateRenderObject) n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U), u.push(t, null, t.material, i, k.z, null);
                        else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== W.render.frame && (t.skeleton.update(), (t.skeleton.frame = W.render.frame)), !t.frustumCulled || R.intersectsObject(t))) {
                            n && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(U);
                            const e = Z.update(t),
                                s = t.material;
                            if (Array.isArray(s)) {
                                const n = e.groups;
                                for (let r = 0, a = n.length; r < a; r++) {
                                    const a = n[r],
                                        o = s[a.materialIndex];
                                    o && o.visible && u.push(t, e, o, i, k.z, a);
                                }
                            } else s.visible && u.push(t, e, s, i, k.z, null);
                        }
                    const s = t.children;
                    for (let t = 0, r = s.length; t < r; t++) _t(s[t], e, i, n);
                }
                function Et(t, e, i) {
                    const n = !0 === e.isScene ? e.overrideMaterial : null;
                    if (i.isArrayCamera) {
                        const s = i.cameras;
                        for (let i = 0, r = s.length; i < r; i++) {
                            const r = s[i];
                            H.viewport(_.copy(r.viewport)), d.setupLightsView(r);
                            for (let i = 0, s = t.length; i < s; i++) {
                                const s = t[i],
                                    a = s.object,
                                    o = s.geometry,
                                    l = null === n ? s.material : n,
                                    c = s.group;
                                a.layers.test(r.layers) && St(a, e, r, o, l, c);
                            }
                        }
                    } else
                        for (let s = 0, r = t.length; s < r; s++) {
                            const r = t[s];
                            St(r.object, e, i, r.geometry, null === n ? r.material : n, r.group);
                        }
                }
                function St(t, e, i, n, s, r) {
                    if ((t.onBeforeRender(g, e, i, n, s, r), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject)) {
                        const n = Lt(i, e, s, t);
                        H.setMaterial(s),
                            ht.reset(),
                            (function (t, e) {
                                t.render(function (t) {
                                    g.renderBufferImmediate(t, e);
                                });
                            })(t, n);
                    } else !0 === s.transparent && 2 === s.side ? ((s.side = 1), (s.needsUpdate = !0), g.renderBufferDirect(i, e, n, s, t, r), (s.side = 0), (s.needsUpdate = !0), g.renderBufferDirect(i, e, n, s, t, r), (s.side = 2)) : g.renderBufferDirect(i, e, n, s, t, r);
                    t.onAfterRender(g, e, i, n, s, r);
                }
                function Bt(t, e, i) {
                    !0 !== e.isScene && (e = O);
                    const n = q.get(t),
                        s = d.state.lights,
                        r = d.state.shadowsArray,
                        a = s.state.version,
                        o = $.getParameters(t, s.state, r, e, i),
                        l = $.getProgramCacheKey(o);
                    let c = n.programs;
                    (n.environment = t.isMeshStandardMaterial ? e.environment : null), (n.fog = e.fog), (n.envMap = (t.isMeshStandardMaterial ? J : Y).get(t.envMap || n.environment)), void 0 === c && (t.addEventListener("dispose", ft), (c = new Map()), (n.programs = c));
                    let h = c.get(l);
                    if (void 0 !== h) {
                        if (n.currentProgram === h && n.lightsStateVersion === a) return Tt(t, o), h;
                    } else (o.uniforms = $.getUniforms(t)), t.onBuild(o, g), t.onBeforeCompile(o, g), (h = $.acquireProgram(o, l)), c.set(l, h), (n.uniforms = o.uniforms);
                    const u = n.uniforms;
                    ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) || (u.clippingPlanes = nt.uniform),
                        Tt(t, o),
                        (n.needsLights = (function (t) {
                            return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || (t.isShaderMaterial && !0 === t.lights);
                        })(t)),
                        (n.lightsStateVersion = a),
                        n.needsLights && ((u.ambientLightColor.value = s.state.ambient), (u.lightProbe.value = s.state.probe), (u.directionalLights.value = s.state.directional), (u.directionalLightShadows.value = s.state.directionalShadow), (u.spotLights.value = s.state.spot), (u.spotLightShadows.value = s.state.spotShadow), (u.rectAreaLights.value = s.state.rectArea), (u.ltc_1.value = s.state.rectAreaLTC1), (u.ltc_2.value = s.state.rectAreaLTC2), (u.pointLights.value = s.state.point), (u.pointLightShadows.value = s.state.pointShadow), (u.hemisphereLights.value = s.state.hemi), (u.directionalShadowMap.value = s.state.directionalShadowMap), (u.directionalShadowMatrix.value = s.state.directionalShadowMatrix), (u.spotShadowMap.value = s.state.spotShadowMap), (u.spotShadowMatrix.value = s.state.spotShadowMatrix), (u.pointShadowMap.value = s.state.pointShadowMap), (u.pointShadowMatrix.value = s.state.pointShadowMatrix));
                    const p = h.getUniforms(),
                        A = Vs.seqWithValue(p.seq, u);
                    return (n.currentProgram = h), (n.uniformsList = A), h;
                }
                function Tt(t, e) {
                    const i = q.get(t);
                    (i.outputEncoding = e.outputEncoding), (i.instancing = e.instancing), (i.skinning = e.skinning), (i.morphTargets = e.morphTargets), (i.morphNormals = e.morphNormals), (i.numClippingPlanes = e.numClippingPlanes), (i.numIntersection = e.numClipIntersection), (i.vertexAlphas = e.vertexAlphas), (i.vertexTangents = e.vertexTangents);
                }
                function Lt(t, e, i, n) {
                    !0 !== e.isScene && (e = O), j.resetTextureUnits();
                    const s = e.fog,
                        r = i.isMeshStandardMaterial ? e.environment : null,
                        a = null === y ? g.outputEncoding : y.texture.encoding,
                        o = (i.isMeshStandardMaterial ? J : Y).get(i.envMap || r),
                        l = !0 === i.vertexColors && !!n.geometry && !!n.geometry.attributes.color && 4 === n.geometry.attributes.color.itemSize,
                        c = !!n.geometry && !!n.geometry.attributes.tangent,
                        h = !!n.geometry && !!n.geometry.morphAttributes.position,
                        u = !!n.geometry && !!n.geometry.morphAttributes.normal,
                        p = q.get(i),
                        A = d.state.lights;
                    if (!0 === P && (!0 === N || t !== w)) {
                        const e = t === w && i.id === x;
                        nt.setState(i, t, e);
                    }
                    let m = !1;
                    i.version === p.__version ? ((p.needsLights && p.lightsStateVersion !== A.state.version) || p.outputEncoding !== a || (n.isInstancedMesh && !1 === p.instancing) ? (m = !0) : n.isInstancedMesh || !0 !== p.instancing ? (n.isSkinnedMesh && !1 === p.skinning ? (m = !0) : n.isSkinnedMesh || !0 !== p.skinning ? (p.envMap !== o || (i.fog && p.fog !== s) ? (m = !0) : void 0 === p.numClippingPlanes || (p.numClippingPlanes === nt.numPlanes && p.numIntersection === nt.numIntersection) ? (p.vertexAlphas !== l || p.vertexTangents !== c || p.morphTargets !== h || p.morphNormals !== u) && (m = !0) : (m = !0)) : (m = !0)) : (m = !0)) : ((m = !0), (p.__version = i.version));
                    let f = p.currentProgram;
                    !0 === m && (f = Bt(i, e, n));
                    let v = !1,
                        _ = !1,
                        I = !1;
                    const C = f.getUniforms(),
                        M = p.uniforms;
                    if ((H.useProgram(f.program) && ((v = !0), (_ = !0), (I = !0)), i.id !== x && ((x = i.id), (_ = !0)), v || w !== t)) {
                        if ((C.setValue(ut, "projectionMatrix", t.projectionMatrix), V.logarithmicDepthBuffer && C.setValue(ut, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), w !== t && ((w = t), (_ = !0), (I = !0)), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap)) {
                            const e = C.map.cameraPosition;
                            void 0 !== e && e.setValue(ut, k.setFromMatrixPosition(t.matrixWorld));
                        }
                        (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && C.setValue(ut, "isOrthographic", !0 === t.isOrthographicCamera), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || n.isSkinnedMesh) && C.setValue(ut, "viewMatrix", t.matrixWorldInverse);
                    }
                    if (n.isSkinnedMesh) {
                        C.setOptional(ut, n, "bindMatrix"), C.setOptional(ut, n, "bindMatrixInverse");
                        const t = n.skeleton;
                        t && (V.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), C.setValue(ut, "boneTexture", t.boneTexture, j), C.setValue(ut, "boneTextureSize", t.boneTextureSize)) : C.setOptional(ut, t, "boneMatrices"));
                    }
                    var S, B;
                    return (_ || p.receiveShadow !== n.receiveShadow) && ((p.receiveShadow = n.receiveShadow), C.setValue(ut, "receiveShadow", n.receiveShadow)), _ && (C.setValue(ut, "toneMappingExposure", g.toneMappingExposure), p.needsLights && ((B = I), ((S = M).ambientLightColor.needsUpdate = B), (S.lightProbe.needsUpdate = B), (S.directionalLights.needsUpdate = B), (S.directionalLightShadows.needsUpdate = B), (S.pointLights.needsUpdate = B), (S.pointLightShadows.needsUpdate = B), (S.spotLights.needsUpdate = B), (S.spotLightShadows.needsUpdate = B), (S.rectAreaLights.needsUpdate = B), (S.hemisphereLights.needsUpdate = B)), s && i.fog && tt.refreshFogUniforms(M, s), tt.refreshMaterialUniforms(M, i, b, E, F), Vs.upload(ut, p.uniformsList, M, j)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Vs.upload(ut, p.uniformsList, M, j), (i.uniformsNeedUpdate = !1)), i.isSpriteMaterial && C.setValue(ut, "center", n.center), C.setValue(ut, "modelViewMatrix", n.modelViewMatrix), C.setValue(ut, "normalMatrix", n.normalMatrix), C.setValue(ut, "modelMatrix", n.matrixWorld), f;
                }
                wt.setAnimationLoop(function (t) {
                    vt && vt(t);
                }),
                    "undefined" != typeof window && wt.setContext(window),
                    (this.setAnimationLoop = function (t) {
                        (vt = t), At.setAnimationLoop(t), null === t ? wt.stop() : wt.start();
                    }),
                    At.addEventListener("sessionstart", yt),
                    At.addEventListener("sessionend", xt),
                    (this.render = function (t, e) {
                        if (void 0 !== e && !0 !== e.isCamera) return;
                        if (!0 === m) return;
                        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === At.enabled && !0 === At.isPresenting && (!0 === At.cameraAutoUpdate && At.updateCamera(e), (e = At.getCamera())), !0 === t.isScene && t.onBeforeRender(g, t, e, y), (d = it.get(t, A.length)), d.init(), A.push(d), U.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), R.setFromProjectionMatrix(U), (N = this.localClippingEnabled), (P = nt.init(this.clippingPlanes, N, e)), (u = et.get(t, p.length)), u.init(), p.push(u), _t(t, e, 0, g.sortObjects), u.finish(), !0 === g.sortObjects && u.sort(S, B), !0 === P && nt.beginShadows();
                        const i = d.state.shadowsArray;
                        st.render(i, t, e), d.setupLights(), d.setupLightsView(e), !0 === P && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), rt.render(u, t);
                        const n = u.opaque,
                            s = u.transmissive,
                            r = u.transparent;
                        n.length > 0 && Et(n, t, e),
                            s.length > 0 &&
                                (function (t, e, i, n) {
                                    if (null === F) {
                                        const t = !0 === a && !0 === V.isWebGL2;
                                        F = new (t ? Mt : Ct)(1024, 1024, { generateMipmaps: !0, type: null !== ct.convert(1016) ? 1016 : 1009, minFilter: 1008, magFilter: 1003, wrapS: 1001, wrapT: 1001 });
                                    }
                                    const s = g.getRenderTarget();
                                    g.setRenderTarget(F), g.clear();
                                    const r = g.toneMapping;
                                    (g.toneMapping = 0), Et(t, i, n), (g.toneMapping = r), j.updateMultisampleRenderTarget(F), j.updateRenderTargetMipmap(F), g.setRenderTarget(s), Et(e, i, n);
                                })(n, s, t, e),
                            r.length > 0 && Et(r, t, e),
                            null !== y && (j.updateMultisampleRenderTarget(y), j.updateRenderTargetMipmap(y)),
                            !0 === t.isScene && t.onAfterRender(g, t, e),
                            H.buffers.depth.setTest(!0),
                            H.buffers.depth.setMask(!0),
                            H.buffers.color.setMask(!0),
                            H.setPolygonOffset(!1),
                            ht.resetDefaultState(),
                            (x = -1),
                            (w = null),
                            A.pop(),
                            (d = A.length > 0 ? A[A.length - 1] : null),
                            p.pop(),
                            (u = p.length > 0 ? p[p.length - 1] : null);
                    }),
                    (this.getActiveCubeFace = function () {
                        return f;
                    }),
                    (this.getActiveMipmapLevel = function () {
                        return v;
                    }),
                    (this.getRenderTarget = function () {
                        return y;
                    }),
                    (this.setRenderTarget = function (t, e = 0, i = 0) {
                        (y = t), (f = e), (v = i), t && void 0 === q.get(t).__webglFramebuffer && j.setupRenderTarget(t);
                        let n = null,
                            s = !1,
                            r = !1;
                        if (t) {
                            const i = t.texture;
                            (i.isDataTexture3D || i.isDataTexture2DArray) && (r = !0);
                            const a = q.get(t).__webglFramebuffer;
                            t.isWebGLCubeRenderTarget ? ((n = a[e]), (s = !0)) : (n = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : a), _.copy(t.viewport), I.copy(t.scissor), (C = t.scissorTest);
                        } else _.copy(T).multiplyScalar(b).floor(), I.copy(L).multiplyScalar(b).floor(), (C = D);
                        if (H.bindFramebuffer(36160, n) && V.drawBuffers) {
                            let e = !1;
                            if (t)
                                if (t.isWebGLMultipleRenderTargets) {
                                    const i = t.texture;
                                    if (Q.length !== i.length || 36064 !== Q[0]) {
                                        for (let t = 0, e = i.length; t < e; t++) Q[t] = 36064 + t;
                                        (Q.length = i.length), (e = !0);
                                    }
                                } else (1 === Q.length && 36064 === Q[0]) || ((Q[0] = 36064), (Q.length = 1), (e = !0));
                            else (1 === Q.length && 1029 === Q[0]) || ((Q[0] = 1029), (Q.length = 1), (e = !0));
                            e && (V.isWebGL2 ? ut.drawBuffers(Q) : z.get("WEBGL_draw_buffers").drawBuffersWEBGL(Q));
                        }
                        if ((H.viewport(_), H.scissor(I), H.setScissorTest(C), s)) {
                            const n = q.get(t.texture);
                            ut.framebufferTexture2D(36160, 36064, 34069 + e, n.__webglTexture, i);
                        } else if (r) {
                            const n = q.get(t.texture),
                                s = e || 0;
                            ut.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, s);
                        }
                    }),
                    (this.readRenderTargetPixels = function (t, e, i, n, s, r, a) {
                        if (!t || !t.isWebGLRenderTarget) return;
                        let o = q.get(t).__webglFramebuffer;
                        if ((t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
                            H.bindFramebuffer(36160, o);
                            try {
                                const a = t.texture,
                                    o = a.format,
                                    l = a.type;
                                if (1023 !== o && ct.convert(o) !== ut.getParameter(35739)) return;
                                const c = 1016 === l && (z.has("EXT_color_buffer_half_float") || (V.isWebGL2 && z.has("EXT_color_buffer_float")));
                                if (!(1009 === l || ct.convert(l) === ut.getParameter(35738) || (1015 === l && (V.isWebGL2 || z.has("OES_texture_float") || z.has("WEBGL_color_buffer_float"))) || c)) return;
                                36053 === ut.checkFramebufferStatus(36160) && e >= 0 && e <= t.width - n && i >= 0 && i <= t.height - s && ut.readPixels(e, i, n, s, ct.convert(o), ct.convert(l), r);
                            } finally {
                                const t = null !== y ? q.get(y).__webglFramebuffer : null;
                                H.bindFramebuffer(36160, t);
                            }
                        }
                    }),
                    (this.copyFramebufferToTexture = function (t, e, i = 0) {
                        const n = Math.pow(2, -i),
                            s = Math.floor(e.image.width * n),
                            r = Math.floor(e.image.height * n);
                        let a = ct.convert(e.format);
                        V.isWebGL2 && (6407 === a && (a = 32849), 6408 === a && (a = 32856)), j.setTexture2D(e, 0), ut.copyTexImage2D(3553, i, a, t.x, t.y, s, r, 0), H.unbindTexture();
                    }),
                    (this.copyTextureToTexture = function (t, e, i, n = 0) {
                        const s = e.image.width,
                            r = e.image.height,
                            a = ct.convert(i.format),
                            o = ct.convert(i.type);
                        j.setTexture2D(i, 0), ut.pixelStorei(37440, i.flipY), ut.pixelStorei(37441, i.premultiplyAlpha), ut.pixelStorei(3317, i.unpackAlignment), e.isDataTexture ? ut.texSubImage2D(3553, n, t.x, t.y, s, r, a, o, e.image.data) : e.isCompressedTexture ? ut.compressedTexSubImage2D(3553, n, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, a, e.mipmaps[0].data) : ut.texSubImage2D(3553, n, t.x, t.y, a, o, e.image), 0 === n && i.generateMipmaps && ut.generateMipmap(3553), H.unbindTexture();
                    }),
                    (this.copyTextureToTexture3D = function (t, e, i, n, s = 0) {
                        if (g.isWebGL1Renderer) return;
                        const r = t.max.x - t.min.x + 1,
                            a = t.max.y - t.min.y + 1,
                            o = t.max.z - t.min.z + 1,
                            l = ct.convert(n.format),
                            c = ct.convert(n.type);
                        let h;
                        if (n.isDataTexture3D) j.setTexture3D(n, 0), (h = 32879);
                        else {
                            if (!n.isDataTexture2DArray) return;
                            j.setTexture2DArray(n, 0), (h = 35866);
                        }
                        ut.pixelStorei(37440, n.flipY), ut.pixelStorei(37441, n.premultiplyAlpha), ut.pixelStorei(3317, n.unpackAlignment);
                        const u = ut.getParameter(3314),
                            d = ut.getParameter(32878),
                            p = ut.getParameter(3316),
                            A = ut.getParameter(3315),
                            m = ut.getParameter(32877),
                            f = i.isCompressedTexture ? i.mipmaps[0] : i.image;
                        ut.pixelStorei(3314, f.width), ut.pixelStorei(32878, f.height), ut.pixelStorei(3316, t.min.x), ut.pixelStorei(3315, t.min.y), ut.pixelStorei(32877, t.min.z), i.isDataTexture || i.isDataTexture3D ? ut.texSubImage3D(h, s, e.x, e.y, e.z, r, a, o, l, c, f.data) : i.isCompressedTexture ? ut.compressedTexSubImage3D(h, s, e.x, e.y, e.z, r, a, o, l, f.data) : ut.texSubImage3D(h, s, e.x, e.y, e.z, r, a, o, l, c, f), ut.pixelStorei(3314, u), ut.pixelStorei(32878, d), ut.pixelStorei(3316, p), ut.pixelStorei(3315, A), ut.pixelStorei(32877, m), 0 === s && n.generateMipmaps && ut.generateMipmap(h), H.unbindTexture();
                    }),
                    (this.initTexture = function (t) {
                        j.setTexture2D(t, 0), H.unbindTexture();
                    }),
                    (this.resetState = function () {
                        (f = 0), (v = 0), (y = null), H.reset(), ht.reset();
                    }),
                    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
            }
            (class extends Rr {}).prototype.isWebGL1Renderer = !0;
            class Pr extends Be {
                constructor() {
                    super(), (this.type = "Scene"), (this.background = null), (this.environment = null), (this.fog = null), (this.overrideMaterial = null), (this.autoUpdate = !0), "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
                }
                copy(t, e) {
                    return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), (this.autoUpdate = t.autoUpdate), (this.matrixAutoUpdate = t.matrixAutoUpdate), this;
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return null !== this.fog && (e.object.fog = this.fog.toJSON()), e;
                }
            }
            Pr.prototype.isScene = !0;
            class Nr {
                constructor(t, e) {
                    (this.array = t), (this.stride = e), (this.count = void 0 !== t ? t.length / e : 0), (this.usage = 35044), (this.updateRange = { offset: 0, count: -1 }), (this.version = 0), (this.uuid = lt());
                }
                onUploadCallback() {}
                set needsUpdate(t) {
                    !0 === t && this.version++;
                }
                setUsage(t) {
                    return (this.usage = t), this;
                }
                copy(t) {
                    return (this.array = new t.array.constructor(t.array)), (this.count = t.count), (this.stride = t.stride), (this.usage = t.usage), this;
                }
                copyAt(t, e, i) {
                    (t *= this.stride), (i *= e.stride);
                    for (let n = 0, s = this.stride; n < s; n++) this.array[t + n] = e.array[i + n];
                    return this;
                }
                set(t, e = 0) {
                    return this.array.set(t, e), this;
                }
                clone(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = lt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
                        i = new this.constructor(e, this.stride);
                    return i.setUsage(this.usage), i;
                }
                onUpload(t) {
                    return (this.onUploadCallback = t), this;
                }
                toJSON(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = lt()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
                }
            }
            Nr.prototype.isInterleavedBuffer = !0;
            const Fr = new bt();
            class Ur {
                constructor(t, e, i, n = !1) {
                    (this.name = ""), (this.data = t), (this.itemSize = e), (this.offset = i), (this.normalized = !0 === n);
                }
                get count() {
                    return this.data.count;
                }
                get array() {
                    return this.data.array;
                }
                set needsUpdate(t) {
                    this.data.needsUpdate = t;
                }
                applyMatrix4(t) {
                    for (let e = 0, i = this.data.count; e < i; e++) (Fr.x = this.getX(e)), (Fr.y = this.getY(e)), (Fr.z = this.getZ(e)), Fr.applyMatrix4(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z);
                    return this;
                }
                applyNormalMatrix(t) {
                    for (let e = 0, i = this.count; e < i; e++) (Fr.x = this.getX(e)), (Fr.y = this.getY(e)), (Fr.z = this.getZ(e)), Fr.applyNormalMatrix(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z);
                    return this;
                }
                transformDirection(t) {
                    for (let e = 0, i = this.count; e < i; e++) (Fr.x = this.getX(e)), (Fr.y = this.getY(e)), (Fr.z = this.getZ(e)), Fr.transformDirection(t), this.setXYZ(e, Fr.x, Fr.y, Fr.z);
                    return this;
                }
                setX(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset] = e), this;
                }
                setY(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
                }
                setZ(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
                }
                setW(t, e) {
                    return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
                }
                getX(t) {
                    return this.data.array[t * this.data.stride + this.offset];
                }
                getY(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1];
                }
                getZ(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2];
                }
                getW(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3];
                }
                setXY(t, e, i) {
                    return (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = i), this;
                }
                setXYZ(t, e, i, n) {
                    return (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = i), (this.data.array[t + 2] = n), this;
                }
                setXYZW(t, e, i, n, s) {
                    return (t = t * this.data.stride + this.offset), (this.data.array[t + 0] = e), (this.data.array[t + 1] = i), (this.data.array[t + 2] = n), (this.data.array[t + 3] = s), this;
                }
                clone(t) {
                    if (void 0 === t) {
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const i = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
                        }
                        return new $e(new this.array.constructor(t), this.itemSize, this.normalized);
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new Ur(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
                }
                toJSON(t) {
                    if (void 0 === t) {
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const i = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[i + e]);
                        }
                        return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
                }
            }
            Ur.prototype.isInterleavedBufferAttribute = !0;
            class kr extends ze {
                constructor(t) {
                    super(), (this.type = "SpriteMaterial"), (this.color = new Je(16777215)), (this.map = null), (this.alphaMap = null), (this.rotation = 0), (this.sizeAttenuation = !0), (this.transparent = !0), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.rotation = t.rotation), (this.sizeAttenuation = t.sizeAttenuation), this;
                }
            }
            let Or;
            kr.prototype.isSpriteMaterial = !0;
            const Gr = new bt(),
                zr = new bt(),
                Vr = new bt(),
                Hr = new mt(),
                Wr = new mt(),
                qr = new se(),
                jr = new bt(),
                Yr = new bt(),
                Jr = new bt(),
                Xr = new mt(),
                Kr = new mt(),
                Zr = new mt();
            function $r(t, e, i, n, s, r) {
                Hr.subVectors(t, i).addScalar(0.5).multiply(n), void 0 !== s ? ((Wr.x = r * Hr.x - s * Hr.y), (Wr.y = s * Hr.x + r * Hr.y)) : Wr.copy(Hr), t.copy(e), (t.x += Wr.x), (t.y += Wr.y), t.applyMatrix4(qr);
            }
            (class extends Be {
                constructor(t) {
                    if ((super(), (this.type = "Sprite"), void 0 === Or)) {
                        Or = new ui();
                        const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]),
                            e = new Nr(t, 5);
                        Or.setIndex([0, 1, 2, 0, 2, 3]), Or.setAttribute("position", new Ur(e, 3, 0, !1)), Or.setAttribute("uv", new Ur(e, 2, 3, !1));
                    }
                    (this.geometry = Or), (this.material = void 0 !== t ? t : new kr()), (this.center = new mt(0.5, 0.5));
                }
                raycast(t, e) {
                    t.camera, zr.setFromMatrixScale(this.matrixWorld), qr.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Vr.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && zr.multiplyScalar(-Vr.z);
                    const i = this.material.rotation;
                    let n, s;
                    0 !== i && ((s = Math.cos(i)), (n = Math.sin(i)));
                    const r = this.center;
                    $r(jr.set(-0.5, -0.5, 0), Vr, r, zr, n, s), $r(Yr.set(0.5, -0.5, 0), Vr, r, zr, n, s), $r(Jr.set(0.5, 0.5, 0), Vr, r, zr, n, s), Xr.set(0, 0), Kr.set(1, 0), Zr.set(1, 1);
                    let a = t.ray.intersectTriangle(jr, Yr, Jr, !1, Gr);
                    if (null === a && ($r(Yr.set(-0.5, 0.5, 0), Vr, r, zr, n, s), Kr.set(0, 1), (a = t.ray.intersectTriangle(jr, Jr, Yr, !1, Gr)), null === a)) return;
                    const o = t.ray.origin.distanceTo(Gr);
                    o < t.near || o > t.far || e.push({ distance: o, point: Gr.clone(), uv: Oe.getUV(Gr, jr, Yr, Jr, Xr, Kr, Zr, new mt()), face: null, object: this });
                }
                copy(t) {
                    return super.copy(t), void 0 !== t.center && this.center.copy(t.center), (this.material = t.material), this;
                }
            }).prototype.isSprite = !0;
            const ta = new bt(),
                ea = new It(),
                ia = new It(),
                na = new bt(),
                sa = new se();
            class ra extends Bi {
                constructor(t, e) {
                    super(t, e), (this.type = "SkinnedMesh"), (this.bindMode = "attached"), (this.bindMatrix = new se()), (this.bindMatrixInverse = new se());
                }
                copy(t) {
                    return super.copy(t), (this.bindMode = t.bindMode), this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), (this.skeleton = t.skeleton), this;
                }
                bind(t, e) {
                    (this.skeleton = t), void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), (e = this.matrixWorld)), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
                }
                pose() {
                    this.skeleton.pose();
                }
                normalizeSkinWeights() {
                    const t = new It(),
                        e = this.geometry.attributes.skinWeight;
                    for (let i = 0, n = e.count; i < n; i++) {
                        (t.x = e.getX(i)), (t.y = e.getY(i)), (t.z = e.getZ(i)), (t.w = e.getW(i));
                        const n = 1 / t.manhattanLength();
                        n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w);
                    }
                }
                updateMatrixWorld(t) {
                    super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode && this.bindMatrixInverse.copy(this.bindMatrix).invert();
                }
                boneTransform(t, e) {
                    const i = this.skeleton,
                        n = this.geometry;
                    ea.fromBufferAttribute(n.attributes.skinIndex, t), ia.fromBufferAttribute(n.attributes.skinWeight, t), ta.fromBufferAttribute(n.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                    for (let t = 0; t < 4; t++) {
                        const n = ia.getComponent(t);
                        if (0 !== n) {
                            const s = ea.getComponent(t);
                            sa.multiplyMatrices(i.bones[s].matrixWorld, i.boneInverses[s]), e.addScaledVector(na.copy(ta).applyMatrix4(sa), n);
                        }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse);
                }
            }
            ra.prototype.isSkinnedMesh = !0;
            class aa extends Be {
                constructor() {
                    super(), (this.type = "Bone");
                }
            }
            aa.prototype.isBone = !0;
            class oa extends wt {
                constructor(t = null, e = 1, i = 1, n, s, r, a, o, l = 1003, c = 1003, h, u) {
                    super(null, r, a, o, l, c, n, s, h, u), (this.image = { data: t, width: e, height: i }), (this.magFilter = l), (this.minFilter = c), (this.generateMipmaps = !1), (this.flipY = !1), (this.unpackAlignment = 1), (this.needsUpdate = !0);
                }
            }
            oa.prototype.isDataTexture = !0;
            const la = new se(),
                ca = new se();
            class ha {
                constructor(t = [], e = []) {
                    (this.uuid = lt()), (this.bones = t.slice(0)), (this.boneInverses = e), (this.boneMatrices = null), (this.boneTexture = null), (this.boneTextureSize = 0), (this.frame = -1), this.init();
                }
                init() {
                    const t = this.bones,
                        e = this.boneInverses;
                    if (((this.boneMatrices = new Float32Array(16 * t.length)), 0 === e.length)) this.calculateInverses();
                    else if (t.length !== e.length) {
                        this.boneInverses = [];
                        for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new se());
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = new se();
                        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e);
                    }
                }
                pose() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && e.matrixWorld.copy(this.boneInverses[t]).invert();
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale));
                    }
                }
                update() {
                    const t = this.bones,
                        e = this.boneInverses,
                        i = this.boneMatrices,
                        n = this.boneTexture;
                    for (let n = 0, s = t.length; n < s; n++) {
                        const s = t[n] ? t[n].matrixWorld : ca;
                        la.multiplyMatrices(s, e[n]), la.toArray(i, 16 * n);
                    }
                    null !== n && (n.needsUpdate = !0);
                }
                clone() {
                    return new ha(this.bones, this.boneInverses);
                }
                computeBoneTexture() {
                    let t = Math.sqrt(4 * this.bones.length);
                    (t = pt(t)), (t = Math.max(t, 4));
                    const e = new Float32Array(t * t * 4);
                    e.set(this.boneMatrices);
                    const i = new oa(e, t, t, 1023, 1015);
                    return (this.boneMatrices = e), (this.boneTexture = i), (this.boneTextureSize = t), this;
                }
                getBoneByName(t) {
                    for (let e = 0, i = this.bones.length; e < i; e++) {
                        const i = this.bones[e];
                        if (i.name === t) return i;
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), (this.boneTexture = null));
                }
                fromJSON(t, e) {
                    this.uuid = t.uuid;
                    for (let i = 0, n = t.bones.length; i < n; i++) {
                        let n = e[t.bones[i]];
                        void 0 === n && (n = new aa()), this.bones.push(n), this.boneInverses.push(new se().fromArray(t.boneInverses[i]));
                    }
                    return this.init(), this;
                }
                toJSON() {
                    const t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
                    t.uuid = this.uuid;
                    const e = this.bones,
                        i = this.boneInverses;
                    for (let n = 0, s = e.length; n < s; n++) {
                        const s = e[n];
                        t.bones.push(s.uuid);
                        const r = i[n];
                        t.boneInverses.push(r.toArray());
                    }
                    return t;
                }
            }
            const ua = new se(),
                da = new se(),
                pa = [],
                Aa = new Bi();
            (class extends Bi {
                constructor(t, e, i) {
                    super(t, e), (this.instanceMatrix = new $e(new Float32Array(16 * i), 16)), (this.instanceColor = null), (this.count = i), (this.frustumCulled = !1);
                }
                copy(t) {
                    return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), (this.count = t.count), this;
                }
                getColorAt(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t);
                }
                getMatrixAt(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t);
                }
                raycast(t, e) {
                    const i = this.matrixWorld,
                        n = this.count;
                    if (((Aa.geometry = this.geometry), (Aa.material = this.material), void 0 !== Aa.material))
                        for (let s = 0; s < n; s++) {
                            this.getMatrixAt(s, ua), da.multiplyMatrices(i, ua), (Aa.matrixWorld = da), Aa.raycast(t, pa);
                            for (let t = 0, i = pa.length; t < i; t++) {
                                const i = pa[t];
                                (i.instanceId = s), (i.object = this), e.push(i);
                            }
                            pa.length = 0;
                        }
                }
                setColorAt(t, e) {
                    null === this.instanceColor && (this.instanceColor = new $e(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t);
                }
                setMatrixAt(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t);
                }
                updateMorphTargets() {}
                dispose() {
                    this.dispatchEvent({ type: "dispose" });
                }
            }).prototype.isInstancedMesh = !0;
            class ga extends ze {
                constructor(t) {
                    super(), (this.type = "LineBasicMaterial"), (this.color = new Je(16777215)), (this.linewidth = 1), (this.linecap = "round"), (this.linejoin = "round"), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), (this.linewidth = t.linewidth), (this.linecap = t.linecap), (this.linejoin = t.linejoin), this;
                }
            }
            ga.prototype.isLineBasicMaterial = !0;
            const ma = new bt(),
                fa = new bt(),
                va = new se(),
                ya = new ne(),
                xa = new Jt();
            class wa extends Be {
                constructor(t = new ui(), e = new ga()) {
                    super(), (this.type = "Line"), (this.geometry = t), (this.material = e), this.updateMorphTargets();
                }
                copy(t) {
                    return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this;
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        if (null === t.index) {
                            const e = t.attributes.position,
                                i = [0];
                            for (let t = 1, n = e.count; t < n; t++) ma.fromBufferAttribute(e, t - 1), fa.fromBufferAttribute(e, t), (i[t] = i[t - 1]), (i[t] += ma.distanceTo(fa));
                            t.setAttribute("lineDistance", new ii(i, 1));
                        }
                    } else t.isGeometry;
                    return this;
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.matrixWorld,
                        s = t.params.Line.threshold,
                        r = i.drawRange;
                    if ((null === i.boundingSphere && i.computeBoundingSphere(), xa.copy(i.boundingSphere), xa.applyMatrix4(n), (xa.radius += s), !1 === t.ray.intersectsSphere(xa))) return;
                    va.copy(n).invert(), ya.copy(t.ray).applyMatrix4(va);
                    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a,
                        l = new bt(),
                        c = new bt(),
                        h = new bt(),
                        u = new bt(),
                        d = this.isLineSegments ? 2 : 1;
                    if (i.isBufferGeometry) {
                        const n = i.index,
                            s = i.attributes.position;
                        if (null !== n)
                            for (let i = Math.max(0, r.start), a = Math.min(n.count, r.start + r.count) - 1; i < a; i += d) {
                                const r = n.getX(i),
                                    a = n.getX(i + 1);
                                if ((l.fromBufferAttribute(s, r), c.fromBufferAttribute(s, a), ya.distanceSqToSegment(l, c, u, h) > o)) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const d = t.ray.origin.distanceTo(u);
                                d < t.near || d > t.far || e.push({ distance: d, point: h.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this });
                            }
                        else
                            for (let i = Math.max(0, r.start), n = Math.min(s.count, r.start + r.count) - 1; i < n; i += d) {
                                if ((l.fromBufferAttribute(s, i), c.fromBufferAttribute(s, i + 1), ya.distanceSqToSegment(l, c, u, h) > o)) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const n = t.ray.origin.distanceTo(u);
                                n < t.near || n > t.far || e.push({ distance: n, point: h.clone().applyMatrix4(this.matrixWorld), index: i, face: null, faceIndex: null, object: this });
                            }
                    } else i.isGeometry;
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = e);
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length;
                    }
                }
            }
            wa.prototype.isLine = !0;
            const _a = new bt(),
                Ia = new bt();
            class Ca extends wa {
                constructor(t, e) {
                    super(t, e), (this.type = "LineSegments");
                }
                computeLineDistances() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        if (null === t.index) {
                            const e = t.attributes.position,
                                i = [];
                            for (let t = 0, n = e.count; t < n; t += 2) _a.fromBufferAttribute(e, t), Ia.fromBufferAttribute(e, t + 1), (i[t] = 0 === t ? 0 : i[t - 1]), (i[t + 1] = i[t] + _a.distanceTo(Ia));
                            t.setAttribute("lineDistance", new ii(i, 1));
                        }
                    } else t.isGeometry;
                    return this;
                }
            }
            Ca.prototype.isLineSegments = !0;
            class Ma extends wa {
                constructor(t, e) {
                    super(t, e), (this.type = "LineLoop");
                }
            }
            Ma.prototype.isLineLoop = !0;
            class Ea extends ze {
                constructor(t) {
                    super(), (this.type = "PointsMaterial"), (this.color = new Je(16777215)), (this.map = null), (this.alphaMap = null), (this.size = 1), (this.sizeAttenuation = !0), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.alphaMap = t.alphaMap), (this.size = t.size), (this.sizeAttenuation = t.sizeAttenuation), this;
                }
            }
            Ea.prototype.isPointsMaterial = !0;
            const ba = new se(),
                Sa = new ne(),
                Ba = new Jt(),
                Ta = new bt();
            class La extends Be {
                constructor(t = new ui(), e = new Ea()) {
                    super(), (this.type = "Points"), (this.geometry = t), (this.material = e), this.updateMorphTargets();
                }
                copy(t) {
                    return super.copy(t), (this.material = t.material), (this.geometry = t.geometry), this;
                }
                raycast(t, e) {
                    const i = this.geometry,
                        n = this.matrixWorld,
                        s = t.params.Points.threshold,
                        r = i.drawRange;
                    if ((null === i.boundingSphere && i.computeBoundingSphere(), Ba.copy(i.boundingSphere), Ba.applyMatrix4(n), (Ba.radius += s), !1 === t.ray.intersectsSphere(Ba))) return;
                    ba.copy(n).invert(), Sa.copy(t.ray).applyMatrix4(ba);
                    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = a * a;
                    if (i.isBufferGeometry) {
                        const s = i.index,
                            a = i.attributes.position;
                        if (null !== s)
                            for (let i = Math.max(0, r.start), l = Math.min(s.count, r.start + r.count); i < l; i++) {
                                const r = s.getX(i);
                                Ta.fromBufferAttribute(a, r), Da(Ta, r, o, n, t, e, this);
                            }
                        else for (let i = Math.max(0, r.start), s = Math.min(a.count, r.start + r.count); i < s; i++) Ta.fromBufferAttribute(a, i), Da(Ta, i, o, n, t, e, this);
                    }
                }
                updateMorphTargets() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            i = Object.keys(e);
                        if (i.length > 0) {
                            const t = e[i[0]];
                            if (void 0 !== t) {
                                (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
                                for (let e = 0, i = t.length; e < i; e++) {
                                    const i = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), (this.morphTargetDictionary[i] = e);
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length;
                    }
                }
            }
            function Da(t, e, i, n, s, r, a) {
                const o = Sa.distanceSqToPoint(t);
                if (o < i) {
                    const i = new bt();
                    Sa.closestPointToPoint(t, i), i.applyMatrix4(n);
                    const l = s.ray.origin.distanceTo(i);
                    if (l < s.near || l > s.far) return;
                    r.push({ distance: l, distanceToRay: Math.sqrt(o), point: i, index: e, face: null, object: a });
                }
            }
            (La.prototype.isPoints = !0),
                (class extends wt {
                    constructor(t, e, i, n, s, r, a, o, l) {
                        super(t, e, i, n, s, r, a, o, l), (this.format = void 0 !== a ? a : 1022), (this.minFilter = void 0 !== r ? r : 1006), (this.magFilter = void 0 !== s ? s : 1006), (this.generateMipmaps = !1);
                        const c = this;
                        "requestVideoFrameCallback" in t &&
                            t.requestVideoFrameCallback(function e() {
                                (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
                            });
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this);
                    }
                    update() {
                        const t = this.image;
                        !1 == "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
                    }
                }.prototype.isVideoTexture = !0);
            class Qa extends wt {
                constructor(t, e, i, n, s, r, a, o, l, c, h, u) {
                    super(null, r, a, o, l, c, n, s, h, u), (this.image = { width: e, height: i }), (this.mipmaps = t), (this.flipY = !1), (this.generateMipmaps = !1);
                }
            }
            (Qa.prototype.isCompressedTexture = !0),
                (class extends wt {
                    constructor(t, e, i, n, s, r, a, o, l) {
                        super(t, e, i, n, s, r, a, o, l), (this.needsUpdate = !0);
                    }
                }.prototype.isCanvasTexture = !0),
                (class extends wt {
                    constructor(t, e, i, n, s, r, a, o, l, c) {
                        if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        void 0 === i && 1026 === c && (i = 1012), void 0 === i && 1027 === c && (i = 1020), super(null, n, s, r, a, o, c, i, l), (this.image = { width: t, height: e }), (this.magFilter = void 0 !== a ? a : 1003), (this.minFilter = void 0 !== o ? o : 1003), (this.flipY = !1), (this.generateMipmaps = !1);
                    }
                }.prototype.isDepthTexture = !0),
                new bt(),
                new bt(),
                new bt(),
                new Oe();
            class Ra {
                constructor() {
                    (this.type = "Curve"), (this.arcLengthDivisions = 200);
                }
                getPoint() {
                    return null;
                }
                getPointAt(t, e) {
                    const i = this.getUtoTmapping(t);
                    return this.getPoint(i, e);
                }
                getPoints(t = 5) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return e;
                }
                getSpacedPoints(t = 5) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
                    return e;
                }
                getLength() {
                    const t = this.getLengths();
                    return t[t.length - 1];
                }
                getLengths(t = this.arcLengthDivisions) {
                    if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let i,
                        n = this.getPoint(0),
                        s = 0;
                    e.push(0);
                    for (let r = 1; r <= t; r++) (i = this.getPoint(r / t)), (s += i.distanceTo(n)), e.push(s), (n = i);
                    return (this.cacheArcLengths = e), e;
                }
                updateArcLengths() {
                    (this.needsUpdate = !0), this.getLengths();
                }
                getUtoTmapping(t, e) {
                    const i = this.getLengths();
                    let n = 0;
                    const s = i.length;
                    let r;
                    r = e || t * i[s - 1];
                    let a,
                        o = 0,
                        l = s - 1;
                    for (; o <= l; )
                        if (((n = Math.floor(o + (l - o) / 2)), (a = i[n] - r), a < 0)) o = n + 1;
                        else {
                            if (!(a > 0)) {
                                l = n;
                                break;
                            }
                            l = n - 1;
                        }
                    if (((n = l), i[n] === r)) return n / (s - 1);
                    const c = i[n];
                    return (n + (r - c) / (i[n + 1] - c)) / (s - 1);
                }
                getTangent(t, e) {
                    const i = 1e-4;
                    let n = t - i,
                        s = t + i;
                    n < 0 && (n = 0), s > 1 && (s = 1);
                    const r = this.getPoint(n),
                        a = this.getPoint(s),
                        o = e || (r.isVector2 ? new mt() : new bt());
                    return o.copy(a).sub(r).normalize(), o;
                }
                getTangentAt(t, e) {
                    const i = this.getUtoTmapping(t);
                    return this.getTangent(i, e);
                }
                computeFrenetFrames(t, e) {
                    const i = new bt(),
                        n = [],
                        s = [],
                        r = [],
                        a = new bt(),
                        o = new se();
                    for (let e = 0; e <= t; e++) {
                        const i = e / t;
                        (n[e] = this.getTangentAt(i, new bt())), n[e].normalize();
                    }
                    (s[0] = new bt()), (r[0] = new bt());
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(n[0].x),
                        h = Math.abs(n[0].y),
                        u = Math.abs(n[0].z);
                    c <= l && ((l = c), i.set(1, 0, 0)), h <= l && ((l = h), i.set(0, 1, 0)), u <= l && i.set(0, 0, 1), a.crossVectors(n[0], i).normalize(), s[0].crossVectors(n[0], a), r[0].crossVectors(n[0], s[0]);
                    for (let e = 1; e <= t; e++) {
                        if (((s[e] = s[e - 1].clone()), (r[e] = r[e - 1].clone()), a.crossVectors(n[e - 1], n[e]), a.length() > Number.EPSILON)) {
                            a.normalize();
                            const t = Math.acos(ct(n[e - 1].dot(n[e]), -1, 1));
                            s[e].applyMatrix4(o.makeRotationAxis(a, t));
                        }
                        r[e].crossVectors(n[e], s[e]);
                    }
                    if (!0 === e) {
                        let e = Math.acos(ct(s[0].dot(s[t]), -1, 1));
                        (e /= t), n[0].dot(a.crossVectors(s[0], s[t])) > 0 && (e = -e);
                        for (let i = 1; i <= t; i++) s[i].applyMatrix4(o.makeRotationAxis(n[i], e * i)), r[i].crossVectors(n[i], s[i]);
                    }
                    return { tangents: n, normals: s, binormals: r };
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                copy(t) {
                    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
                }
                toJSON() {
                    const t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
                    return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t;
                }
                fromJSON(t) {
                    return (this.arcLengthDivisions = t.arcLengthDivisions), this;
                }
            }
            class Pa extends Ra {
                constructor(t = 0, e = 0, i = 1, n = 1, s = 0, r = 2 * Math.PI, a = !1, o = 0) {
                    super(), (this.type = "EllipseCurve"), (this.aX = t), (this.aY = e), (this.xRadius = i), (this.yRadius = n), (this.aStartAngle = s), (this.aEndAngle = r), (this.aClockwise = a), (this.aRotation = o);
                }
                getPoint(t, e) {
                    const i = e || new mt(),
                        n = 2 * Math.PI;
                    let s = this.aEndAngle - this.aStartAngle;
                    const r = Math.abs(s) < Number.EPSILON;
                    for (; s < 0; ) s += n;
                    for (; s > n; ) s -= n;
                    s < Number.EPSILON && (s = r ? 0 : n), !0 !== this.aClockwise || r || (s === n ? (s = -n) : (s -= n));
                    const a = this.aStartAngle + t * s;
                    let o = this.aX + this.xRadius * Math.cos(a),
                        l = this.aY + this.yRadius * Math.sin(a);
                    if (0 !== this.aRotation) {
                        const t = Math.cos(this.aRotation),
                            e = Math.sin(this.aRotation),
                            i = o - this.aX,
                            n = l - this.aY;
                        (o = i * t - n * e + this.aX), (l = i * e + n * t + this.aY);
                    }
                    return i.set(o, l);
                }
                copy(t) {
                    return super.copy(t), (this.aX = t.aX), (this.aY = t.aY), (this.xRadius = t.xRadius), (this.yRadius = t.yRadius), (this.aStartAngle = t.aStartAngle), (this.aEndAngle = t.aEndAngle), (this.aClockwise = t.aClockwise), (this.aRotation = t.aRotation), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.aX = this.aX), (t.aY = this.aY), (t.xRadius = this.xRadius), (t.yRadius = this.yRadius), (t.aStartAngle = this.aStartAngle), (t.aEndAngle = this.aEndAngle), (t.aClockwise = this.aClockwise), (t.aRotation = this.aRotation), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), (this.aX = t.aX), (this.aY = t.aY), (this.xRadius = t.xRadius), (this.yRadius = t.yRadius), (this.aStartAngle = t.aStartAngle), (this.aEndAngle = t.aEndAngle), (this.aClockwise = t.aClockwise), (this.aRotation = t.aRotation), this;
                }
            }
            Pa.prototype.isEllipseCurve = !0;
            class Na extends Pa {
                constructor(t, e, i, n, s, r) {
                    super(t, e, i, i, n, s, r), (this.type = "ArcCurve");
                }
            }
            function Fa() {
                let t = 0,
                    e = 0,
                    i = 0,
                    n = 0;
                function s(s, r, a, o) {
                    (t = s), (e = a), (i = -3 * s + 3 * r - 2 * a - o), (n = 2 * s - 2 * r + a + o);
                }
                return {
                    initCatmullRom: function (t, e, i, n, r) {
                        s(e, i, r * (i - t), r * (n - e));
                    },
                    initNonuniformCatmullRom: function (t, e, i, n, r, a, o) {
                        let l = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
                            c = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
                        (l *= a), (c *= a), s(e, i, l, c);
                    },
                    calc: function (s) {
                        const r = s * s;
                        return t + e * s + i * r + n * (r * s);
                    },
                };
            }
            Na.prototype.isArcCurve = !0;
            const Ua = new bt(),
                ka = new Fa(),
                Oa = new Fa(),
                Ga = new Fa();
            class za extends Ra {
                constructor(t = [], e = !1, i = "centripetal", n = 0.5) {
                    super(), (this.type = "CatmullRomCurve3"), (this.points = t), (this.closed = e), (this.curveType = i), (this.tension = n);
                }
                getPoint(t, e = new bt()) {
                    const i = e,
                        n = this.points,
                        s = n.length,
                        r = (s - (this.closed ? 0 : 1)) * t;
                    let a,
                        o,
                        l = Math.floor(r),
                        c = r - l;
                    this.closed ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s) : 0 === c && l === s - 1 && ((l = s - 2), (c = 1)), this.closed || l > 0 ? (a = n[(l - 1) % s]) : (Ua.subVectors(n[0], n[1]).add(n[0]), (a = Ua));
                    const h = n[l % s],
                        u = n[(l + 1) % s];
                    if ((this.closed || l + 2 < s ? (o = n[(l + 2) % s]) : (Ua.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), (o = Ua)), "centripetal" === this.curveType || "chordal" === this.curveType)) {
                        const t = "chordal" === this.curveType ? 0.5 : 0.25;
                        let e = Math.pow(a.distanceToSquared(h), t),
                            i = Math.pow(h.distanceToSquared(u), t),
                            n = Math.pow(u.distanceToSquared(o), t);
                        i < 1e-4 && (i = 1), e < 1e-4 && (e = i), n < 1e-4 && (n = i), ka.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, i, n), Oa.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, i, n), Ga.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, i, n);
                    } else "catmullrom" === this.curveType && (ka.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), Oa.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), Ga.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
                    return i.set(ka.calc(c), Oa.calc(c), Ga.calc(c)), i;
                }
                copy(t) {
                    super.copy(t), (this.points = []);
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push(i.clone());
                    }
                    return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, i = this.points.length; e < i; e++) {
                        const i = this.points[e];
                        t.points.push(i.toArray());
                    }
                    return (t.closed = this.closed), (t.curveType = this.curveType), (t.tension = this.tension), t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.points = []);
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push(new bt().fromArray(i));
                    }
                    return (this.closed = t.closed), (this.curveType = t.curveType), (this.tension = t.tension), this;
                }
            }
            function Va(t, e, i, n, s) {
                const r = 0.5 * (n - e),
                    a = 0.5 * (s - i),
                    o = t * t;
                return (2 * i - 2 * n + r + a) * (t * o) + (-3 * i + 3 * n - 2 * r - a) * o + r * t + i;
            }
            function Ha(t, e, i, n) {
                return (
                    (function (t, e) {
                        const i = 1 - t;
                        return i * i * e;
                    })(t, e) +
                    (function (t, e) {
                        return 2 * (1 - t) * t * e;
                    })(t, i) +
                    (function (t, e) {
                        return t * t * e;
                    })(t, n)
                );
            }
            function Wa(t, e, i, n, s) {
                return (
                    (function (t, e) {
                        const i = 1 - t;
                        return i * i * i * e;
                    })(t, e) +
                    (function (t, e) {
                        const i = 1 - t;
                        return 3 * i * i * t * e;
                    })(t, i) +
                    (function (t, e) {
                        return 3 * (1 - t) * t * t * e;
                    })(t, n) +
                    (function (t, e) {
                        return t * t * t * e;
                    })(t, s)
                );
            }
            za.prototype.isCatmullRomCurve3 = !0;
            class qa extends Ra {
                constructor(t = new mt(), e = new mt(), i = new mt(), n = new mt()) {
                    super(), (this.type = "CubicBezierCurve"), (this.v0 = t), (this.v1 = e), (this.v2 = i), (this.v3 = n);
                }
                getPoint(t, e = new mt()) {
                    const i = e,
                        n = this.v0,
                        s = this.v1,
                        r = this.v2,
                        a = this.v3;
                    return i.set(Wa(t, n.x, s.x, r.x, a.x), Wa(t, n.y, s.y, r.y, a.y)), i;
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), (t.v3 = this.v3.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
                }
            }
            qa.prototype.isCubicBezierCurve = !0;
            class ja extends Ra {
                constructor(t = new bt(), e = new bt(), i = new bt(), n = new bt()) {
                    super(), (this.type = "CubicBezierCurve3"), (this.v0 = t), (this.v1 = e), (this.v2 = i), (this.v3 = n);
                }
                getPoint(t, e = new bt()) {
                    const i = e,
                        n = this.v0,
                        s = this.v1,
                        r = this.v2,
                        a = this.v3;
                    return i.set(Wa(t, n.x, s.x, r.x, a.x), Wa(t, n.y, s.y, r.y, a.y), Wa(t, n.z, s.z, r.z, a.z)), i;
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), (t.v3 = this.v3.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
                }
            }
            ja.prototype.isCubicBezierCurve3 = !0;
            class Ya extends Ra {
                constructor(t = new mt(), e = new mt()) {
                    super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
                }
                getPoint(t, e = new mt()) {
                    const i = e;
                    return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e);
                }
                getTangent(t, e) {
                    const i = e || new mt();
                    return i.copy(this.v2).sub(this.v1).normalize(), i;
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
                }
            }
            Ya.prototype.isLineCurve = !0;
            class Ja extends Ra {
                constructor(t = new mt(), e = new mt(), i = new mt()) {
                    super(), (this.type = "QuadraticBezierCurve"), (this.v0 = t), (this.v1 = e), (this.v2 = i);
                }
                getPoint(t, e = new mt()) {
                    const i = e,
                        n = this.v0,
                        s = this.v1,
                        r = this.v2;
                    return i.set(Ha(t, n.x, s.x, r.x), Ha(t, n.y, s.y, r.y)), i;
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
                }
            }
            Ja.prototype.isQuadraticBezierCurve = !0;
            class Xa extends Ra {
                constructor(t = new bt(), e = new bt(), i = new bt()) {
                    super(), (this.type = "QuadraticBezierCurve3"), (this.v0 = t), (this.v1 = e), (this.v2 = i);
                }
                getPoint(t, e = new bt()) {
                    const i = e,
                        n = this.v0,
                        s = this.v1,
                        r = this.v2;
                    return i.set(Ha(t, n.x, s.x, r.x), Ha(t, n.y, s.y, r.y), Ha(t, n.z, s.z, r.z)), i;
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.v0 = this.v0.toArray()), (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
                }
            }
            Xa.prototype.isQuadraticBezierCurve3 = !0;
            class Ka extends Ra {
                constructor(t = []) {
                    super(), (this.type = "SplineCurve"), (this.points = t);
                }
                getPoint(t, e = new mt()) {
                    const i = e,
                        n = this.points,
                        s = (n.length - 1) * t,
                        r = Math.floor(s),
                        a = s - r,
                        o = n[0 === r ? r : r - 1],
                        l = n[r],
                        c = n[r > n.length - 2 ? n.length - 1 : r + 1],
                        h = n[r > n.length - 3 ? n.length - 1 : r + 2];
                    return i.set(Va(a, o.x, l.x, c.x, h.x), Va(a, o.y, l.y, c.y, h.y)), i;
                }
                copy(t) {
                    super.copy(t), (this.points = []);
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push(i.clone());
                    }
                    return this;
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, i = this.points.length; e < i; e++) {
                        const i = this.points[e];
                        t.points.push(i.toArray());
                    }
                    return t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.points = []);
                    for (let e = 0, i = t.points.length; e < i; e++) {
                        const i = t.points[e];
                        this.points.push(new mt().fromArray(i));
                    }
                    return this;
                }
            }
            Ka.prototype.isSplineCurve = !0;
            var Za = Object.freeze({
                __proto__: null,
                ArcCurve: Na,
                CatmullRomCurve3: za,
                CubicBezierCurve: qa,
                CubicBezierCurve3: ja,
                EllipseCurve: Pa,
                LineCurve: Ya,
                LineCurve3: class extends Ra {
                    constructor(t = new bt(), e = new bt()) {
                        super(), (this.type = "LineCurve3"), (this.isLineCurve3 = !0), (this.v1 = t), (this.v2 = e);
                    }
                    getPoint(t, e = new bt()) {
                        const i = e;
                        return 1 === t ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)), i;
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e);
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
                    }
                },
                QuadraticBezierCurve: Ja,
                QuadraticBezierCurve3: Xa,
                SplineCurve: Ka,
            });
            function $a(t, e, i, n, s) {
                let r, a;
                if (
                    s ===
                    (function (t, e, i, n) {
                        let s = 0;
                        for (let r = e, a = i - n; r < i; r += n) (s += (t[a] - t[r]) * (t[r + 1] + t[a + 1])), (a = r);
                        return s;
                    })(t, e, i, n) >
                        0
                )
                    for (r = e; r < i; r += n) a = wo(r, t[r], t[r + 1], a);
                else for (r = i - n; r >= e; r -= n) a = wo(r, t[r], t[r + 1], a);
                return a && go(a, a.next) && (_o(a), (a = a.next)), a;
            }
            function to(t, e) {
                if (!t) return t;
                e || (e = t);
                let i,
                    n = t;
                do {
                    if (((i = !1), n.steiner || (!go(n, n.next) && 0 !== Ao(n.prev, n, n.next)))) n = n.next;
                    else {
                        if ((_o(n), (n = e = n.prev), n === n.next)) break;
                        i = !0;
                    }
                } while (i || n !== e);
                return e;
            }
            function eo(t, e, i, n, s, r, a) {
                if (!t) return;
                !a &&
                    r &&
                    (function (t, e, i, n) {
                        let s = t;
                        do {
                            null === s.z && (s.z = co(s.x, s.y, e, i, n)), (s.prevZ = s.prev), (s.nextZ = s.next), (s = s.next);
                        } while (s !== t);
                        (s.prevZ.nextZ = null),
                            (s.prevZ = null),
                            (function (t) {
                                let e,
                                    i,
                                    n,
                                    s,
                                    r,
                                    a,
                                    o,
                                    l,
                                    c = 1;
                                do {
                                    for (i = t, t = null, r = null, a = 0; i; ) {
                                        for (a++, n = i, o = 0, e = 0; e < c && (o++, (n = n.nextZ), n); e++);
                                        for (l = c; o > 0 || (l > 0 && n); ) 0 !== o && (0 === l || !n || i.z <= n.z) ? ((s = i), (i = i.nextZ), o--) : ((s = n), (n = n.nextZ), l--), r ? (r.nextZ = s) : (t = s), (s.prevZ = r), (r = s);
                                        i = n;
                                    }
                                    (r.nextZ = null), (c *= 2);
                                } while (a > 1);
                            })(s);
                    })(t, n, s, r);
                let o,
                    l,
                    c = t;
                for (; t.prev !== t.next; )
                    if (((o = t.prev), (l = t.next), r ? no(t, n, s, r) : io(t))) e.push(o.i / i), e.push(t.i / i), e.push(l.i / i), _o(t), (t = l.next), (c = l.next);
                    else if ((t = l) === c) {
                        a ? (1 === a ? eo((t = so(to(t), e, i)), e, i, n, s, r, 2) : 2 === a && ro(t, e, i, n, s, r)) : eo(to(t), e, i, n, s, r, 1);
                        break;
                    }
            }
            function io(t) {
                const e = t.prev,
                    i = t,
                    n = t.next;
                if (Ao(e, i, n) >= 0) return !1;
                let s = t.next.next;
                for (; s !== t.prev; ) {
                    if (uo(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && Ao(s.prev, s, s.next) >= 0) return !1;
                    s = s.next;
                }
                return !0;
            }
            function no(t, e, i, n) {
                const s = t.prev,
                    r = t,
                    a = t.next;
                if (Ao(s, r, a) >= 0) return !1;
                const o = s.x < r.x ? (s.x < a.x ? s.x : a.x) : r.x < a.x ? r.x : a.x,
                    l = s.y < r.y ? (s.y < a.y ? s.y : a.y) : r.y < a.y ? r.y : a.y,
                    c = s.x > r.x ? (s.x > a.x ? s.x : a.x) : r.x > a.x ? r.x : a.x,
                    h = s.y > r.y ? (s.y > a.y ? s.y : a.y) : r.y > a.y ? r.y : a.y,
                    u = co(o, l, e, i, n),
                    d = co(c, h, e, i, n);
                let p = t.prevZ,
                    A = t.nextZ;
                for (; p && p.z >= u && A && A.z <= d; ) {
                    if (p !== t.prev && p !== t.next && uo(s.x, s.y, r.x, r.y, a.x, a.y, p.x, p.y) && Ao(p.prev, p, p.next) >= 0) return !1;
                    if (((p = p.prevZ), A !== t.prev && A !== t.next && uo(s.x, s.y, r.x, r.y, a.x, a.y, A.x, A.y) && Ao(A.prev, A, A.next) >= 0)) return !1;
                    A = A.nextZ;
                }
                for (; p && p.z >= u; ) {
                    if (p !== t.prev && p !== t.next && uo(s.x, s.y, r.x, r.y, a.x, a.y, p.x, p.y) && Ao(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ;
                }
                for (; A && A.z <= d; ) {
                    if (A !== t.prev && A !== t.next && uo(s.x, s.y, r.x, r.y, a.x, a.y, A.x, A.y) && Ao(A.prev, A, A.next) >= 0) return !1;
                    A = A.nextZ;
                }
                return !0;
            }
            function so(t, e, i) {
                let n = t;
                do {
                    const s = n.prev,
                        r = n.next.next;
                    !go(s, r) && mo(s, n, n.next, r) && yo(s, r) && yo(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), _o(n), _o(n.next), (n = t = r)), (n = n.next);
                } while (n !== t);
                return to(n);
            }
            function ro(t, e, i, n, s, r) {
                let a = t;
                do {
                    let t = a.next.next;
                    for (; t !== a.prev; ) {
                        if (a.i !== t.i && po(a, t)) {
                            let o = xo(a, t);
                            return (a = to(a, a.next)), (o = to(o, o.next)), eo(a, e, i, n, s, r), void eo(o, e, i, n, s, r);
                        }
                        t = t.next;
                    }
                    a = a.next;
                } while (a !== t);
            }
            function ao(t, e) {
                return t.x - e.x;
            }
            function oo(t, e) {
                if (
                    (e = (function (t, e) {
                        let i = e;
                        const n = t.x,
                            s = t.y;
                        let r,
                            a = -1 / 0;
                        do {
                            if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                                const t = i.x + ((s - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
                                if (t <= n && t > a) {
                                    if (((a = t), t === n)) {
                                        if (s === i.y) return i;
                                        if (s === i.next.y) return i.next;
                                    }
                                    r = i.x < i.next.x ? i : i.next;
                                }
                            }
                            i = i.next;
                        } while (i !== e);
                        if (!r) return null;
                        if (n === a) return r;
                        const o = r,
                            l = r.x,
                            c = r.y;
                        let h,
                            u = 1 / 0;
                        i = r;
                        do {
                            n >= i.x && i.x >= l && n !== i.x && uo(s < c ? n : a, s, l, c, s < c ? a : n, s, i.x, i.y) && ((h = Math.abs(s - i.y) / (n - i.x)), yo(i, t) && (h < u || (h === u && (i.x > r.x || (i.x === r.x && lo(r, i))))) && ((r = i), (u = h))), (i = i.next);
                        } while (i !== o);
                        return r;
                    })(t, e))
                ) {
                    const i = xo(e, t);
                    to(e, e.next), to(i, i.next);
                }
            }
            function lo(t, e) {
                return Ao(t.prev, t, e.prev) < 0 && Ao(e.next, t, t.next) < 0;
            }
            function co(t, e, i, n, s) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | (t << 8))) | (t << 4))) | (t << 2))) | (t << 1))) | ((e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | (e << 8))) | (e << 4))) | (e << 2))) | (e << 1))) << 1);
            }
            function ho(t) {
                let e = t,
                    i = t;
                do {
                    (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
                } while (e !== t);
                return i;
            }
            function uo(t, e, i, n, s, r, a, o) {
                return (s - a) * (e - o) - (t - a) * (r - o) >= 0 && (t - a) * (n - o) - (i - a) * (e - o) >= 0 && (i - a) * (r - o) - (s - a) * (n - o) >= 0;
            }
            function po(t, e) {
                return (
                    t.next.i !== e.i &&
                    t.prev.i !== e.i &&
                    !(function (t, e) {
                        let i = t;
                        do {
                            if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && mo(i, i.next, t, e)) return !0;
                            i = i.next;
                        } while (i !== t);
                        return !1;
                    })(t, e) &&
                    ((yo(t, e) &&
                        yo(e, t) &&
                        (function (t, e) {
                            let i = t,
                                n = !1;
                            const s = (t.x + e.x) / 2,
                                r = (t.y + e.y) / 2;
                            do {
                                i.y > r != i.next.y > r && i.next.y !== i.y && s < ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) + i.x && (n = !n), (i = i.next);
                            } while (i !== t);
                            return n;
                        })(t, e) &&
                        (Ao(t.prev, t, e.prev) || Ao(t, e.prev, e))) ||
                        (go(t, e) && Ao(t.prev, t, t.next) > 0 && Ao(e.prev, e, e.next) > 0))
                );
            }
            function Ao(t, e, i) {
                return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
            }
            function go(t, e) {
                return t.x === e.x && t.y === e.y;
            }
            function mo(t, e, i, n) {
                const s = vo(Ao(t, e, i)),
                    r = vo(Ao(t, e, n)),
                    a = vo(Ao(i, n, t)),
                    o = vo(Ao(i, n, e));
                return (s !== r && a !== o) || !(0 !== s || !fo(t, i, e)) || !(0 !== r || !fo(t, n, e)) || !(0 !== a || !fo(i, t, n)) || !(0 !== o || !fo(i, e, n));
            }
            function fo(t, e, i) {
                return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y);
            }
            function vo(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0;
            }
            function yo(t, e) {
                return Ao(t.prev, t, t.next) < 0 ? Ao(t, e, t.next) >= 0 && Ao(t, t.prev, e) >= 0 : Ao(t, e, t.prev) < 0 || Ao(t, t.next, e) < 0;
            }
            function xo(t, e) {
                const i = new Io(t.i, t.x, t.y),
                    n = new Io(e.i, e.x, e.y),
                    s = t.next,
                    r = e.prev;
                return (t.next = e), (e.prev = t), (i.next = s), (s.prev = i), (n.next = i), (i.prev = n), (r.next = n), (n.prev = r), n;
            }
            function wo(t, e, i, n) {
                const s = new Io(t, e, i);
                return n ? ((s.next = n.next), (s.prev = n), (n.next.prev = s), (n.next = s)) : ((s.prev = s), (s.next = s)), s;
            }
            function _o(t) {
                (t.next.prev = t.prev), (t.prev.next = t.next), t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);
            }
            function Io(t, e, i) {
                (this.i = t), (this.x = e), (this.y = i), (this.prev = null), (this.next = null), (this.z = null), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
            }
            class Co {
                static area(t) {
                    const e = t.length;
                    let i = 0;
                    for (let n = e - 1, s = 0; s < e; n = s++) i += t[n].x * t[s].y - t[s].x * t[n].y;
                    return 0.5 * i;
                }
                static isClockWise(t) {
                    return Co.area(t) < 0;
                }
                static triangulateShape(t, e) {
                    const i = [],
                        n = [],
                        s = [];
                    Mo(t), Eo(i, t);
                    let r = t.length;
                    e.forEach(Mo);
                    for (let t = 0; t < e.length; t++) n.push(r), (r += e[t].length), Eo(i, e[t]);
                    const a = (function (t, e, i = 2) {
                        const n = e && e.length,
                            s = n ? e[0] * i : t.length;
                        let r = $a(t, 0, s, i, !0);
                        const a = [];
                        if (!r || r.next === r.prev) return a;
                        let o, l, c, h, u, d, p;
                        if (
                            (n &&
                                (r = (function (t, e, i, n) {
                                    const s = [];
                                    let r, a, o, l, c;
                                    for (r = 0, a = e.length; r < a; r++) (o = e[r] * n), (l = r < a - 1 ? e[r + 1] * n : t.length), (c = $a(t, o, l, n, !1)), c === c.next && (c.steiner = !0), s.push(ho(c));
                                    for (s.sort(ao), r = 0; r < s.length; r++) oo(s[r], i), (i = to(i, i.next));
                                    return i;
                                })(t, e, r, i)),
                            t.length > 80 * i)
                        ) {
                            (o = c = t[0]), (l = h = t[1]);
                            for (let e = i; e < s; e += i) (u = t[e]), (d = t[e + 1]), u < o && (o = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
                            (p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0);
                        }
                        return eo(r, a, i, o, l, p), a;
                    })(i, n);
                    for (let t = 0; t < a.length; t += 3) s.push(a.slice(t, t + 3));
                    return s;
                }
            }
            function Mo(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop();
            }
            function Eo(t, e) {
                for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
            }
            class bo extends ui {
                constructor(t, e) {
                    super(), (this.type = "ExtrudeGeometry"), (this.parameters = { shapes: t, options: e }), (t = Array.isArray(t) ? t : [t]);
                    const i = this,
                        n = [],
                        s = [];
                    for (let e = 0, i = t.length; e < i; e++) r(t[e]);
                    function r(t) {
                        const r = [],
                            a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            o = void 0 !== e.steps ? e.steps : 1;
                        let l = void 0 !== e.depth ? e.depth : 100,
                            c = void 0 === e.bevelEnabled || e.bevelEnabled,
                            h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                            u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const A = e.extrudePath,
                            g = void 0 !== e.UVGenerator ? e.UVGenerator : So;
                        void 0 !== e.amount && (l = e.amount);
                        let m,
                            f,
                            v,
                            y,
                            x,
                            w = !1;
                        A && ((m = A.getSpacedPoints(o)), (w = !0), (c = !1), (f = A.computeFrenetFrames(o, !1)), (v = new bt()), (y = new bt()), (x = new bt())), c || ((p = 0), (h = 0), (u = 0), (d = 0));
                        const _ = t.extractPoints(a);
                        let I = _.shape;
                        const C = _.holes;
                        if (!Co.isClockWise(I)) {
                            I = I.reverse();
                            for (let t = 0, e = C.length; t < e; t++) {
                                const e = C[t];
                                Co.isClockWise(e) && (C[t] = e.reverse());
                            }
                        }
                        const M = Co.triangulateShape(I, C),
                            E = I;
                        for (let t = 0, e = C.length; t < e; t++) {
                            const e = C[t];
                            I = I.concat(e);
                        }
                        function b(t, e, i) {
                            return e.clone().multiplyScalar(i).add(t);
                        }
                        const S = I.length,
                            B = M.length;
                        function T(t, e, i) {
                            let n, s, r;
                            const a = t.x - e.x,
                                o = t.y - e.y,
                                l = i.x - t.x,
                                c = i.y - t.y,
                                h = a * a + o * o,
                                u = a * c - o * l;
                            if (Math.abs(u) > Number.EPSILON) {
                                const u = Math.sqrt(h),
                                    d = Math.sqrt(l * l + c * c),
                                    p = e.x - o / u,
                                    A = e.y + a / u,
                                    g = ((i.x - c / d - p) * c - (i.y + l / d - A) * l) / (a * c - o * l);
                                (n = p + a * g - t.x), (s = A + o * g - t.y);
                                const m = n * n + s * s;
                                if (m <= 2) return new mt(n, s);
                                r = Math.sqrt(m / 2);
                            } else {
                                let t = !1;
                                a > Number.EPSILON ? l > Number.EPSILON && (t = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(c) && (t = !0), t ? ((n = -o), (s = a), (r = Math.sqrt(h))) : ((n = a), (s = o), (r = Math.sqrt(h / 2)));
                            }
                            return new mt(n / r, s / r);
                        }
                        const L = [];
                        for (let t = 0, e = E.length, i = e - 1, n = t + 1; t < e; t++, i++, n++) i === e && (i = 0), n === e && (n = 0), (L[t] = T(E[t], E[i], E[n]));
                        const D = [];
                        let Q,
                            R = L.concat();
                        for (let t = 0, e = C.length; t < e; t++) {
                            const e = C[t];
                            Q = [];
                            for (let t = 0, i = e.length, n = i - 1, s = t + 1; t < i; t++, n++, s++) n === i && (n = 0), s === i && (s = 0), (Q[t] = T(e[t], e[n], e[s]));
                            D.push(Q), (R = R.concat(Q));
                        }
                        for (let t = 0; t < p; t++) {
                            const e = t / p,
                                i = h * Math.cos((e * Math.PI) / 2),
                                n = u * Math.sin((e * Math.PI) / 2) + d;
                            for (let t = 0, e = E.length; t < e; t++) {
                                const e = b(E[t], L[t], n);
                                F(e.x, e.y, -i);
                            }
                            for (let t = 0, e = C.length; t < e; t++) {
                                const e = C[t];
                                Q = D[t];
                                for (let t = 0, s = e.length; t < s; t++) {
                                    const s = b(e[t], Q[t], n);
                                    F(s.x, s.y, -i);
                                }
                            }
                        }
                        const P = u + d;
                        for (let t = 0; t < S; t++) {
                            const e = c ? b(I[t], R[t], P) : I[t];
                            w ? (y.copy(f.normals[0]).multiplyScalar(e.x), v.copy(f.binormals[0]).multiplyScalar(e.y), x.copy(m[0]).add(y).add(v), F(x.x, x.y, x.z)) : F(e.x, e.y, 0);
                        }
                        for (let t = 1; t <= o; t++)
                            for (let e = 0; e < S; e++) {
                                const i = c ? b(I[e], R[e], P) : I[e];
                                w ? (y.copy(f.normals[t]).multiplyScalar(i.x), v.copy(f.binormals[t]).multiplyScalar(i.y), x.copy(m[t]).add(y).add(v), F(x.x, x.y, x.z)) : F(i.x, i.y, (l / o) * t);
                            }
                        for (let t = p - 1; t >= 0; t--) {
                            const e = t / p,
                                i = h * Math.cos((e * Math.PI) / 2),
                                n = u * Math.sin((e * Math.PI) / 2) + d;
                            for (let t = 0, e = E.length; t < e; t++) {
                                const e = b(E[t], L[t], n);
                                F(e.x, e.y, l + i);
                            }
                            for (let t = 0, e = C.length; t < e; t++) {
                                const e = C[t];
                                Q = D[t];
                                for (let t = 0, s = e.length; t < s; t++) {
                                    const s = b(e[t], Q[t], n);
                                    w ? F(s.x, s.y + m[o - 1].y, m[o - 1].x + i) : F(s.x, s.y, l + i);
                                }
                            }
                        }
                        function N(t, e) {
                            let i = t.length;
                            for (; --i >= 0; ) {
                                const n = i;
                                let s = i - 1;
                                s < 0 && (s = t.length - 1);
                                for (let t = 0, i = o + 2 * p; t < i; t++) {
                                    const i = S * t,
                                        r = S * (t + 1);
                                    k(e + n + i, e + s + i, e + s + r, e + n + r);
                                }
                            }
                        }
                        function F(t, e, i) {
                            r.push(t), r.push(e), r.push(i);
                        }
                        function U(t, e, s) {
                            O(t), O(e), O(s);
                            const r = n.length / 3,
                                a = g.generateTopUV(i, n, r - 3, r - 2, r - 1);
                            G(a[0]), G(a[1]), G(a[2]);
                        }
                        function k(t, e, s, r) {
                            O(t), O(e), O(r), O(e), O(s), O(r);
                            const a = n.length / 3,
                                o = g.generateSideWallUV(i, n, a - 6, a - 3, a - 2, a - 1);
                            G(o[0]), G(o[1]), G(o[3]), G(o[1]), G(o[2]), G(o[3]);
                        }
                        function O(t) {
                            n.push(r[3 * t + 0]), n.push(r[3 * t + 1]), n.push(r[3 * t + 2]);
                        }
                        function G(t) {
                            s.push(t.x), s.push(t.y);
                        }
                        !(function () {
                            const t = n.length / 3;
                            if (c) {
                                let t = 0,
                                    e = S * t;
                                for (let t = 0; t < B; t++) {
                                    const i = M[t];
                                    U(i[2] + e, i[1] + e, i[0] + e);
                                }
                                (t = o + 2 * p), (e = S * t);
                                for (let t = 0; t < B; t++) {
                                    const i = M[t];
                                    U(i[0] + e, i[1] + e, i[2] + e);
                                }
                            } else {
                                for (let t = 0; t < B; t++) {
                                    const e = M[t];
                                    U(e[2], e[1], e[0]);
                                }
                                for (let t = 0; t < B; t++) {
                                    const e = M[t];
                                    U(e[0] + S * o, e[1] + S * o, e[2] + S * o);
                                }
                            }
                            i.addGroup(t, n.length / 3 - t, 0);
                        })(),
                            (function () {
                                const t = n.length / 3;
                                let e = 0;
                                N(E, e), (e += E.length);
                                for (let t = 0, i = C.length; t < i; t++) {
                                    const i = C[t];
                                    N(i, e), (e += i.length);
                                }
                                i.addGroup(t, n.length / 3 - t, 1);
                            })();
                    }
                    this.setAttribute("position", new ii(n, 3)), this.setAttribute("uv", new ii(s, 2)), this.computeVertexNormals();
                }
                toJSON() {
                    const t = super.toJSON();
                    return (function (t, e, i) {
                        if (((i.shapes = []), Array.isArray(t)))
                            for (let e = 0, n = t.length; e < n; e++) {
                                const n = t[e];
                                i.shapes.push(n.uuid);
                            }
                        else i.shapes.push(t.uuid);
                        return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i;
                    })(this.parameters.shapes, this.parameters.options, t);
                }
                static fromJSON(t, e) {
                    const i = [];
                    for (let n = 0, s = t.shapes.length; n < s; n++) {
                        const s = e[t.shapes[n]];
                        i.push(s);
                    }
                    const n = t.options.extrudePath;
                    return void 0 !== n && (t.options.extrudePath = new Za[n.type]().fromJSON(n)), new bo(i, t.options);
                }
            }
            const So = {
                generateTopUV: function (t, e, i, n, s) {
                    const r = e[3 * i],
                        a = e[3 * i + 1],
                        o = e[3 * n],
                        l = e[3 * n + 1],
                        c = e[3 * s],
                        h = e[3 * s + 1];
                    return [new mt(r, a), new mt(o, l), new mt(c, h)];
                },
                generateSideWallUV: function (t, e, i, n, s, r) {
                    const a = e[3 * i],
                        o = e[3 * i + 1],
                        l = e[3 * i + 2],
                        c = e[3 * n],
                        h = e[3 * n + 1],
                        u = e[3 * n + 2],
                        d = e[3 * s],
                        p = e[3 * s + 1],
                        A = e[3 * s + 2],
                        g = e[3 * r],
                        m = e[3 * r + 1],
                        f = e[3 * r + 2];
                    return Math.abs(o - h) < Math.abs(a - c) ? [new mt(a, 1 - l), new mt(c, 1 - u), new mt(d, 1 - A), new mt(g, 1 - f)] : [new mt(o, 1 - l), new mt(h, 1 - u), new mt(p, 1 - A), new mt(m, 1 - f)];
                },
            };
            class Bo extends ui {
                constructor(t, e = 12) {
                    super(), (this.type = "ShapeGeometry"), (this.parameters = { shapes: t, curveSegments: e });
                    const i = [],
                        n = [],
                        s = [],
                        r = [];
                    let a = 0,
                        o = 0;
                    if (!1 === Array.isArray(t)) l(t);
                    else for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);
                    function l(t) {
                        const a = n.length / 3,
                            l = t.extractPoints(e);
                        let c = l.shape;
                        const h = l.holes;
                        !1 === Co.isClockWise(c) && (c = c.reverse());
                        for (let t = 0, e = h.length; t < e; t++) {
                            const e = h[t];
                            !0 === Co.isClockWise(e) && (h[t] = e.reverse());
                        }
                        const u = Co.triangulateShape(c, h);
                        for (let t = 0, e = h.length; t < e; t++) {
                            const e = h[t];
                            c = c.concat(e);
                        }
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            n.push(e.x, e.y, 0), s.push(0, 0, 1), r.push(e.x, e.y);
                        }
                        for (let t = 0, e = u.length; t < e; t++) {
                            const e = u[t],
                                n = e[0] + a,
                                s = e[1] + a,
                                r = e[2] + a;
                            i.push(n, s, r), (o += 3);
                        }
                    }
                    this.setIndex(i), this.setAttribute("position", new ii(n, 3)), this.setAttribute("normal", new ii(s, 3)), this.setAttribute("uv", new ii(r, 2));
                }
                toJSON() {
                    const t = super.toJSON();
                    return (function (t, e) {
                        if (((e.shapes = []), Array.isArray(t)))
                            for (let i = 0, n = t.length; i < n; i++) {
                                const n = t[i];
                                e.shapes.push(n.uuid);
                            }
                        else e.shapes.push(t.uuid);
                        return e;
                    })(this.parameters.shapes, t);
                }
                static fromJSON(t, e) {
                    const i = [];
                    for (let n = 0, s = t.shapes.length; n < s; n++) {
                        const s = e[t.shapes[n]];
                        i.push(s);
                    }
                    return new Bo(i, t.curveSegments);
                }
            }
            class To extends ze {
                constructor(t) {
                    super(), (this.type = "ShadowMaterial"), (this.color = new Je(0)), (this.transparent = !0), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this;
                }
            }
            To.prototype.isShadowMaterial = !0;
            class Lo extends ze {
                constructor(t) {
                    super(), (this.defines = { STANDARD: "" }), (this.type = "MeshStandardMaterial"), (this.color = new Je(16777215)), (this.roughness = 1), (this.metalness = 0), (this.map = null), (this.lightMap = null), (this.lightMapIntensity = 1), (this.aoMap = null), (this.aoMapIntensity = 1), (this.emissive = new Je(0)), (this.emissiveIntensity = 1), (this.emissiveMap = null), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new mt(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.roughnessMap = null), (this.metalnessMap = null), (this.alphaMap = null), (this.envMap = null), (this.envMapIntensity = 1), (this.refractionRatio = 0.98), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.wireframeLinecap = "round"), (this.wireframeLinejoin = "round"), (this.flatShading = !1), this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), (this.defines = { STANDARD: "" }), this.color.copy(t.color), (this.roughness = t.roughness), (this.metalness = t.metalness), (this.map = t.map), (this.lightMap = t.lightMap), (this.lightMapIntensity = t.lightMapIntensity), (this.aoMap = t.aoMap), (this.aoMapIntensity = t.aoMapIntensity), this.emissive.copy(t.emissive), (this.emissiveMap = t.emissiveMap), (this.emissiveIntensity = t.emissiveIntensity), (this.bumpMap = t.bumpMap), (this.bumpScale = t.bumpScale), (this.normalMap = t.normalMap), (this.normalMapType = t.normalMapType), this.normalScale.copy(t.normalScale), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.roughnessMap = t.roughnessMap), (this.metalnessMap = t.metalnessMap), (this.alphaMap = t.alphaMap), (this.envMap = t.envMap), (this.envMapIntensity = t.envMapIntensity), (this.refractionRatio = t.refractionRatio), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.wireframeLinecap = t.wireframeLinecap), (this.wireframeLinejoin = t.wireframeLinejoin), (this.flatShading = t.flatShading), this;
                }
            }
            Lo.prototype.isMeshStandardMaterial = !0;
            class Do extends Lo {
                constructor(t) {
                    super(),
                        (this.defines = { STANDARD: "", PHYSICAL: "" }),
                        (this.type = "MeshPhysicalMaterial"),
                        (this.clearcoat = 0),
                        (this.clearcoatMap = null),
                        (this.clearcoatRoughness = 0),
                        (this.clearcoatRoughnessMap = null),
                        (this.clearcoatNormalScale = new mt(1, 1)),
                        (this.clearcoatNormalMap = null),
                        (this.reflectivity = 0.5),
                        Object.defineProperty(this, "ior", {
                            get: function () {
                                return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
                            },
                            set: function (t) {
                                this.reflectivity = ct((2.5 * (t - 1)) / (t + 1), 0, 1);
                            },
                        }),
                        (this.sheen = null),
                        (this.transmission = 0),
                        (this.transmissionMap = null),
                        (this.thickness = 0.01),
                        (this.thicknessMap = null),
                        (this.attenuationDistance = 0),
                        (this.attenuationTint = new Je(1, 1, 1)),
                        (this.specularIntensity = 1),
                        (this.specularIntensityMap = null),
                        (this.specularTint = new Je(1, 1, 1)),
                        (this.specularTintMap = null),
                        this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), (this.defines = { STANDARD: "", PHYSICAL: "" }), (this.clearcoat = t.clearcoat), (this.clearcoatMap = t.clearcoatMap), (this.clearcoatRoughness = t.clearcoatRoughness), (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap), (this.clearcoatNormalMap = t.clearcoatNormalMap), this.clearcoatNormalScale.copy(t.clearcoatNormalScale), (this.reflectivity = t.reflectivity), t.sheen ? (this.sheen = (this.sheen || new Je()).copy(t.sheen)) : (this.sheen = null), (this.transmission = t.transmission), (this.transmissionMap = t.transmissionMap), (this.thickness = t.thickness), (this.thicknessMap = t.thicknessMap), (this.attenuationDistance = t.attenuationDistance), this.attenuationTint.copy(t.attenuationTint), (this.specularIntensity = t.specularIntensity), (this.specularIntensityMap = t.specularIntensityMap), this.specularTint.copy(t.specularTint), (this.specularTintMap = t.specularTintMap), this;
                }
            }
            (Do.prototype.isMeshPhysicalMaterial = !0),
                (class extends ze {
                    constructor(t) {
                        super(), (this.type = "MeshPhongMaterial"), (this.color = new Je(16777215)), (this.specular = new Je(1118481)), (this.shininess = 30), (this.map = null), (this.lightMap = null), (this.lightMapIntensity = 1), (this.aoMap = null), (this.aoMapIntensity = 1), (this.emissive = new Je(0)), (this.emissiveIntensity = 1), (this.emissiveMap = null), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new mt(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.specularMap = null), (this.alphaMap = null), (this.envMap = null), (this.combine = 0), (this.reflectivity = 1), (this.refractionRatio = 0.98), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.wireframeLinecap = "round"), (this.wireframeLinejoin = "round"), (this.flatShading = !1), this.setValues(t);
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), (this.shininess = t.shininess), (this.map = t.map), (this.lightMap = t.lightMap), (this.lightMapIntensity = t.lightMapIntensity), (this.aoMap = t.aoMap), (this.aoMapIntensity = t.aoMapIntensity), this.emissive.copy(t.emissive), (this.emissiveMap = t.emissiveMap), (this.emissiveIntensity = t.emissiveIntensity), (this.bumpMap = t.bumpMap), (this.bumpScale = t.bumpScale), (this.normalMap = t.normalMap), (this.normalMapType = t.normalMapType), this.normalScale.copy(t.normalScale), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.specularMap = t.specularMap), (this.alphaMap = t.alphaMap), (this.envMap = t.envMap), (this.combine = t.combine), (this.reflectivity = t.reflectivity), (this.refractionRatio = t.refractionRatio), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.wireframeLinecap = t.wireframeLinecap), (this.wireframeLinejoin = t.wireframeLinejoin), (this.flatShading = t.flatShading), this;
                    }
                }.prototype.isMeshPhongMaterial = !0),
                (class extends ze {
                    constructor(t) {
                        super(), (this.defines = { TOON: "" }), (this.type = "MeshToonMaterial"), (this.color = new Je(16777215)), (this.map = null), (this.gradientMap = null), (this.lightMap = null), (this.lightMapIntensity = 1), (this.aoMap = null), (this.aoMapIntensity = 1), (this.emissive = new Je(0)), (this.emissiveIntensity = 1), (this.emissiveMap = null), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new mt(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.alphaMap = null), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.wireframeLinecap = "round"), (this.wireframeLinejoin = "round"), this.setValues(t);
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.gradientMap = t.gradientMap), (this.lightMap = t.lightMap), (this.lightMapIntensity = t.lightMapIntensity), (this.aoMap = t.aoMap), (this.aoMapIntensity = t.aoMapIntensity), this.emissive.copy(t.emissive), (this.emissiveMap = t.emissiveMap), (this.emissiveIntensity = t.emissiveIntensity), (this.bumpMap = t.bumpMap), (this.bumpScale = t.bumpScale), (this.normalMap = t.normalMap), (this.normalMapType = t.normalMapType), this.normalScale.copy(t.normalScale), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.alphaMap = t.alphaMap), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.wireframeLinecap = t.wireframeLinecap), (this.wireframeLinejoin = t.wireframeLinejoin), this;
                    }
                }.prototype.isMeshToonMaterial = !0),
                (class extends ze {
                    constructor(t) {
                        super(), (this.type = "MeshNormalMaterial"), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new mt(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.fog = !1), (this.flatShading = !1), this.setValues(t);
                    }
                    copy(t) {
                        return super.copy(t), (this.bumpMap = t.bumpMap), (this.bumpScale = t.bumpScale), (this.normalMap = t.normalMap), (this.normalMapType = t.normalMapType), this.normalScale.copy(t.normalScale), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.flatShading = t.flatShading), this;
                    }
                }.prototype.isMeshNormalMaterial = !0),
                (class extends ze {
                    constructor(t) {
                        super(), (this.type = "MeshLambertMaterial"), (this.color = new Je(16777215)), (this.map = null), (this.lightMap = null), (this.lightMapIntensity = 1), (this.aoMap = null), (this.aoMapIntensity = 1), (this.emissive = new Je(0)), (this.emissiveIntensity = 1), (this.emissiveMap = null), (this.specularMap = null), (this.alphaMap = null), (this.envMap = null), (this.combine = 0), (this.reflectivity = 1), (this.refractionRatio = 0.98), (this.wireframe = !1), (this.wireframeLinewidth = 1), (this.wireframeLinecap = "round"), (this.wireframeLinejoin = "round"), this.setValues(t);
                    }
                    copy(t) {
                        return super.copy(t), this.color.copy(t.color), (this.map = t.map), (this.lightMap = t.lightMap), (this.lightMapIntensity = t.lightMapIntensity), (this.aoMap = t.aoMap), (this.aoMapIntensity = t.aoMapIntensity), this.emissive.copy(t.emissive), (this.emissiveMap = t.emissiveMap), (this.emissiveIntensity = t.emissiveIntensity), (this.specularMap = t.specularMap), (this.alphaMap = t.alphaMap), (this.envMap = t.envMap), (this.combine = t.combine), (this.reflectivity = t.reflectivity), (this.refractionRatio = t.refractionRatio), (this.wireframe = t.wireframe), (this.wireframeLinewidth = t.wireframeLinewidth), (this.wireframeLinecap = t.wireframeLinecap), (this.wireframeLinejoin = t.wireframeLinejoin), this;
                    }
                }.prototype.isMeshLambertMaterial = !0),
                (class extends ze {
                    constructor(t) {
                        super(), (this.defines = { MATCAP: "" }), (this.type = "MeshMatcapMaterial"), (this.color = new Je(16777215)), (this.matcap = null), (this.map = null), (this.bumpMap = null), (this.bumpScale = 1), (this.normalMap = null), (this.normalMapType = 0), (this.normalScale = new mt(1, 1)), (this.displacementMap = null), (this.displacementScale = 1), (this.displacementBias = 0), (this.alphaMap = null), (this.flatShading = !1), this.setValues(t);
                    }
                    copy(t) {
                        return super.copy(t), (this.defines = { MATCAP: "" }), this.color.copy(t.color), (this.matcap = t.matcap), (this.map = t.map), (this.bumpMap = t.bumpMap), (this.bumpScale = t.bumpScale), (this.normalMap = t.normalMap), (this.normalMapType = t.normalMapType), this.normalScale.copy(t.normalScale), (this.displacementMap = t.displacementMap), (this.displacementScale = t.displacementScale), (this.displacementBias = t.displacementBias), (this.alphaMap = t.alphaMap), (this.flatShading = t.flatShading), this;
                    }
                }.prototype.isMeshMatcapMaterial = !0),
                (class extends ga {
                    constructor(t) {
                        super(), (this.type = "LineDashedMaterial"), (this.scale = 1), (this.dashSize = 3), (this.gapSize = 1), this.setValues(t);
                    }
                    copy(t) {
                        return super.copy(t), (this.scale = t.scale), (this.dashSize = t.dashSize), (this.gapSize = t.gapSize), this;
                    }
                }.prototype.isLineDashedMaterial = !0);
            const Qo = {
                arraySlice: function (t, e, i) {
                    return Qo.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i);
                },
                convertArray: function (t, e, i) {
                    return !t || (!i && t.constructor === e) ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t);
                },
                isTypedArray: function (t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView);
                },
                getKeyframeOrder: function (t) {
                    const e = t.length,
                        i = new Array(e);
                    for (let t = 0; t !== e; ++t) i[t] = t;
                    return (
                        i.sort(function (e, i) {
                            return t[e] - t[i];
                        }),
                        i
                    );
                },
                sortedArray: function (t, e, i) {
                    const n = t.length,
                        s = new t.constructor(n);
                    for (let r = 0, a = 0; a !== n; ++r) {
                        const n = i[r] * e;
                        for (let i = 0; i !== e; ++i) s[a++] = t[n + i];
                    }
                    return s;
                },
                flattenJSON: function (t, e, i, n) {
                    let s = 1,
                        r = t[0];
                    for (; void 0 !== r && void 0 === r[n]; ) r = t[s++];
                    if (void 0 === r) return;
                    let a = r[n];
                    if (void 0 !== a)
                        if (Array.isArray(a))
                            do {
                                (a = r[n]), void 0 !== a && (e.push(r.time), i.push.apply(i, a)), (r = t[s++]);
                            } while (void 0 !== r);
                        else if (void 0 !== a.toArray)
                            do {
                                (a = r[n]), void 0 !== a && (e.push(r.time), a.toArray(i, i.length)), (r = t[s++]);
                            } while (void 0 !== r);
                        else
                            do {
                                (a = r[n]), void 0 !== a && (e.push(r.time), i.push(a)), (r = t[s++]);
                            } while (void 0 !== r);
                },
                subclip: function (t, e, i, n, s = 30) {
                    const r = t.clone();
                    r.name = e;
                    const a = [];
                    for (let t = 0; t < r.tracks.length; ++t) {
                        const e = r.tracks[t],
                            o = e.getValueSize(),
                            l = [],
                            c = [];
                        for (let t = 0; t < e.times.length; ++t) {
                            const r = e.times[t] * s;
                            if (!(r < i || r >= n)) {
                                l.push(e.times[t]);
                                for (let i = 0; i < o; ++i) c.push(e.values[t * o + i]);
                            }
                        }
                        0 !== l.length && ((e.times = Qo.convertArray(l, e.times.constructor)), (e.values = Qo.convertArray(c, e.values.constructor)), a.push(e));
                    }
                    r.tracks = a;
                    let o = 1 / 0;
                    for (let t = 0; t < r.tracks.length; ++t) o > r.tracks[t].times[0] && (o = r.tracks[t].times[0]);
                    for (let t = 0; t < r.tracks.length; ++t) r.tracks[t].shift(-1 * o);
                    return r.resetDuration(), r;
                },
                makeClipAdditive: function (t, e = 0, i = t, n = 30) {
                    n <= 0 && (n = 30);
                    const s = i.tracks.length,
                        r = e / n;
                    for (let e = 0; e < s; ++e) {
                        const n = i.tracks[e],
                            s = n.ValueTypeName;
                        if ("bool" === s || "string" === s) continue;
                        const a = t.tracks.find(function (t) {
                            return t.name === n.name && t.ValueTypeName === s;
                        });
                        if (void 0 === a) continue;
                        let o = 0;
                        const l = n.getValueSize();
                        n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
                        let c = 0;
                        const h = a.getValueSize();
                        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
                        const u = n.times.length - 1;
                        let d;
                        if (r <= n.times[0]) {
                            const t = o,
                                e = l - o;
                            d = Qo.arraySlice(n.values, t, e);
                        } else if (r >= n.times[u]) {
                            const t = u * l + o,
                                e = t + l - o;
                            d = Qo.arraySlice(n.values, t, e);
                        } else {
                            const t = n.createInterpolant(),
                                e = o,
                                i = l - o;
                            t.evaluate(r), (d = Qo.arraySlice(t.resultBuffer, e, i));
                        }
                        "quaternion" === s && new Et().fromArray(d).normalize().conjugate().toArray(d);
                        const p = a.times.length;
                        for (let t = 0; t < p; ++t) {
                            const e = t * h + c;
                            if ("quaternion" === s) Et.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                            else {
                                const t = h - 2 * c;
                                for (let i = 0; i < t; ++i) a.values[e + i] -= d[i];
                            }
                        }
                    }
                    return (t.blendMode = 2501), t;
                },
            };
            class Ro {
                constructor(t, e, i, n) {
                    (this.parameterPositions = t), (this._cachedIndex = 0), (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)), (this.sampleValues = e), (this.valueSize = i), (this.settings = null), (this.DefaultSettings_ = {});
                }
                evaluate(t) {
                    const e = this.parameterPositions;
                    let i = this._cachedIndex,
                        n = e[i],
                        s = e[i - 1];
                    t: {
                        e: {
                            let r;
                            i: {
                                n: if (!(t < n)) {
                                    for (let r = i + 2; ; ) {
                                        if (void 0 === n) {
                                            if (t < s) break n;
                                            return (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, t, s);
                                        }
                                        if (i === r) break;
                                        if (((s = n), (n = e[++i]), t < n)) break e;
                                    }
                                    r = e.length;
                                    break i;
                                }
                                if (t >= s) break t;
                                {
                                    const a = e[1];
                                    t < a && ((i = 2), (s = a));
                                    for (let r = i - 2; ; ) {
                                        if (void 0 === s) return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
                                        if (i === r) break;
                                        if (((n = s), (s = e[--i - 1]), t >= s)) break e;
                                    }
                                    (r = i), (i = 0);
                                }
                            }
                            for (; i < r; ) {
                                const n = (i + r) >>> 1;
                                t < e[n] ? (r = n) : (i = n + 1);
                            }
                            if (((n = e[i]), (s = e[i - 1]), void 0 === s)) return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
                            if (void 0 === n) return (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, s, t);
                        }
                        (this._cachedIndex = i), this.intervalChanged_(i, s, n);
                    }
                    return this.interpolate_(i, s, t, n);
                }
                getSettings_() {
                    return this.settings || this.DefaultSettings_;
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        s = t * n;
                    for (let t = 0; t !== n; ++t) e[t] = i[s + t];
                    return e;
                }
                interpolate_() {
                    throw new Error("call to abstract method");
                }
                intervalChanged_() {}
            }
            (Ro.prototype.beforeStart_ = Ro.prototype.copySampleValue_), (Ro.prototype.afterEnd_ = Ro.prototype.copySampleValue_);
            class Po extends Ro {
                constructor(t, e, i, n) {
                    super(t, e, i, n), (this._weightPrev = -0), (this._offsetPrev = -0), (this._weightNext = -0), (this._offsetNext = -0), (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
                }
                intervalChanged_(t, e, i) {
                    const n = this.parameterPositions;
                    let s = t - 2,
                        r = t + 1,
                        a = n[s],
                        o = n[r];
                    if (void 0 === a)
                        switch (this.getSettings_().endingStart) {
                            case 2401:
                                (s = t), (a = 2 * e - i);
                                break;
                            case 2402:
                                (s = n.length - 2), (a = e + n[s] - n[s + 1]);
                                break;
                            default:
                                (s = t), (a = i);
                        }
                    if (void 0 === o)
                        switch (this.getSettings_().endingEnd) {
                            case 2401:
                                (r = t), (o = 2 * i - e);
                                break;
                            case 2402:
                                (r = 1), (o = i + n[1] - n[0]);
                                break;
                            default:
                                (r = t - 1), (o = e);
                        }
                    const l = 0.5 * (i - e),
                        c = this.valueSize;
                    (this._weightPrev = l / (e - a)), (this._weightNext = l / (o - i)), (this._offsetPrev = s * c), (this._offsetNext = r * c);
                }
                interpolate_(t, e, i, n) {
                    const s = this.resultBuffer,
                        r = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        l = o - a,
                        c = this._offsetPrev,
                        h = this._offsetNext,
                        u = this._weightPrev,
                        d = this._weightNext,
                        p = (i - e) / (n - e),
                        A = p * p,
                        g = A * p,
                        m = -u * g + 2 * u * A - u * p,
                        f = (1 + u) * g + (-1.5 - 2 * u) * A + (-0.5 + u) * p + 1,
                        v = (-1 - d) * g + (1.5 + d) * A + 0.5 * p,
                        y = d * g - d * A;
                    for (let t = 0; t !== a; ++t) s[t] = m * r[c + t] + f * r[l + t] + v * r[o + t] + y * r[h + t];
                    return s;
                }
            }
            class No extends Ro {
                constructor(t, e, i, n) {
                    super(t, e, i, n);
                }
                interpolate_(t, e, i, n) {
                    const s = this.resultBuffer,
                        r = this.sampleValues,
                        a = this.valueSize,
                        o = t * a,
                        l = o - a,
                        c = (i - e) / (n - e),
                        h = 1 - c;
                    for (let t = 0; t !== a; ++t) s[t] = r[l + t] * h + r[o + t] * c;
                    return s;
                }
            }
            class Fo extends Ro {
                constructor(t, e, i, n) {
                    super(t, e, i, n);
                }
                interpolate_(t) {
                    return this.copySampleValue_(t - 1);
                }
            }
            class Uo {
                constructor(t, e, i, n) {
                    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                    (this.name = t), (this.times = Qo.convertArray(e, this.TimeBufferType)), (this.values = Qo.convertArray(i, this.ValueBufferType)), this.setInterpolation(n || this.DefaultInterpolation);
                }
                static toJSON(t) {
                    const e = t.constructor;
                    let i;
                    if (e.toJSON !== this.toJSON) i = e.toJSON(t);
                    else {
                        i = { name: t.name, times: Qo.convertArray(t.times, Array), values: Qo.convertArray(t.values, Array) };
                        const e = t.getInterpolation();
                        e !== t.DefaultInterpolation && (i.interpolation = e);
                    }
                    return (i.type = t.ValueTypeName), i;
                }
                InterpolantFactoryMethodDiscrete(t) {
                    return new Fo(this.times, this.values, this.getValueSize(), t);
                }
                InterpolantFactoryMethodLinear(t) {
                    return new No(this.times, this.values, this.getValueSize(), t);
                }
                InterpolantFactoryMethodSmooth(t) {
                    return new Po(this.times, this.values, this.getValueSize(), t);
                }
                setInterpolation(t) {
                    let e;
                    switch (t) {
                        case 2300:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case 2301:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case 2302:
                            e = this.InterpolantFactoryMethodSmooth;
                    }
                    if (void 0 === e) {
                        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation);
                        }
                        return this;
                    }
                    return (this.createInterpolant = e), this;
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return 2300;
                        case this.InterpolantFactoryMethodLinear:
                            return 2301;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302;
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length;
                }
                shift(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let i = 0, n = e.length; i !== n; ++i) e[i] += t;
                    }
                    return this;
                }
                scale(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t;
                    }
                    return this;
                }
                trim(t, e) {
                    const i = this.times,
                        n = i.length;
                    let s = 0,
                        r = n - 1;
                    for (; s !== n && i[s] < t; ) ++s;
                    for (; -1 !== r && i[r] > e; ) --r;
                    if ((++r, 0 !== s || r !== n)) {
                        s >= r && ((r = Math.max(r, 1)), (s = r - 1));
                        const t = this.getValueSize();
                        (this.times = Qo.arraySlice(i, s, r)), (this.values = Qo.arraySlice(this.values, s * t, r * t));
                    }
                    return this;
                }
                validate() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) != 0 && (t = !1);
                    const i = this.times,
                        n = this.values,
                        s = i.length;
                    0 === s && (t = !1);
                    let r = null;
                    for (let e = 0; e !== s; e++) {
                        const n = i[e];
                        if ("number" == typeof n && isNaN(n)) {
                            t = !1;
                            break;
                        }
                        if (null !== r && r > n) {
                            t = !1;
                            break;
                        }
                        r = n;
                    }
                    if (void 0 !== n && Qo.isTypedArray(n))
                        for (let e = 0, i = n.length; e !== i; ++e) {
                            const i = n[e];
                            if (isNaN(i)) {
                                t = !1;
                                break;
                            }
                        }
                    return t;
                }
                optimize() {
                    const t = Qo.arraySlice(this.times),
                        e = Qo.arraySlice(this.values),
                        i = this.getValueSize(),
                        n = 2302 === this.getInterpolation(),
                        s = t.length - 1;
                    let r = 1;
                    for (let a = 1; a < s; ++a) {
                        let s = !1;
                        const o = t[a];
                        if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                            if (n) s = !0;
                            else {
                                const t = a * i,
                                    n = t - i,
                                    r = t + i;
                                for (let a = 0; a !== i; ++a) {
                                    const i = e[t + a];
                                    if (i !== e[n + a] || i !== e[r + a]) {
                                        s = !0;
                                        break;
                                    }
                                }
                            }
                        if (s) {
                            if (a !== r) {
                                t[r] = t[a];
                                const n = a * i,
                                    s = r * i;
                                for (let t = 0; t !== i; ++t) e[s + t] = e[n + t];
                            }
                            ++r;
                        }
                    }
                    if (s > 0) {
                        t[r] = t[s];
                        for (let t = s * i, n = r * i, a = 0; a !== i; ++a) e[n + a] = e[t + a];
                        ++r;
                    }
                    return r !== t.length ? ((this.times = Qo.arraySlice(t, 0, r)), (this.values = Qo.arraySlice(e, 0, r * i))) : ((this.times = t), (this.values = e)), this;
                }
                clone() {
                    const t = Qo.arraySlice(this.times, 0),
                        e = Qo.arraySlice(this.values, 0),
                        i = new (0, this.constructor)(this.name, t, e);
                    return (i.createInterpolant = this.createInterpolant), i;
                }
            }
            (Uo.prototype.TimeBufferType = Float32Array), (Uo.prototype.ValueBufferType = Float32Array), (Uo.prototype.DefaultInterpolation = 2301);
            class ko extends Uo {}
            (ko.prototype.ValueTypeName = "bool"), (ko.prototype.ValueBufferType = Array), (ko.prototype.DefaultInterpolation = 2300), (ko.prototype.InterpolantFactoryMethodLinear = void 0), (ko.prototype.InterpolantFactoryMethodSmooth = void 0);
            class Oo extends Uo {}
            Oo.prototype.ValueTypeName = "color";
            class Go extends Uo {}
            Go.prototype.ValueTypeName = "number";
            class zo extends Ro {
                constructor(t, e, i, n) {
                    super(t, e, i, n);
                }
                interpolate_(t, e, i, n) {
                    const s = this.resultBuffer,
                        r = this.sampleValues,
                        a = this.valueSize,
                        o = (i - e) / (n - e);
                    let l = t * a;
                    for (let t = l + a; l !== t; l += 4) Et.slerpFlat(s, 0, r, l - a, r, l, o);
                    return s;
                }
            }
            class Vo extends Uo {
                InterpolantFactoryMethodLinear(t) {
                    return new zo(this.times, this.values, this.getValueSize(), t);
                }
            }
            (Vo.prototype.ValueTypeName = "quaternion"), (Vo.prototype.DefaultInterpolation = 2301), (Vo.prototype.InterpolantFactoryMethodSmooth = void 0);
            class Ho extends Uo {}
            (Ho.prototype.ValueTypeName = "string"), (Ho.prototype.ValueBufferType = Array), (Ho.prototype.DefaultInterpolation = 2300), (Ho.prototype.InterpolantFactoryMethodLinear = void 0), (Ho.prototype.InterpolantFactoryMethodSmooth = void 0);
            class Wo extends Uo {}
            Wo.prototype.ValueTypeName = "vector";
            class qo {
                constructor(t, e = -1, i, n = 2500) {
                    (this.name = t), (this.tracks = i), (this.duration = e), (this.blendMode = n), (this.uuid = lt()), this.duration < 0 && this.resetDuration();
                }
                static parse(t) {
                    const e = [],
                        i = t.tracks,
                        n = 1 / (t.fps || 1);
                    for (let t = 0, s = i.length; t !== s; ++t) e.push(jo(i[t]).scale(n));
                    const s = new this(t.name, t.duration, e, t.blendMode);
                    return (s.uuid = t.uuid), s;
                }
                static toJSON(t) {
                    const e = [],
                        i = t.tracks,
                        n = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
                    for (let t = 0, n = i.length; t !== n; ++t) e.push(Uo.toJSON(i[t]));
                    return n;
                }
                static CreateFromMorphTargetSequence(t, e, i, n) {
                    const s = e.length,
                        r = [];
                    for (let t = 0; t < s; t++) {
                        let a = [],
                            o = [];
                        a.push((t + s - 1) % s, t, (t + 1) % s), o.push(0, 1, 0);
                        const l = Qo.getKeyframeOrder(a);
                        (a = Qo.sortedArray(a, 1, l)), (o = Qo.sortedArray(o, 1, l)), n || 0 !== a[0] || (a.push(s), o.push(o[0])), r.push(new Go(".morphTargetInfluences[" + e[t].name + "]", a, o).scale(1 / i));
                    }
                    return new this(t, -1, r);
                }
                static findByName(t, e) {
                    let i = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        i = (e.geometry && e.geometry.animations) || e.animations;
                    }
                    for (let t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
                    return null;
                }
                static CreateClipsFromMorphTargetSequences(t, e, i) {
                    const n = {},
                        s = /^([\w-]*?)([\d]+)$/;
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e],
                            r = i.name.match(s);
                        if (r && r.length > 1) {
                            const t = r[1];
                            let e = n[t];
                            e || (n[t] = e = []), e.push(i);
                        }
                    }
                    const r = [];
                    for (const t in n) r.push(this.CreateFromMorphTargetSequence(t, n[t], e, i));
                    return r;
                }
                static parseAnimation(t, e) {
                    if (!t) return null;
                    const i = function (t, e, i, n, s) {
                            if (0 !== i.length) {
                                const r = [],
                                    a = [];
                                Qo.flattenJSON(i, r, a, n), 0 !== r.length && s.push(new t(e, r, a));
                            }
                        },
                        n = [],
                        s = t.name || "default",
                        r = t.fps || 30,
                        a = t.blendMode;
                    let o = t.length || -1;
                    const l = t.hierarchy || [];
                    for (let t = 0; t < l.length; t++) {
                        const s = l[t].keys;
                        if (s && 0 !== s.length)
                            if (s[0].morphTargets) {
                                const t = {};
                                let e;
                                for (e = 0; e < s.length; e++) if (s[e].morphTargets) for (let i = 0; i < s[e].morphTargets.length; i++) t[s[e].morphTargets[i]] = -1;
                                for (const i in t) {
                                    const t = [],
                                        r = [];
                                    for (let n = 0; n !== s[e].morphTargets.length; ++n) {
                                        const n = s[e];
                                        t.push(n.time), r.push(n.morphTarget === i ? 1 : 0);
                                    }
                                    n.push(new Go(".morphTargetInfluence[" + i + "]", t, r));
                                }
                                o = t.length * (r || 1);
                            } else {
                                const r = ".bones[" + e[t].name + "]";
                                i(Wo, r + ".position", s, "pos", n), i(Vo, r + ".quaternion", s, "rot", n), i(Wo, r + ".scale", s, "scl", n);
                            }
                    }
                    return 0 === n.length ? null : new this(s, o, n, a);
                }
                resetDuration() {
                    let t = 0;
                    for (let e = 0, i = this.tracks.length; e !== i; ++e) {
                        const i = this.tracks[e];
                        t = Math.max(t, i.times[i.times.length - 1]);
                    }
                    return (this.duration = t), this;
                }
                trim() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this;
                }
                validate() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t;
                }
                optimize() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this;
                }
                clone() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new this.constructor(this.name, this.duration, t, this.blendMode);
                }
                toJSON() {
                    return this.constructor.toJSON(this);
                }
            }
            function jo(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = (function (t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Go;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Wo;
                        case "color":
                            return Oo;
                        case "quaternion":
                            return Vo;
                        case "bool":
                        case "boolean":
                            return ko;
                        case "string":
                            return Ho;
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
                })(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        i = [];
                    Qo.flattenJSON(t.keys, e, i, "value"), (t.times = e), (t.values = i);
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation);
            }
            const Yo = {
                    enabled: !1,
                    files: {},
                    add: function (t, e) {
                        !1 !== this.enabled && (this.files[t] = e);
                    },
                    get: function (t) {
                        if (!1 !== this.enabled) return this.files[t];
                    },
                    remove: function (t) {
                        delete this.files[t];
                    },
                    clear: function () {
                        this.files = {};
                    },
                },
                Jo = new (class {
                    constructor(t, e, i) {
                        const n = this;
                        let s,
                            r = !1,
                            a = 0,
                            o = 0;
                        const l = [];
                        (this.onStart = void 0),
                            (this.onLoad = t),
                            (this.onProgress = e),
                            (this.onError = i),
                            (this.itemStart = function (t) {
                                o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), (r = !0);
                            }),
                            (this.itemEnd = function (t) {
                                a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && ((r = !1), void 0 !== n.onLoad && n.onLoad());
                            }),
                            (this.itemError = function (t) {
                                void 0 !== n.onError && n.onError(t);
                            }),
                            (this.resolveURL = function (t) {
                                return s ? s(t) : t;
                            }),
                            (this.setURLModifier = function (t) {
                                return (s = t), this;
                            }),
                            (this.addHandler = function (t, e) {
                                return l.push(t, e), this;
                            }),
                            (this.removeHandler = function (t) {
                                const e = l.indexOf(t);
                                return -1 !== e && l.splice(e, 2), this;
                            }),
                            (this.getHandler = function (t) {
                                for (let e = 0, i = l.length; e < i; e += 2) {
                                    const i = l[e],
                                        n = l[e + 1];
                                    if ((i.global && (i.lastIndex = 0), i.test(t))) return n;
                                }
                                return null;
                            });
                    }
                })();
            class Xo {
                constructor(t) {
                    (this.manager = void 0 !== t ? t : Jo), (this.crossOrigin = "anonymous"), (this.withCredentials = !1), (this.path = ""), (this.resourcePath = ""), (this.requestHeader = {});
                }
                load() {}
                loadAsync(t, e) {
                    const i = this;
                    return new Promise(function (n, s) {
                        i.load(t, n, e, s);
                    });
                }
                parse() {}
                setCrossOrigin(t) {
                    return (this.crossOrigin = t), this;
                }
                setWithCredentials(t) {
                    return (this.withCredentials = t), this;
                }
                setPath(t) {
                    return (this.path = t), this;
                }
                setResourcePath(t) {
                    return (this.resourcePath = t), this;
                }
                setRequestHeader(t) {
                    return (this.requestHeader = t), this;
                }
            }
            const Ko = {};
            class Zo extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
                    const s = this,
                        r = Yo.get(t);
                    if (void 0 !== r)
                        return (
                            s.manager.itemStart(t),
                            setTimeout(function () {
                                e && e(r), s.manager.itemEnd(t);
                            }, 0),
                            r
                        );
                    if (void 0 !== Ko[t]) return void Ko[t].push({ onLoad: e, onProgress: i, onError: n });
                    const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    let o;
                    if (a) {
                        const i = a[1],
                            r = !!a[2];
                        let o = a[3];
                        (o = decodeURIComponent(o)), r && (o = atob(o));
                        try {
                            let n;
                            const r = (this.responseType || "").toLowerCase();
                            switch (r) {
                                case "arraybuffer":
                                case "blob":
                                    const t = new Uint8Array(o.length);
                                    for (let e = 0; e < o.length; e++) t[e] = o.charCodeAt(e);
                                    n = "blob" === r ? new Blob([t.buffer], { type: i }) : t.buffer;
                                    break;
                                case "document":
                                    const e = new DOMParser();
                                    n = e.parseFromString(o, i);
                                    break;
                                case "json":
                                    n = JSON.parse(o);
                                    break;
                                default:
                                    n = o;
                            }
                            setTimeout(function () {
                                e && e(n), s.manager.itemEnd(t);
                            }, 0);
                        } catch (e) {
                            setTimeout(function () {
                                n && n(e), s.manager.itemError(t), s.manager.itemEnd(t);
                            }, 0);
                        }
                    } else {
                        (Ko[t] = []),
                            Ko[t].push({ onLoad: e, onProgress: i, onError: n }),
                            (o = new XMLHttpRequest()),
                            o.open("GET", t, !0),
                            o.addEventListener(
                                "load",
                                function (e) {
                                    const i = this.response,
                                        n = Ko[t];
                                    if ((delete Ko[t], 200 === this.status || 0 === this.status)) {
                                        this.status, Yo.add(t, i);
                                        for (let t = 0, e = n.length; t < e; t++) {
                                            const e = n[t];
                                            e.onLoad && e.onLoad(i);
                                        }
                                        s.manager.itemEnd(t);
                                    } else {
                                        for (let t = 0, i = n.length; t < i; t++) {
                                            const i = n[t];
                                            i.onError && i.onError(e);
                                        }
                                        s.manager.itemError(t), s.manager.itemEnd(t);
                                    }
                                },
                                !1,
                            ),
                            o.addEventListener(
                                "progress",
                                function (e) {
                                    const i = Ko[t];
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onProgress && n.onProgress(e);
                                    }
                                },
                                !1,
                            ),
                            o.addEventListener(
                                "error",
                                function (e) {
                                    const i = Ko[t];
                                    delete Ko[t];
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onError && n.onError(e);
                                    }
                                    s.manager.itemError(t), s.manager.itemEnd(t);
                                },
                                !1,
                            ),
                            o.addEventListener(
                                "abort",
                                function (e) {
                                    const i = Ko[t];
                                    delete Ko[t];
                                    for (let t = 0, n = i.length; t < n; t++) {
                                        const n = i[t];
                                        n.onError && n.onError(e);
                                    }
                                    s.manager.itemError(t), s.manager.itemEnd(t);
                                },
                                !1,
                            ),
                            void 0 !== this.responseType && (o.responseType = this.responseType),
                            void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
                            o.overrideMimeType && o.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (const t in this.requestHeader) o.setRequestHeader(t, this.requestHeader[t]);
                        o.send(null);
                    }
                    return s.manager.itemStart(t), o;
                }
                setResponseType(t) {
                    return (this.responseType = t), this;
                }
                setMimeType(t) {
                    return (this.mimeType = t), this;
                }
            }
            class $o extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    const s = this,
                        r = [],
                        a = new Qa(),
                        o = new Zo(this.manager);
                    o.setPath(this.path), o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setWithCredentials(s.withCredentials);
                    let l = 0;
                    function c(c) {
                        o.load(
                            t[c],
                            function (t) {
                                const i = s.parse(t, !0);
                                (r[c] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }), (l += 1), 6 === l && (1 === i.mipmapCount && (a.minFilter = 1006), (a.image = r), (a.format = i.format), (a.needsUpdate = !0), e && e(a));
                            },
                            i,
                            n,
                        );
                    }
                    if (Array.isArray(t)) for (let e = 0, i = t.length; e < i; ++e) c(e);
                    else
                        o.load(
                            t,
                            function (t) {
                                const i = s.parse(t, !0);
                                if (i.isCubemap) {
                                    const t = i.mipmaps.length / i.mipmapCount;
                                    for (let e = 0; e < t; e++) {
                                        r[e] = { mipmaps: [] };
                                        for (let t = 0; t < i.mipmapCount; t++) r[e].mipmaps.push(i.mipmaps[e * i.mipmapCount + t]), (r[e].format = i.format), (r[e].width = i.width), (r[e].height = i.height);
                                    }
                                    a.image = r;
                                } else (a.image.width = i.width), (a.image.height = i.height), (a.mipmaps = i.mipmaps);
                                1 === i.mipmapCount && (a.minFilter = 1006), (a.format = i.format), (a.needsUpdate = !0), e && e(a);
                            },
                            i,
                            n,
                        );
                    return a;
                }
            }
            class tl extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
                    const s = this,
                        r = Yo.get(t);
                    if (void 0 !== r)
                        return (
                            s.manager.itemStart(t),
                            setTimeout(function () {
                                e && e(r), s.manager.itemEnd(t);
                            }, 0),
                            r
                        );
                    const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    function o() {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), Yo.add(t, this), e && e(this), s.manager.itemEnd(t);
                    }
                    function l(e) {
                        a.removeEventListener("load", o, !1), a.removeEventListener("error", l, !1), n && n(e), s.manager.itemError(t), s.manager.itemEnd(t);
                    }
                    return a.addEventListener("load", o, !1), a.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(t), (a.src = t), a;
                }
            }
            class el extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    const s = new ki(),
                        r = new tl(this.manager);
                    r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
                    let a = 0;
                    function o(i) {
                        r.load(
                            t[i],
                            function (t) {
                                (s.images[i] = t), a++, 6 === a && ((s.needsUpdate = !0), e && e(s));
                            },
                            void 0,
                            n,
                        );
                    }
                    for (let e = 0; e < t.length; ++e) o(e);
                    return s;
                }
            }
            class il extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    const s = this,
                        r = new oa(),
                        a = new Zo(this.manager);
                    return (
                        a.setResponseType("arraybuffer"),
                        a.setRequestHeader(this.requestHeader),
                        a.setPath(this.path),
                        a.setWithCredentials(s.withCredentials),
                        a.load(
                            t,
                            function (t) {
                                const i = s.parse(t);
                                i && (void 0 !== i.image ? (r.image = i.image) : void 0 !== i.data && ((r.image.width = i.width), (r.image.height = i.height), (r.image.data = i.data)), (r.wrapS = void 0 !== i.wrapS ? i.wrapS : 1001), (r.wrapT = void 0 !== i.wrapT ? i.wrapT : 1001), (r.magFilter = void 0 !== i.magFilter ? i.magFilter : 1006), (r.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006), (r.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1), void 0 !== i.encoding && (r.encoding = i.encoding), void 0 !== i.flipY && (r.flipY = i.flipY), void 0 !== i.format && (r.format = i.format), void 0 !== i.type && (r.type = i.type), void 0 !== i.mipmaps && ((r.mipmaps = i.mipmaps), (r.minFilter = 1008)), 1 === i.mipmapCount && (r.minFilter = 1006), void 0 !== i.generateMipmaps && (r.generateMipmaps = i.generateMipmaps), (r.needsUpdate = !0), e && e(r, i));
                            },
                            i,
                            n,
                        ),
                        r
                    );
                }
            }
            class nl extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    const s = new wt(),
                        r = new tl(this.manager);
                    return (
                        r.setCrossOrigin(this.crossOrigin),
                        r.setPath(this.path),
                        r.load(
                            t,
                            function (i) {
                                s.image = i;
                                const n = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                                (s.format = n ? 1022 : 1023), (s.needsUpdate = !0), void 0 !== e && e(s);
                            },
                            i,
                            n,
                        ),
                        s
                    );
                }
            }
            class sl extends Ra {
                constructor() {
                    super(), (this.type = "CurvePath"), (this.curves = []), (this.autoClose = !1);
                }
                add(t) {
                    this.curves.push(t);
                }
                closePath() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Ya(e, t));
                }
                getPoint(t) {
                    const e = t * this.getLength(),
                        i = this.getCurveLengths();
                    let n = 0;
                    for (; n < i.length; ) {
                        if (i[n] >= e) {
                            const t = i[n] - e,
                                s = this.curves[n],
                                r = s.getLength(),
                                a = 0 === r ? 0 : 1 - t / r;
                            return s.getPointAt(a);
                        }
                        n++;
                    }
                    return null;
                }
                getLength() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1];
                }
                updateArcLengths() {
                    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let i = 0, n = this.curves.length; i < n; i++) (e += this.curves[i].getLength()), t.push(e);
                    return (this.cacheLengths = t), t;
                }
                getSpacedPoints(t = 40) {
                    const e = [];
                    for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
                    return this.autoClose && e.push(e[0]), e;
                }
                getPoints(t = 12) {
                    const e = [];
                    let i;
                    for (let n = 0, s = this.curves; n < s.length; n++) {
                        const r = s[n],
                            a = r && r.isEllipseCurve ? 2 * t : r && (r.isLineCurve || r.isLineCurve3) ? 1 : r && r.isSplineCurve ? t * r.points.length : t,
                            o = r.getPoints(a);
                        for (let t = 0; t < o.length; t++) {
                            const n = o[t];
                            (i && i.equals(n)) || (e.push(n), (i = n));
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
                }
                copy(t) {
                    super.copy(t), (this.curves = []);
                    for (let e = 0, i = t.curves.length; e < i; e++) {
                        const i = t.curves[e];
                        this.curves.push(i.clone());
                    }
                    return (this.autoClose = t.autoClose), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    (t.autoClose = this.autoClose), (t.curves = []);
                    for (let e = 0, i = this.curves.length; e < i; e++) {
                        const i = this.curves[e];
                        t.curves.push(i.toJSON());
                    }
                    return t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.autoClose = t.autoClose), (this.curves = []);
                    for (let e = 0, i = t.curves.length; e < i; e++) {
                        const i = t.curves[e];
                        this.curves.push(new Za[i.type]().fromJSON(i));
                    }
                    return this;
                }
            }
            class rl extends sl {
                constructor(t) {
                    super(), (this.type = "Path"), (this.currentPoint = new mt()), t && this.setFromPoints(t);
                }
                setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
                    return this;
                }
                moveTo(t, e) {
                    return this.currentPoint.set(t, e), this;
                }
                lineTo(t, e) {
                    const i = new Ya(this.currentPoint.clone(), new mt(t, e));
                    return this.curves.push(i), this.currentPoint.set(t, e), this;
                }
                quadraticCurveTo(t, e, i, n) {
                    const s = new Ja(this.currentPoint.clone(), new mt(t, e), new mt(i, n));
                    return this.curves.push(s), this.currentPoint.set(i, n), this;
                }
                bezierCurveTo(t, e, i, n, s, r) {
                    const a = new qa(this.currentPoint.clone(), new mt(t, e), new mt(i, n), new mt(s, r));
                    return this.curves.push(a), this.currentPoint.set(s, r), this;
                }
                splineThru(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                        i = new Ka(e);
                    return this.curves.push(i), this.currentPoint.copy(t[t.length - 1]), this;
                }
                arc(t, e, i, n, s, r) {
                    const a = this.currentPoint.x,
                        o = this.currentPoint.y;
                    return this.absarc(t + a, e + o, i, n, s, r), this;
                }
                absarc(t, e, i, n, s, r) {
                    return this.absellipse(t, e, i, i, n, s, r), this;
                }
                ellipse(t, e, i, n, s, r, a, o) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(t + l, e + c, i, n, s, r, a, o), this;
                }
                absellipse(t, e, i, n, s, r, a, o) {
                    const l = new Pa(t, e, i, n, s, r, a, o);
                    if (this.curves.length > 0) {
                        const t = l.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this;
                }
                copy(t) {
                    return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
                }
                toJSON() {
                    const t = super.toJSON();
                    return (t.currentPoint = this.currentPoint.toArray()), t;
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
                }
            }
            class al extends rl {
                constructor(t) {
                    super(t), (this.uuid = lt()), (this.type = "Shape"), (this.holes = []);
                }
                getPointsHoles(t) {
                    const e = [];
                    for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
                    return e;
                }
                extractPoints(t) {
                    return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
                }
                copy(t) {
                    super.copy(t), (this.holes = []);
                    for (let e = 0, i = t.holes.length; e < i; e++) {
                        const i = t.holes[e];
                        this.holes.push(i.clone());
                    }
                    return this;
                }
                toJSON() {
                    const t = super.toJSON();
                    (t.uuid = this.uuid), (t.holes = []);
                    for (let e = 0, i = this.holes.length; e < i; e++) {
                        const i = this.holes[e];
                        t.holes.push(i.toJSON());
                    }
                    return t;
                }
                fromJSON(t) {
                    super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
                    for (let e = 0, i = t.holes.length; e < i; e++) {
                        const i = t.holes[e];
                        this.holes.push(new rl().fromJSON(i));
                    }
                    return this;
                }
            }
            class ol extends Be {
                constructor(t, e = 1) {
                    super(), (this.type = "Light"), (this.color = new Je(t)), (this.intensity = e);
                }
                dispose() {}
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), (this.intensity = t.intensity), this;
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (e.object.color = this.color.getHex()), (e.object.intensity = this.intensity), void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e;
                }
            }
            (ol.prototype.isLight = !0),
                (class extends ol {
                    constructor(t, e, i) {
                        super(t, i), (this.type = "HemisphereLight"), this.position.copy(Be.DefaultUp), this.updateMatrix(), (this.groundColor = new Je(e));
                    }
                    copy(t) {
                        return ol.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
                    }
                }.prototype.isHemisphereLight = !0);
            const ll = new se(),
                cl = new bt(),
                hl = new bt();
            class ul {
                constructor(t) {
                    (this.camera = t), (this.bias = 0), (this.normalBias = 0), (this.radius = 1), (this.mapSize = new mt(512, 512)), (this.map = null), (this.mapPass = null), (this.matrix = new se()), (this.autoUpdate = !0), (this.needsUpdate = !1), (this._frustum = new ji()), (this._frameExtents = new mt(1, 1)), (this._viewportCount = 1), (this._viewports = [new It(0, 0, 1, 1)]);
                }
                getViewportCount() {
                    return this._viewportCount;
                }
                getFrustum() {
                    return this._frustum;
                }
                updateMatrices(t) {
                    const e = this.camera,
                        i = this.matrix;
                    cl.setFromMatrixPosition(t.matrixWorld), e.position.copy(cl), hl.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(hl), e.updateMatrixWorld(), ll.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ll), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(e.projectionMatrix), i.multiply(e.matrixWorldInverse);
                }
                getViewport(t) {
                    return this._viewports[t];
                }
                getFrameExtents() {
                    return this._frameExtents;
                }
                dispose() {
                    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
                }
                copy(t) {
                    return (this.camera = t.camera.clone()), (this.bias = t.bias), (this.radius = t.radius), this.mapSize.copy(t.mapSize), this;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                toJSON() {
                    const t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), (512 === this.mapSize.x && 512 === this.mapSize.y) || (t.mapSize = this.mapSize.toArray()), (t.camera = this.camera.toJSON(!1).object), delete t.camera.matrix, t;
                }
            }
            class dl extends ul {
                constructor() {
                    super(new Fi(50, 1, 0.5, 500)), (this.focus = 1);
                }
                updateMatrices(t) {
                    const e = this.camera,
                        i = 2 * ot * t.angle * this.focus,
                        n = this.mapSize.width / this.mapSize.height,
                        s = t.distance || e.far;
                    (i === e.fov && n === e.aspect && s === e.far) || ((e.fov = i), (e.aspect = n), (e.far = s), e.updateProjectionMatrix()), super.updateMatrices(t);
                }
                copy(t) {
                    return super.copy(t), (this.focus = t.focus), this;
                }
            }
            dl.prototype.isSpotLightShadow = !0;
            class pl extends ol {
                constructor(t, e, i = 0, n = Math.PI / 3, s = 0, r = 1) {
                    super(t, e), (this.type = "SpotLight"), this.position.copy(Be.DefaultUp), this.updateMatrix(), (this.target = new Be()), (this.distance = i), (this.angle = n), (this.penumbra = s), (this.decay = r), (this.shadow = new dl());
                }
                get power() {
                    return this.intensity * Math.PI;
                }
                set power(t) {
                    this.intensity = t / Math.PI;
                }
                dispose() {
                    this.shadow.dispose();
                }
                copy(t) {
                    return super.copy(t), (this.distance = t.distance), (this.angle = t.angle), (this.penumbra = t.penumbra), (this.decay = t.decay), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this;
                }
            }
            pl.prototype.isSpotLight = !0;
            const Al = new se(),
                gl = new bt(),
                ml = new bt();
            class fl extends ul {
                constructor() {
                    super(new Fi(90, 1, 0.5, 500)), (this._frameExtents = new mt(4, 2)), (this._viewportCount = 6), (this._viewports = [new It(2, 1, 1, 1), new It(0, 1, 1, 1), new It(3, 1, 1, 1), new It(1, 1, 1, 1), new It(3, 0, 1, 1), new It(1, 0, 1, 1)]), (this._cubeDirections = [new bt(1, 0, 0), new bt(-1, 0, 0), new bt(0, 0, 1), new bt(0, 0, -1), new bt(0, 1, 0), new bt(0, -1, 0)]), (this._cubeUps = [new bt(0, 1, 0), new bt(0, 1, 0), new bt(0, 1, 0), new bt(0, 1, 0), new bt(0, 0, 1), new bt(0, 0, -1)]);
                }
                updateMatrices(t, e = 0) {
                    const i = this.camera,
                        n = this.matrix,
                        s = t.distance || i.far;
                    s !== i.far && ((i.far = s), i.updateProjectionMatrix()), gl.setFromMatrixPosition(t.matrixWorld), i.position.copy(gl), ml.copy(i.position), ml.add(this._cubeDirections[e]), i.up.copy(this._cubeUps[e]), i.lookAt(ml), i.updateMatrixWorld(), n.makeTranslation(-gl.x, -gl.y, -gl.z), Al.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Al);
                }
            }
            fl.prototype.isPointLightShadow = !0;
            class vl extends ol {
                constructor(t, e, i = 0, n = 1) {
                    super(t, e), (this.type = "PointLight"), (this.distance = i), (this.decay = n), (this.shadow = new fl());
                }
                get power() {
                    return 4 * this.intensity * Math.PI;
                }
                set power(t) {
                    this.intensity = t / (4 * Math.PI);
                }
                dispose() {
                    this.shadow.dispose();
                }
                copy(t) {
                    return super.copy(t), (this.distance = t.distance), (this.decay = t.decay), (this.shadow = t.shadow.clone()), this;
                }
            }
            vl.prototype.isPointLight = !0;
            class yl extends ul {
                constructor() {
                    super(new on(-5, 5, 5, -5, 0.5, 500));
                }
            }
            yl.prototype.isDirectionalLightShadow = !0;
            class xl extends ol {
                constructor(t, e) {
                    super(t, e), (this.type = "DirectionalLight"), this.position.copy(Be.DefaultUp), this.updateMatrix(), (this.target = new Be()), (this.shadow = new yl());
                }
                dispose() {
                    this.shadow.dispose();
                }
                copy(t) {
                    return super.copy(t), (this.target = t.target.clone()), (this.shadow = t.shadow.clone()), this;
                }
            }
            (xl.prototype.isDirectionalLight = !0),
                (class extends ol {
                    constructor(t, e) {
                        super(t, e), (this.type = "AmbientLight");
                    }
                }.prototype.isAmbientLight = !0),
                (class extends ol {
                    constructor(t, e, i = 10, n = 10) {
                        super(t, e), (this.type = "RectAreaLight"), (this.width = i), (this.height = n);
                    }
                    copy(t) {
                        return super.copy(t), (this.width = t.width), (this.height = t.height), this;
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (e.object.width = this.width), (e.object.height = this.height), e;
                    }
                }.prototype.isRectAreaLight = !0);
            class wl {
                constructor() {
                    this.coefficients = [];
                    for (let t = 0; t < 9; t++) this.coefficients.push(new bt());
                }
                set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this;
                }
                zero() {
                    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this;
                }
                getAt(t, e) {
                    const i = t.x,
                        n = t.y,
                        s = t.z,
                        r = this.coefficients;
                    return e.copy(r[0]).multiplyScalar(0.282095), e.addScaledVector(r[1], 0.488603 * n), e.addScaledVector(r[2], 0.488603 * s), e.addScaledVector(r[3], 0.488603 * i), e.addScaledVector(r[4], i * n * 1.092548), e.addScaledVector(r[5], n * s * 1.092548), e.addScaledVector(r[6], 0.315392 * (3 * s * s - 1)), e.addScaledVector(r[7], i * s * 1.092548), e.addScaledVector(r[8], 0.546274 * (i * i - n * n)), e;
                }
                getIrradianceAt(t, e) {
                    const i = t.x,
                        n = t.y,
                        s = t.z,
                        r = this.coefficients;
                    return e.copy(r[0]).multiplyScalar(0.886227), e.addScaledVector(r[1], 1.023328 * n), e.addScaledVector(r[2], 1.023328 * s), e.addScaledVector(r[3], 1.023328 * i), e.addScaledVector(r[4], 0.858086 * i * n), e.addScaledVector(r[5], 0.858086 * n * s), e.addScaledVector(r[6], 0.743125 * s * s - 0.247708), e.addScaledVector(r[7], 0.858086 * i * s), e.addScaledVector(r[8], 0.429043 * (i * i - n * n)), e;
                }
                add(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this;
                }
                addScaledSH(t, e) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], e);
                    return this;
                }
                scale(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this;
                }
                lerp(t, e) {
                    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
                    return this;
                }
                equals(t) {
                    for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0;
                }
                copy(t) {
                    return this.set(t.coefficients);
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                fromArray(t, e = 0) {
                    const i = this.coefficients;
                    for (let n = 0; n < 9; n++) i[n].fromArray(t, e + 3 * n);
                    return this;
                }
                toArray(t = [], e = 0) {
                    const i = this.coefficients;
                    for (let n = 0; n < 9; n++) i[n].toArray(t, e + 3 * n);
                    return t;
                }
                static getBasisAt(t, e) {
                    const i = t.x,
                        n = t.y,
                        s = t.z;
                    (e[0] = 0.282095), (e[1] = 0.488603 * n), (e[2] = 0.488603 * s), (e[3] = 0.488603 * i), (e[4] = 1.092548 * i * n), (e[5] = 1.092548 * n * s), (e[6] = 0.315392 * (3 * s * s - 1)), (e[7] = 1.092548 * i * s), (e[8] = 0.546274 * (i * i - n * n));
                }
            }
            wl.prototype.isSphericalHarmonics3 = !0;
            class _l extends ol {
                constructor(t = new wl(), e = 1) {
                    super(void 0, e), (this.sh = t);
                }
                copy(t) {
                    return super.copy(t), this.sh.copy(t.sh), this;
                }
                fromJSON(t) {
                    return (this.intensity = t.intensity), this.sh.fromArray(t.sh), this;
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return (e.object.sh = this.sh.toArray()), e;
                }
            }
            _l.prototype.isLightProbe = !0;
            class Il {
                static decodeText(t) {
                    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(t);
                    let e = "";
                    for (let i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
                    try {
                        return decodeURIComponent(escape(e));
                    } catch (t) {
                        return e;
                    }
                }
                static extractUrlBase(t) {
                    const e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1);
                }
            }
            ((class extends ui {
                constructor() {
                    super(), (this.type = "InstancedBufferGeometry"), (this.instanceCount = 1 / 0);
                }
                copy(t) {
                    return super.copy(t), (this.instanceCount = t.instanceCount), this;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
                toJSON() {
                    const t = super.toJSON(this);
                    return (t.instanceCount = this.instanceCount), (t.isInstancedBufferGeometry = !0), t;
                }
            }).prototype.isInstancedBufferGeometry = !0),
                (class extends $e {
                    constructor(t, e, i, n = 1) {
                        "number" == typeof i && ((n = i), (i = !1)), super(t, e, i), (this.meshPerAttribute = n);
                    }
                    copy(t) {
                        return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return (t.meshPerAttribute = this.meshPerAttribute), (t.isInstancedBufferAttribute = !0), t;
                    }
                }.prototype.isInstancedBufferAttribute = !0);
            class Cl extends Xo {
                constructor(t) {
                    super(t), (this.options = { premultiplyAlpha: "none" });
                }
                setOptions(t) {
                    return (this.options = t), this;
                }
                load(t, e, i, n) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), (t = this.manager.resolveURL(t));
                    const s = this,
                        r = Yo.get(t);
                    if (void 0 !== r)
                        return (
                            s.manager.itemStart(t),
                            setTimeout(function () {
                                e && e(r), s.manager.itemEnd(t);
                            }, 0),
                            r
                        );
                    const a = {};
                    (a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include"),
                        (a.headers = this.requestHeader),
                        fetch(t, a)
                            .then(function (t) {
                                return t.blob();
                            })
                            .then(function (t) {
                                return createImageBitmap(t, Object.assign(s.options, { colorSpaceConversion: "none" }));
                            })
                            .then(function (i) {
                                Yo.add(t, i), e && e(i), s.manager.itemEnd(t);
                            })
                            .catch(function (e) {
                                n && n(e), s.manager.itemError(t), s.manager.itemEnd(t);
                            }),
                        s.manager.itemStart(t);
                }
            }
            let Ml;
            Cl.prototype.isImageBitmapLoader = !0;
            class El extends Xo {
                constructor(t) {
                    super(t);
                }
                load(t, e, i, n) {
                    const s = this,
                        r = new Zo(this.manager);
                    r.setResponseType("arraybuffer"),
                        r.setPath(this.path),
                        r.setRequestHeader(this.requestHeader),
                        r.setWithCredentials(this.withCredentials),
                        r.load(
                            t,
                            function (i) {
                                try {
                                    const t = i.slice(0);
                                    (void 0 === Ml && (Ml = new (window.AudioContext || window.webkitAudioContext)()), Ml).decodeAudioData(t, function (t) {
                                        e(t);
                                    });
                                } catch (e) {
                                    n && n(e), s.manager.itemError(t);
                                }
                            },
                            i,
                            n,
                        );
                }
            }
            ((class extends _l {
                constructor(t, e, i = 1) {
                    super(void 0, i);
                    const n = new Je().set(t),
                        s = new Je().set(e),
                        r = new bt(n.r, n.g, n.b),
                        a = new bt(s.r, s.g, s.b),
                        o = Math.sqrt(Math.PI),
                        l = o * Math.sqrt(0.75);
                    this.sh.coefficients[0].copy(r).add(a).multiplyScalar(o), this.sh.coefficients[1].copy(r).sub(a).multiplyScalar(l);
                }
            }).prototype.isHemisphereLightProbe = !0),
                (class extends _l {
                    constructor(t, e = 1) {
                        super(void 0, e);
                        const i = new Je().set(t);
                        this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI));
                    }
                }.prototype.isAmbientLightProbe = !0);
            class bl {
                constructor(t, e, i) {
                    let n, s, r;
                    switch (((this.binding = t), (this.valueSize = i), e)) {
                        case "quaternion":
                            (n = this._slerp), (s = this._slerpAdditive), (r = this._setAdditiveIdentityQuaternion), (this.buffer = new Float64Array(6 * i)), (this._workIndex = 5);
                            break;
                        case "string":
                        case "bool":
                            (n = this._select), (s = this._select), (r = this._setAdditiveIdentityOther), (this.buffer = new Array(5 * i));
                            break;
                        default:
                            (n = this._lerp), (s = this._lerpAdditive), (r = this._setAdditiveIdentityNumeric), (this.buffer = new Float64Array(5 * i));
                    }
                    (this._mixBufferRegion = n), (this._mixBufferRegionAdditive = s), (this._setIdentity = r), (this._origIndex = 3), (this._addIndex = 4), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), (this.useCount = 0), (this.referenceCount = 0);
                }
                accumulate(t, e) {
                    const i = this.buffer,
                        n = this.valueSize,
                        s = t * n + n;
                    let r = this.cumulativeWeight;
                    if (0 === r) {
                        for (let t = 0; t !== n; ++t) i[s + t] = i[t];
                        r = e;
                    } else {
                        r += e;
                        const t = e / r;
                        this._mixBufferRegion(i, s, 0, t, n);
                    }
                    this.cumulativeWeight = r;
                }
                accumulateAdditive(t) {
                    const e = this.buffer,
                        i = this.valueSize,
                        n = i * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, n, 0, t, i), (this.cumulativeWeightAdditive += t);
                }
                apply(t) {
                    const e = this.valueSize,
                        i = this.buffer,
                        n = t * e + e,
                        s = this.cumulativeWeight,
                        r = this.cumulativeWeightAdditive,
                        a = this.binding;
                    if (((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(i, n, t, 1 - s, e);
                    }
                    r > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * e, 1, e);
                    for (let t = e, s = e + e; t !== s; ++t)
                        if (i[t] !== i[t + e]) {
                            a.setValue(i, n);
                            break;
                        }
                }
                saveOriginalState() {
                    const t = this.binding,
                        e = this.buffer,
                        i = this.valueSize,
                        n = i * this._origIndex;
                    t.getValue(e, n);
                    for (let t = i, s = n; t !== s; ++t) e[t] = e[n + (t % i)];
                    this._setIdentity(), (this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0);
                }
                restoreOriginalState() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t);
                }
                _setAdditiveIdentityNumeric() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let i = t; i < e; i++) this.buffer[i] = 0;
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), (this.buffer[this._addIndex * this.valueSize + 3] = 1);
                }
                _setAdditiveIdentityOther() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i];
                }
                _select(t, e, i, n, s) {
                    if (n >= 0.5) for (let n = 0; n !== s; ++n) t[e + n] = t[i + n];
                }
                _slerp(t, e, i, n) {
                    Et.slerpFlat(t, e, t, e, t, i, n);
                }
                _slerpAdditive(t, e, i, n, s) {
                    const r = this._workIndex * s;
                    Et.multiplyQuaternionsFlat(t, r, t, e, t, i), Et.slerpFlat(t, e, t, e, t, r, n);
                }
                _lerp(t, e, i, n, s) {
                    const r = 1 - n;
                    for (let a = 0; a !== s; ++a) {
                        const s = e + a;
                        t[s] = t[s] * r + t[i + a] * n;
                    }
                }
                _lerpAdditive(t, e, i, n, s) {
                    for (let r = 0; r !== s; ++r) {
                        const s = e + r;
                        t[s] = t[s] + t[i + r] * n;
                    }
                }
            }
            const Sl = new RegExp("[\\[\\]\\.:\\/]", "g"),
                Bl = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                Tl = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                Ll = /(WCOD+)?/.source.replace("WCOD", Bl),
                Dl = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                Ql = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                Rl = new RegExp("^" + Tl + Ll + Dl + Ql + "$"),
                Pl = ["material", "materials", "bones"];
            class Nl {
                constructor(t, e, i) {
                    (this.path = e), (this.parsedPath = i || Nl.parseTrackName(e)), (this.node = Nl.findNode(t, this.parsedPath.nodeName) || t), (this.rootNode = t), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
                }
                static create(t, e, i) {
                    return t && t.isAnimationObjectGroup ? new Nl.Composite(t, e, i) : new Nl(t, e, i);
                }
                static sanitizeNodeName(t) {
                    return t.replace(/\s/g, "_").replace(Sl, "");
                }
                static parseTrackName(t) {
                    const e = Rl.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const i = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] },
                        n = i.nodeName && i.nodeName.lastIndexOf(".");
                    if (void 0 !== n && -1 !== n) {
                        const t = i.nodeName.substring(n + 1);
                        -1 !== Pl.indexOf(t) && ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = t));
                    }
                    if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return i;
                }
                static findNode(t, e) {
                    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const i = t.skeleton.getBoneByName(e);
                        if (void 0 !== i) return i;
                    }
                    if (t.children) {
                        const i = function (t) {
                                for (let n = 0; n < t.length; n++) {
                                    const s = t[n];
                                    if (s.name === e || s.uuid === e) return s;
                                    const r = i(s.children);
                                    if (r) return r;
                                }
                                return null;
                            },
                            n = i(t.children);
                        if (n) return n;
                    }
                    return null;
                }
                _getValue_unavailable() {}
                _setValue_unavailable() {}
                _getValue_direct(t, e) {
                    t[e] = this.node[this.propertyName];
                }
                _getValue_array(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, s = i.length; n !== s; ++n) t[e++] = i[n];
                }
                _getValue_arrayElement(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex];
                }
                _getValue_toArray(t, e) {
                    this.resolvedProperty.toArray(t, e);
                }
                _setValue_direct(t, e) {
                    this.targetObject[this.propertyName] = t[e];
                }
                _setValue_direct_setNeedsUpdate(t, e) {
                    (this.targetObject[this.propertyName] = t[e]), (this.targetObject.needsUpdate = !0);
                }
                _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
                    (this.targetObject[this.propertyName] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0);
                }
                _setValue_array(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++];
                }
                _setValue_array_setNeedsUpdate(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++];
                    this.targetObject.needsUpdate = !0;
                }
                _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
                    const i = this.resolvedProperty;
                    for (let n = 0, s = i.length; n !== s; ++n) i[n] = t[e++];
                    this.targetObject.matrixWorldNeedsUpdate = !0;
                }
                _setValue_arrayElement(t, e) {
                    this.resolvedProperty[this.propertyIndex] = t[e];
                }
                _setValue_arrayElement_setNeedsUpdate(t, e) {
                    (this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.needsUpdate = !0);
                }
                _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
                    (this.resolvedProperty[this.propertyIndex] = t[e]), (this.targetObject.matrixWorldNeedsUpdate = !0);
                }
                _setValue_fromArray(t, e) {
                    this.resolvedProperty.fromArray(t, e);
                }
                _setValue_fromArray_setNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
                }
                _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
                    this.resolvedProperty.fromArray(t, e), (this.targetObject.matrixWorldNeedsUpdate = !0);
                }
                _getValue_unbound(t, e) {
                    this.bind(), this.getValue(t, e);
                }
                _setValue_unbound(t, e) {
                    this.bind(), this.setValue(t, e);
                }
                bind() {
                    let t = this.node;
                    const e = this.parsedPath,
                        i = e.objectName,
                        n = e.propertyName;
                    let s = e.propertyIndex;
                    if ((t || ((t = Nl.findNode(this.rootNode, e.nodeName) || this.rootNode), (this.node = t)), (this.getValue = this._getValue_unavailable), (this.setValue = this._setValue_unavailable), !t)) return;
                    if (i) {
                        let n = e.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!t.material) return;
                                if (!t.material.materials) return;
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return;
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === n) {
                                        n = e;
                                        break;
                                    }
                                break;
                            default:
                                if (void 0 === t[i]) return;
                                t = t[i];
                        }
                        if (void 0 !== n) {
                            if (void 0 === t[n]) return;
                            t = t[n];
                        }
                    }
                    const r = t[n];
                    if (void 0 === r) {
                        e.nodeName;
                        return;
                    }
                    let a = this.Versioning.None;
                    (this.targetObject = t), void 0 !== t.needsUpdate ? (a = this.Versioning.NeedsUpdate) : void 0 !== t.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                    let o = this.BindingType.Direct;
                    if (void 0 !== s) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry) return;
                            if (!t.geometry.isBufferGeometry) return;
                            if (!t.geometry.morphAttributes) return;
                            void 0 !== t.morphTargetDictionary[s] && (s = t.morphTargetDictionary[s]);
                        }
                        (o = this.BindingType.ArrayElement), (this.resolvedProperty = r), (this.propertyIndex = s);
                    } else void 0 !== r.fromArray && void 0 !== r.toArray ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = r)) : Array.isArray(r) ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = r)) : (this.propertyName = n);
                    (this.getValue = this.GetterByBindingType[o]), (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
                }
                unbind() {
                    (this.node = null), (this.getValue = this._getValue_unbound), (this.setValue = this._setValue_unbound);
                }
            }
            (Nl.Composite = class {
                constructor(t, e, i) {
                    const n = i || Nl.parseTrackName(e);
                    (this._targetGroup = t), (this._bindings = t.subscribe_(e, n));
                }
                getValue(t, e) {
                    this.bind();
                    const i = this._targetGroup.nCachedObjects_,
                        n = this._bindings[i];
                    void 0 !== n && n.getValue(t, e);
                }
                setValue(t, e) {
                    const i = this._bindings;
                    for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n) i[n].setValue(t, e);
                }
                bind() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind();
                }
                unbind() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind();
                }
            }),
                (Nl.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }),
                (Nl.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }),
                (Nl.prototype.GetterByBindingType = [Nl.prototype._getValue_direct, Nl.prototype._getValue_array, Nl.prototype._getValue_arrayElement, Nl.prototype._getValue_toArray]),
                (Nl.prototype.SetterByBindingTypeAndVersioning = [
                    [Nl.prototype._setValue_direct, Nl.prototype._setValue_direct_setNeedsUpdate, Nl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                    [Nl.prototype._setValue_array, Nl.prototype._setValue_array_setNeedsUpdate, Nl.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                    [Nl.prototype._setValue_arrayElement, Nl.prototype._setValue_arrayElement_setNeedsUpdate, Nl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                    [Nl.prototype._setValue_fromArray, Nl.prototype._setValue_fromArray_setNeedsUpdate, Nl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate],
                ]);
            class Fl {
                constructor(t, e, i = null, n = e.blendMode) {
                    (this._mixer = t), (this._clip = e), (this._localRoot = i), (this.blendMode = n);
                    const s = e.tracks,
                        r = s.length,
                        a = new Array(r),
                        o = { endingStart: 2400, endingEnd: 2400 };
                    for (let t = 0; t !== r; ++t) {
                        const e = s[t].createInterpolant(null);
                        (a[t] = e), (e.settings = o);
                    }
                    (this._interpolantSettings = o), (this._interpolants = a), (this._propertyBindings = new Array(r)), (this._cacheIndex = null), (this._byClipCacheIndex = null), (this._timeScaleInterpolant = null), (this._weightInterpolant = null), (this.loop = 2201), (this._loopCount = -1), (this._startTime = null), (this.time = 0), (this.timeScale = 1), (this._effectiveTimeScale = 1), (this.weight = 1), (this._effectiveWeight = 1), (this.repetitions = 1 / 0), (this.paused = !1), (this.enabled = !0), (this.clampWhenFinished = !1), (this.zeroSlopeAtStart = !0), (this.zeroSlopeAtEnd = !0);
                }
                play() {
                    return this._mixer._activateAction(this), this;
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset();
                }
                reset() {
                    return (this.paused = !1), (this.enabled = !0), (this.time = 0), (this._loopCount = -1), (this._startTime = null), this.stopFading().stopWarping();
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this);
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this);
                }
                startAt(t) {
                    return (this._startTime = t), this;
                }
                setLoop(t, e) {
                    return (this.loop = t), (this.repetitions = e), this;
                }
                setEffectiveWeight(t) {
                    return (this.weight = t), (this._effectiveWeight = this.enabled ? t : 0), this.stopFading();
                }
                getEffectiveWeight() {
                    return this._effectiveWeight;
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1);
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0);
                }
                crossFadeFrom(t, e, i) {
                    if ((t.fadeOut(e), this.fadeIn(e), i)) {
                        const i = this._clip.duration,
                            n = t._clip.duration,
                            s = n / i,
                            r = i / n;
                        t.warp(1, s, e), this.warp(r, 1, e);
                    }
                    return this;
                }
                crossFadeTo(t, e, i) {
                    return t.crossFadeFrom(this, e, i);
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return null !== t && ((this._weightInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this;
                }
                setEffectiveTimeScale(t) {
                    return (this.timeScale = t), (this._effectiveTimeScale = this.paused ? 0 : t), this.stopWarping();
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale;
                }
                setDuration(t) {
                    return (this.timeScale = this._clip.duration / t), this.stopWarping();
                }
                syncWith(t) {
                    return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping();
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t);
                }
                warp(t, e, i) {
                    const n = this._mixer,
                        s = n.time,
                        r = this.timeScale;
                    let a = this._timeScaleInterpolant;
                    null === a && ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
                    const o = a.parameterPositions,
                        l = a.sampleValues;
                    return (o[0] = s), (o[1] = s + i), (l[0] = t / r), (l[1] = e / r), this;
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return null !== t && ((this._timeScaleInterpolant = null), this._mixer._takeBackControlInterpolant(t)), this;
                }
                getMixer() {
                    return this._mixer;
                }
                getClip() {
                    return this._clip;
                }
                getRoot() {
                    return this._localRoot || this._mixer._root;
                }
                _update(t, e, i, n) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const s = this._startTime;
                    if (null !== s) {
                        const n = (t - s) * i;
                        if (n < 0 || 0 === i) return;
                        (this._startTime = null), (e = i * n);
                    }
                    e *= this._updateTimeScale(t);
                    const r = this._updateTime(e),
                        a = this._updateWeight(t);
                    if (a > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        if (2501 === this.blendMode) for (let i = 0, n = t.length; i !== n; ++i) t[i].evaluate(r), e[i].accumulateAdditive(a);
                        else for (let i = 0, s = t.length; i !== s; ++i) t[i].evaluate(r), e[i].accumulate(n, a);
                    }
                }
                _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        const i = this._weightInterpolant;
                        if (null !== i) {
                            const n = i.evaluate(t)[0];
                            (e *= n), t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1));
                        }
                    }
                    return (this._effectiveWeight = e), e;
                }
                _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        const i = this._timeScaleInterpolant;
                        null !== i && ((e *= i.evaluate(t)[0]), t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e)));
                    }
                    return (this._effectiveTimeScale = e), e;
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        i = this.loop;
                    let n = this.time + t,
                        s = this._loopCount;
                    const r = 2202 === i;
                    if (0 === t) return -1 === s || !r || 1 & ~s ? n : e - n;
                    if (2200 === i) {
                        -1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
                        t: {
                            if (n >= e) n = e;
                            else {
                                if (!(n < 0)) {
                                    this.time = n;
                                    break t;
                                }
                                n = 0;
                            }
                            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1), (this.time = n), this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 });
                        }
                    } else {
                        if ((-1 === s && (t >= 0 ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, r)) : this._setEndings(0 === this.repetitions, !0, r)), n >= e || n < 0)) {
                            const i = Math.floor(n / e);
                            (n -= e * i), (s += Math.abs(i));
                            const a = this.repetitions - s;
                            if (a <= 0) this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1), (n = t > 0 ? e : 0), (this.time = n), this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
                            else {
                                if (1 === a) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, r);
                                } else this._setEndings(!1, !1, r);
                                (this._loopCount = s), (this.time = n), this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: i });
                            }
                        } else this.time = n;
                        if (r && !(1 & ~s)) return e - n;
                    }
                    return n;
                }
                _setEndings(t, e, i) {
                    const n = this._interpolantSettings;
                    i ? ((n.endingStart = 2401), (n.endingEnd = 2401)) : ((n.endingStart = t ? (this.zeroSlopeAtStart ? 2401 : 2400) : 2402), (n.endingEnd = e ? (this.zeroSlopeAtEnd ? 2401 : 2400) : 2402));
                }
                _scheduleFading(t, e, i) {
                    const n = this._mixer,
                        s = n.time;
                    let r = this._weightInterpolant;
                    null === r && ((r = n._lendControlInterpolant()), (this._weightInterpolant = r));
                    const a = r.parameterPositions,
                        o = r.sampleValues;
                    return (a[0] = s), (o[0] = e), (a[1] = s + t), (o[1] = i), this;
                }
            }
            class Ul extends nt {
                constructor(t) {
                    super(), (this._root = t), this._initMemoryManager(), (this._accuIndex = 0), (this.time = 0), (this.timeScale = 1);
                }
                _bindAction(t, e) {
                    const i = t._localRoot || this._root,
                        n = t._clip.tracks,
                        s = n.length,
                        r = t._propertyBindings,
                        a = t._interpolants,
                        o = i.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[o];
                    void 0 === c && ((c = {}), (l[o] = c));
                    for (let t = 0; t !== s; ++t) {
                        const s = n[t],
                            l = s.name;
                        let h = c[l];
                        if (void 0 !== h) r[t] = h;
                        else {
                            if (((h = r[t]), void 0 !== h)) {
                                null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, o, l));
                                continue;
                            }
                            const n = e && e._propertyBindings[t].binding.parsedPath;
                            (h = new bl(Nl.create(i, l, n), s.ValueTypeName, s.getValueSize())), ++h.referenceCount, this._addInactiveBinding(h, o, l), (r[t] = h);
                        }
                        a[t].resultBuffer = h.buffer;
                    }
                }
                _activateAction(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                i = t._clip.uuid,
                                n = this._actionsByClip[i];
                            this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
                        }
                        const e = t._propertyBindings;
                        for (let t = 0, i = e.length; t !== i; ++t) {
                            const i = e[t];
                            0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState());
                        }
                        this._lendAction(t);
                    }
                }
                _deactivateAction(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let t = 0, i = e.length; t !== i; ++t) {
                            const i = e[t];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i));
                        }
                        this._takeBackAction(t);
                    }
                }
                _initMemoryManager() {
                    (this._actions = []), (this._nActiveActions = 0), (this._actionsByClip = {}), (this._bindings = []), (this._nActiveBindings = 0), (this._bindingsByRootAndName = {}), (this._controlInterpolants = []), (this._nActiveControlInterpolants = 0);
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length;
                            },
                            get inUse() {
                                return t._nActiveActions;
                            },
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length;
                            },
                            get inUse() {
                                return t._nActiveBindings;
                            },
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length;
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants;
                            },
                        },
                    };
                }
                _isActiveAction(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions;
                }
                _addInactiveAction(t, e, i) {
                    const n = this._actions,
                        s = this._actionsByClip;
                    let r = s[e];
                    if (void 0 === r) (r = { knownActions: [t], actionByRoot: {} }), (t._byClipCacheIndex = 0), (s[e] = r);
                    else {
                        const e = r.knownActions;
                        (t._byClipCacheIndex = e.length), e.push(t);
                    }
                    (t._cacheIndex = n.length), n.push(t), (r.actionByRoot[i] = t);
                }
                _removeInactiveAction(t) {
                    const e = this._actions,
                        i = e[e.length - 1],
                        n = t._cacheIndex;
                    (i._cacheIndex = n), (e[n] = i), e.pop(), (t._cacheIndex = null);
                    const s = t._clip.uuid,
                        r = this._actionsByClip,
                        a = r[s],
                        o = a.knownActions,
                        l = o[o.length - 1],
                        c = t._byClipCacheIndex;
                    (l._byClipCacheIndex = c), (o[c] = l), o.pop(), (t._byClipCacheIndex = null), delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === o.length && delete r[s], this._removeInactiveBindingsForAction(t);
                }
                _removeInactiveBindingsForAction(t) {
                    const e = t._propertyBindings;
                    for (let t = 0, i = e.length; t !== i; ++t) {
                        const i = e[t];
                        0 == --i.referenceCount && this._removeInactiveBinding(i);
                    }
                }
                _lendAction(t) {
                    const e = this._actions,
                        i = t._cacheIndex,
                        n = this._nActiveActions++,
                        s = e[n];
                    (t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s);
                }
                _takeBackAction(t) {
                    const e = this._actions,
                        i = t._cacheIndex,
                        n = --this._nActiveActions,
                        s = e[n];
                    (t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s);
                }
                _addInactiveBinding(t, e, i) {
                    const n = this._bindingsByRootAndName,
                        s = this._bindings;
                    let r = n[e];
                    void 0 === r && ((r = {}), (n[e] = r)), (r[i] = t), (t._cacheIndex = s.length), s.push(t);
                }
                _removeInactiveBinding(t) {
                    const e = this._bindings,
                        i = t.binding,
                        n = i.rootNode.uuid,
                        s = i.path,
                        r = this._bindingsByRootAndName,
                        a = r[n],
                        o = e[e.length - 1],
                        l = t._cacheIndex;
                    (o._cacheIndex = l), (e[l] = o), e.pop(), delete a[s], 0 === Object.keys(a).length && delete r[n];
                }
                _lendBinding(t) {
                    const e = this._bindings,
                        i = t._cacheIndex,
                        n = this._nActiveBindings++,
                        s = e[n];
                    (t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s);
                }
                _takeBackBinding(t) {
                    const e = this._bindings,
                        i = t._cacheIndex,
                        n = --this._nActiveBindings,
                        s = e[n];
                    (t._cacheIndex = n), (e[n] = t), (s._cacheIndex = i), (e[i] = s);
                }
                _lendControlInterpolant() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let i = t[e];
                    return void 0 === i && ((i = new No(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)), (i.__cacheIndex = e), (t[e] = i)), i;
                }
                _takeBackControlInterpolant(t) {
                    const e = this._controlInterpolants,
                        i = t.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        s = e[n];
                    (t.__cacheIndex = n), (e[n] = t), (s.__cacheIndex = i), (e[i] = s);
                }
                clipAction(t, e, i) {
                    const n = e || this._root,
                        s = n.uuid;
                    let r = "string" == typeof t ? qo.findByName(n, t) : t;
                    const a = null !== r ? r.uuid : t,
                        o = this._actionsByClip[a];
                    let l = null;
                    if ((void 0 === i && (i = null !== r ? r.blendMode : 2500), void 0 !== o)) {
                        const t = o.actionByRoot[s];
                        if (void 0 !== t && t.blendMode === i) return t;
                        (l = o.knownActions[0]), null === r && (r = l._clip);
                    }
                    if (null === r) return null;
                    const c = new Fl(this, r, e, i);
                    return this._bindAction(c, l), this._addInactiveAction(c, a, s), c;
                }
                existingAction(t, e) {
                    const i = e || this._root,
                        n = i.uuid,
                        s = "string" == typeof t ? qo.findByName(i, t) : t,
                        r = s ? s.uuid : t,
                        a = this._actionsByClip[r];
                    return (void 0 !== a && a.actionByRoot[n]) || null;
                }
                stopAllAction() {
                    const t = this._actions;
                    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                    return this;
                }
                update(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        i = this._nActiveActions,
                        n = (this.time += t),
                        s = Math.sign(t),
                        r = (this._accuIndex ^= 1);
                    for (let a = 0; a !== i; ++a) e[a]._update(n, t, s, r);
                    const a = this._bindings,
                        o = this._nActiveBindings;
                    for (let t = 0; t !== o; ++t) a[t].apply(r);
                    return this;
                }
                setTime(t) {
                    this.time = 0;
                    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(t);
                }
                getRoot() {
                    return this._root;
                }
                uncacheClip(t) {
                    const e = this._actions,
                        i = t.uuid,
                        n = this._actionsByClip,
                        s = n[i];
                    if (void 0 !== s) {
                        const t = s.knownActions;
                        for (let i = 0, n = t.length; i !== n; ++i) {
                            const n = t[i];
                            this._deactivateAction(n);
                            const s = n._cacheIndex,
                                r = e[e.length - 1];
                            (n._cacheIndex = null), (n._byClipCacheIndex = null), (r._cacheIndex = s), (e[s] = r), e.pop(), this._removeInactiveBindingsForAction(n);
                        }
                        delete n[i];
                    }
                }
                uncacheRoot(t) {
                    const e = t.uuid,
                        i = this._actionsByClip;
                    for (const t in i) {
                        const n = i[t].actionByRoot[e];
                        void 0 !== n && (this._deactivateAction(n), this._removeInactiveAction(n));
                    }
                    const n = this._bindingsByRootAndName[e];
                    if (void 0 !== n)
                        for (const t in n) {
                            const e = n[t];
                            e.restoreOriginalState(), this._removeInactiveBinding(e);
                        }
                }
                uncacheAction(t, e) {
                    const i = this.existingAction(t, e);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
                }
            }
            function kl(t, e) {
                return t.distance - e.distance;
            }
            function Ol(t, e, i, n) {
                if ((t.layers.test(e.layers) && t.raycast(e, i), !0 === n)) {
                    const n = t.children;
                    for (let t = 0, s = n.length; t < s; t++) Ol(n[t], e, i, !0);
                }
            }
            (Ul.prototype._controlInterpolantsResultBuffer = new Float32Array(1)),
                (class extends Nr {
                    constructor(t, e, i = 1) {
                        super(t, e), (this.meshPerAttribute = i);
                    }
                    copy(t) {
                        return super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this;
                    }
                    clone(t) {
                        const e = super.clone(t);
                        return (e.meshPerAttribute = this.meshPerAttribute), e;
                    }
                    toJSON(t) {
                        const e = super.toJSON(t);
                        return (e.isInstancedInterleavedBuffer = !0), (e.meshPerAttribute = this.meshPerAttribute), e;
                    }
                }.prototype.isInstancedInterleavedBuffer = !0);
            class Gl {
                constructor(t = 1, e = 0, i = 0) {
                    return (this.radius = t), (this.phi = e), (this.theta = i), this;
                }
                set(t, e, i) {
                    return (this.radius = t), (this.phi = e), (this.theta = i), this;
                }
                copy(t) {
                    return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this;
                }
                makeSafe() {
                    const t = 1e-6;
                    return (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this;
                }
                setFromVector3(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z);
                }
                setFromCartesianCoords(t, e, i) {
                    return (this.radius = Math.sqrt(t * t + e * e + i * i)), 0 === this.radius ? ((this.theta = 0), (this.phi = 0)) : ((this.theta = Math.atan2(t, i)), (this.phi = Math.acos(ct(e / this.radius, -1, 1)))), this;
                }
                clone() {
                    return new this.constructor().copy(this);
                }
            }
            (class extends Be {
                constructor(t) {
                    super(), (this.material = t), (this.render = function () {}), (this.hasPositions = !1), (this.hasNormals = !1), (this.hasColors = !1), (this.hasUvs = !1), (this.positionArray = null), (this.normalArray = null), (this.colorArray = null), (this.uvArray = null), (this.count = 0);
                }
            }).prototype.isImmediateRenderObject = !0;
            const zl = new bt(),
                Vl = new se(),
                Hl = new se();
            class Wl extends Ca {
                constructor(t) {
                    const e = ql(t),
                        i = new ui(),
                        n = [],
                        s = [],
                        r = new Je(0, 0, 1),
                        a = new Je(0, 1, 0);
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        i.parent && i.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), s.push(r.r, r.g, r.b), s.push(a.r, a.g, a.b));
                    }
                    i.setAttribute("position", new ii(n, 3)), i.setAttribute("color", new ii(s, 3)), super(i, new ga({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 })), (this.type = "SkeletonHelper"), (this.isSkeletonHelper = !0), (this.root = t), (this.bones = e), (this.matrix = t.matrixWorld), (this.matrixAutoUpdate = !1);
                }
                updateMatrixWorld(t) {
                    const e = this.bones,
                        i = this.geometry,
                        n = i.getAttribute("position");
                    Hl.copy(this.root.matrixWorld).invert();
                    for (let t = 0, i = 0; t < e.length; t++) {
                        const s = e[t];
                        s.parent && s.parent.isBone && (Vl.multiplyMatrices(Hl, s.matrixWorld), zl.setFromMatrixPosition(Vl), n.setXYZ(i, zl.x, zl.y, zl.z), Vl.multiplyMatrices(Hl, s.parent.matrixWorld), zl.setFromMatrixPosition(Vl), n.setXYZ(i + 1, zl.x, zl.y, zl.z), (i += 2));
                    }
                    (i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(t);
                }
            }
            function ql(t) {
                const e = [];
                t && t.isBone && e.push(t);
                for (let i = 0; i < t.children.length; i++) e.push.apply(e, ql(t.children[i]));
                return e;
            }
            const jl = new Float32Array(1),
                Yl = new Int32Array(jl.buffer);
            class Jl {
                static toHalfFloat(t) {
                    jl[0] = t;
                    const e = Yl[0];
                    let i = (e >> 16) & 32768,
                        n = (e >> 12) & 2047;
                    const s = (e >> 23) & 255;
                    return s < 103 ? i : s > 142 ? ((i |= 31744), (i |= (255 == s ? 0 : 1) && 8388607 & e), i) : s < 113 ? ((n |= 2048), (i |= (n >> (114 - s)) + ((n >> (113 - s)) & 1)), i) : ((i |= ((s - 112) << 10) | (n >> 1)), (i += 1 & n), i);
                }
            }
            (Ra.create = function (t, e) {
                return (t.prototype = Object.create(Ra.prototype)), (t.prototype.constructor = t), (t.prototype.getPoint = e), t;
            }),
                (rl.prototype.fromPoints = function (t) {
                    return this.setFromPoints(t);
                }),
                (class extends Ca {
                    constructor(t = 10, e = 10, i = 4473924, n = 8947848) {
                        (i = new Je(i)), (n = new Je(n));
                        const s = e / 2,
                            r = t / e,
                            a = t / 2,
                            o = [],
                            l = [];
                        for (let t = 0, c = 0, h = -a; t <= e; t++, h += r) {
                            o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
                            const e = t === s ? i : n;
                            e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3), e.toArray(l, c), (c += 3);
                        }
                        const c = new ui();
                        c.setAttribute("position", new ii(o, 3)), c.setAttribute("color", new ii(l, 3)), super(c, new ga({ vertexColors: !0, toneMapped: !1 })), (this.type = "GridHelper");
                    }
                }.prototype.setColors = function () {}),
                (Wl.prototype.update = function () {}),
                (Xo.prototype.extractUrlBase = function (t) {
                    return Il.extractUrlBase(t);
                }),
                (Xo.Handlers = { add: function () {}, get: function () {} }),
                (Tt.prototype.center = function (t) {
                    return this.getCenter(t);
                }),
                (Tt.prototype.empty = function () {
                    return this.isEmpty();
                }),
                (Tt.prototype.isIntersectionBox = function (t) {
                    return this.intersectsBox(t);
                }),
                (Tt.prototype.isIntersectionSphere = function (t) {
                    return this.intersectsSphere(t);
                }),
                (Tt.prototype.size = function (t) {
                    return this.getSize(t);
                }),
                (Jt.prototype.empty = function () {
                    return this.isEmpty();
                }),
                (ji.prototype.setFromMatrix = function (t) {
                    return this.setFromProjectionMatrix(t);
                }),
                (ft.prototype.flattenToArrayOffset = function (t, e) {
                    return this.toArray(t, e);
                }),
                (ft.prototype.multiplyVector3 = function (t) {
                    return t.applyMatrix3(this);
                }),
                (ft.prototype.multiplyVector3Array = function () {}),
                (ft.prototype.applyToBufferAttribute = function (t) {
                    return t.applyMatrix3(this);
                }),
                (ft.prototype.applyToVector3Array = function () {}),
                (ft.prototype.getInverse = function (t) {
                    return this.copy(t).invert();
                }),
                (se.prototype.extractPosition = function (t) {
                    return this.copyPosition(t);
                }),
                (se.prototype.flattenToArrayOffset = function (t, e) {
                    return this.toArray(t, e);
                }),
                (se.prototype.getPosition = function () {
                    return new bt().setFromMatrixColumn(this, 3);
                }),
                (se.prototype.setRotationFromQuaternion = function (t) {
                    return this.makeRotationFromQuaternion(t);
                }),
                (se.prototype.multiplyToArray = function () {}),
                (se.prototype.multiplyVector3 = function (t) {
                    return t.applyMatrix4(this);
                }),
                (se.prototype.multiplyVector4 = function (t) {
                    return t.applyMatrix4(this);
                }),
                (se.prototype.multiplyVector3Array = function () {}),
                (se.prototype.rotateAxis = function (t) {
                    t.transformDirection(this);
                }),
                (se.prototype.crossVector = function (t) {
                    return t.applyMatrix4(this);
                }),
                (se.prototype.translate = function () {}),
                (se.prototype.rotateX = function () {}),
                (se.prototype.rotateY = function () {}),
                (se.prototype.rotateZ = function () {}),
                (se.prototype.rotateByAxis = function () {}),
                (se.prototype.applyToBufferAttribute = function (t) {
                    return t.applyMatrix4(this);
                }),
                (se.prototype.applyToVector3Array = function () {}),
                (se.prototype.makeFrustum = function (t, e, i, n, s, r) {
                    return this.makePerspective(t, e, n, i, s, r);
                }),
                (se.prototype.getInverse = function (t) {
                    return this.copy(t).invert();
                }),
                (Hi.prototype.isIntersectionLine = function (t) {
                    return this.intersectsLine(t);
                }),
                (Et.prototype.multiplyVector3 = function (t) {
                    return t.applyQuaternion(this);
                }),
                (Et.prototype.inverse = function () {
                    return this.invert();
                }),
                (ne.prototype.isIntersectionBox = function (t) {
                    return this.intersectsBox(t);
                }),
                (ne.prototype.isIntersectionPlane = function (t) {
                    return this.intersectsPlane(t);
                }),
                (ne.prototype.isIntersectionSphere = function (t) {
                    return this.intersectsSphere(t);
                }),
                (Oe.prototype.area = function () {
                    return this.getArea();
                }),
                (Oe.prototype.barycoordFromPoint = function (t, e) {
                    return this.getBarycoord(t, e);
                }),
                (Oe.prototype.midpoint = function (t) {
                    return this.getMidpoint(t);
                }),
                (Oe.prototypenormal = function (t) {
                    return this.getNormal(t);
                }),
                (Oe.prototype.plane = function (t) {
                    return this.getPlane(t);
                }),
                (Oe.barycoordFromPoint = function (t, e, i, n, s) {
                    return Oe.getBarycoord(t, e, i, n, s);
                }),
                (Oe.normal = function (t, e, i, n) {
                    return Oe.getNormal(t, e, i, n);
                }),
                (al.prototype.extractAllPoints = function (t) {
                    return this.extractPoints(t);
                }),
                (al.prototype.extrude = function (t) {
                    return new bo(this, t);
                }),
                (al.prototype.makeGeometry = function (t) {
                    return new Bo(this, t);
                }),
                (mt.prototype.fromAttribute = function (t, e, i) {
                    return this.fromBufferAttribute(t, e, i);
                }),
                (mt.prototype.distanceToManhattan = function (t) {
                    return this.manhattanDistanceTo(t);
                }),
                (mt.prototype.lengthManhattan = function () {
                    return this.manhattanLength();
                }),
                (bt.prototype.setEulerFromRotationMatrix = function () {}),
                (bt.prototype.setEulerFromQuaternion = function () {}),
                (bt.prototype.getPositionFromMatrix = function (t) {
                    return this.setFromMatrixPosition(t);
                }),
                (bt.prototype.getScaleFromMatrix = function (t) {
                    return this.setFromMatrixScale(t);
                }),
                (bt.prototype.getColumnFromMatrix = function (t, e) {
                    return this.setFromMatrixColumn(e, t);
                }),
                (bt.prototype.applyProjection = function (t) {
                    return this.applyMatrix4(t);
                }),
                (bt.prototype.fromAttribute = function (t, e, i) {
                    return this.fromBufferAttribute(t, e, i);
                }),
                (bt.prototype.distanceToManhattan = function (t) {
                    return this.manhattanDistanceTo(t);
                }),
                (bt.prototype.lengthManhattan = function () {
                    return this.manhattanLength();
                }),
                (It.prototype.fromAttribute = function (t, e, i) {
                    return this.fromBufferAttribute(t, e, i);
                }),
                (It.prototype.lengthManhattan = function () {
                    return this.manhattanLength();
                }),
                (Be.prototype.getChildByName = function (t) {
                    return this.getObjectByName(t);
                }),
                (Be.prototype.renderDepth = function () {}),
                (Be.prototype.translate = function (t, e) {
                    return this.translateOnAxis(e, t);
                }),
                (Be.prototype.getWorldRotation = function () {}),
                (Be.prototype.applyMatrix = function (t) {
                    return this.applyMatrix4(t);
                }),
                Object.defineProperties(Be.prototype, {
                    eulerOrder: {
                        get: function () {
                            return this.rotation.order;
                        },
                        set: function (t) {
                            this.rotation.order = t;
                        },
                    },
                    useQuaternion: { get: function () {}, set: function () {} },
                }),
                (Bi.prototype.setDrawMode = function () {}),
                Object.defineProperties(Bi.prototype, {
                    drawMode: {
                        get: function () {
                            return 0;
                        },
                        set: function () {},
                    },
                }),
                (ra.prototype.initBones = function () {}),
                (Fi.prototype.setLens = function (t, e) {
                    void 0 !== e && (this.filmGauge = e), this.setFocalLength(t);
                }),
                Object.defineProperties(ol.prototype, {
                    onlyShadow: { set: function () {} },
                    shadowCameraFov: {
                        set: function (t) {
                            this.shadow.camera.fov = t;
                        },
                    },
                    shadowCameraLeft: {
                        set: function (t) {
                            this.shadow.camera.left = t;
                        },
                    },
                    shadowCameraRight: {
                        set: function (t) {
                            this.shadow.camera.right = t;
                        },
                    },
                    shadowCameraTop: {
                        set: function (t) {
                            this.shadow.camera.top = t;
                        },
                    },
                    shadowCameraBottom: {
                        set: function (t) {
                            this.shadow.camera.bottom = t;
                        },
                    },
                    shadowCameraNear: {
                        set: function (t) {
                            this.shadow.camera.near = t;
                        },
                    },
                    shadowCameraFar: {
                        set: function (t) {
                            this.shadow.camera.far = t;
                        },
                    },
                    shadowCameraVisible: { set: function () {} },
                    shadowBias: {
                        set: function (t) {
                            this.shadow.bias = t;
                        },
                    },
                    shadowDarkness: { set: function () {} },
                    shadowMapWidth: {
                        set: function (t) {
                            this.shadow.mapSize.width = t;
                        },
                    },
                    shadowMapHeight: {
                        set: function (t) {
                            this.shadow.mapSize.height = t;
                        },
                    },
                }),
                Object.defineProperties($e.prototype, {
                    length: {
                        get: function () {
                            return this.array.length;
                        },
                    },
                    dynamic: {
                        get: function () {
                            return 35048 === this.usage;
                        },
                        set: function () {
                            this.setUsage(35048);
                        },
                    },
                }),
                ($e.prototype.setDynamic = function (t) {
                    return this.setUsage(!0 === t ? 35048 : 35044), this;
                }),
                ($e.prototype.copyIndicesArray = function () {}),
                ($e.prototype.setArray = function () {}),
                (ui.prototype.addIndex = function (t) {
                    this.setIndex(t);
                }),
                (ui.prototype.addAttribute = function (t, e) {
                    return (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute) ? ("index" === t ? (this.setIndex(e), this) : this.setAttribute(t, e)) : this.setAttribute(t, new $e(arguments[1], arguments[2]));
                }),
                (ui.prototype.addDrawCall = function (t, e, i) {
                    this.addGroup(t, e);
                }),
                (ui.prototype.clearDrawCalls = function () {
                    this.clearGroups();
                }),
                (ui.prototype.computeOffsets = function () {}),
                (ui.prototype.removeAttribute = function (t) {
                    return this.deleteAttribute(t);
                }),
                (ui.prototype.applyMatrix = function (t) {
                    return this.applyMatrix4(t);
                }),
                Object.defineProperties(ui.prototype, {
                    drawcalls: {
                        get: function () {
                            return this.groups;
                        },
                    },
                    offsets: {
                        get: function () {
                            return this.groups;
                        },
                    },
                }),
                (Nr.prototype.setDynamic = function (t) {
                    return this.setUsage(!0 === t ? 35048 : 35044), this;
                }),
                (Nr.prototype.setArray = function () {}),
                (bo.prototype.getArrays = function () {}),
                (bo.prototype.addShapeList = function () {}),
                (bo.prototype.addShape = function () {}),
                (Pr.prototype.dispose = function () {}),
                Object.defineProperties(ze.prototype, {
                    wrapAround: { get: function () {}, set: function () {} },
                    overdraw: { get: function () {}, set: function () {} },
                    wrapRGB: {
                        get: function () {
                            return new Je();
                        },
                    },
                    shading: {
                        get: function () {},
                        set: function (t) {
                            this.flatShading = 1 === t;
                        },
                    },
                    stencilMask: {
                        get: function () {
                            return this.stencilFuncMask;
                        },
                        set: function (t) {
                            this.stencilFuncMask = t;
                        },
                    },
                    vertexTangents: { get: function () {}, set: function () {} },
                }),
                Object.defineProperties(Pi.prototype, {
                    derivatives: {
                        get: function () {
                            return this.extensions.derivatives;
                        },
                        set: function (t) {
                            this.extensions.derivatives = t;
                        },
                    },
                }),
                (Rr.prototype.clearTarget = function (t, e, i, n) {
                    this.setRenderTarget(t), this.clear(e, i, n);
                }),
                (Rr.prototype.animate = function (t) {
                    this.setAnimationLoop(t);
                }),
                (Rr.prototype.getCurrentRenderTarget = function () {
                    return this.getRenderTarget();
                }),
                (Rr.prototype.getMaxAnisotropy = function () {
                    return this.capabilities.getMaxAnisotropy();
                }),
                (Rr.prototype.getPrecision = function () {
                    return this.capabilities.precision;
                }),
                (Rr.prototype.resetGLState = function () {
                    return this.state.reset();
                }),
                (Rr.prototype.supportsFloatTextures = function () {
                    return this.extensions.get("OES_texture_float");
                }),
                (Rr.prototype.supportsHalfFloatTextures = function () {
                    return this.extensions.get("OES_texture_half_float");
                }),
                (Rr.prototype.supportsStandardDerivatives = function () {
                    return this.extensions.get("OES_standard_derivatives");
                }),
                (Rr.prototype.supportsCompressedTextureS3TC = function () {
                    return this.extensions.get("WEBGL_compressed_texture_s3tc");
                }),
                (Rr.prototype.supportsCompressedTexturePVRTC = function () {
                    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
                }),
                (Rr.prototype.supportsBlendMinMax = function () {
                    return this.extensions.get("EXT_blend_minmax");
                }),
                (Rr.prototype.supportsVertexTextures = function () {
                    return this.capabilities.vertexTextures;
                }),
                (Rr.prototype.supportsInstancedArrays = function () {
                    return this.extensions.get("ANGLE_instanced_arrays");
                }),
                (Rr.prototype.enableScissorTest = function (t) {
                    this.setScissorTest(t);
                }),
                (Rr.prototype.initMaterial = function () {}),
                (Rr.prototype.addPrePlugin = function () {}),
                (Rr.prototype.addPostPlugin = function () {}),
                (Rr.prototype.updateShadowMap = function () {}),
                (Rr.prototype.setFaceCulling = function () {}),
                (Rr.prototype.allocTextureUnit = function () {}),
                (Rr.prototype.setTexture = function () {}),
                (Rr.prototype.setTexture2D = function () {}),
                (Rr.prototype.setTextureCube = function () {}),
                (Rr.prototype.getActiveMipMapLevel = function () {
                    return this.getActiveMipmapLevel();
                }),
                Object.defineProperties(Rr.prototype, {
                    shadowMapEnabled: {
                        get: function () {
                            return this.shadowMap.enabled;
                        },
                        set: function (t) {
                            this.shadowMap.enabled = t;
                        },
                    },
                    shadowMapType: {
                        get: function () {
                            return this.shadowMap.type;
                        },
                        set: function (t) {
                            this.shadowMap.type = t;
                        },
                    },
                    shadowMapCullFace: { get: function () {}, set: function () {} },
                    context: {
                        get: function () {
                            return this.getContext();
                        },
                    },
                    vr: {
                        get: function () {
                            return this.xr;
                        },
                    },
                    gammaInput: {
                        get: function () {
                            return !1;
                        },
                        set: function () {},
                    },
                    gammaOutput: {
                        get: function () {
                            return !1;
                        },
                        set: function (t) {
                            this.outputEncoding = !0 === t ? 3001 : 3e3;
                        },
                    },
                    toneMappingWhitePoint: {
                        get: function () {
                            return 1;
                        },
                        set: function () {},
                    },
                }),
                Object.defineProperties(Cr.prototype, { cullFace: { get: function () {}, set: function () {} }, renderReverseSided: { get: function () {}, set: function () {} }, renderSingleSided: { get: function () {}, set: function () {} } }),
                Object.defineProperties(Ct.prototype, {
                    wrapS: {
                        get: function () {
                            return this.texture.wrapS;
                        },
                        set: function (t) {
                            this.texture.wrapS = t;
                        },
                    },
                    wrapT: {
                        get: function () {
                            return this.texture.wrapT;
                        },
                        set: function (t) {
                            this.texture.wrapT = t;
                        },
                    },
                    magFilter: {
                        get: function () {
                            return this.texture.magFilter;
                        },
                        set: function (t) {
                            this.texture.magFilter = t;
                        },
                    },
                    minFilter: {
                        get: function () {
                            return this.texture.minFilter;
                        },
                        set: function (t) {
                            this.texture.minFilter = t;
                        },
                    },
                    anisotropy: {
                        get: function () {
                            return this.texture.anisotropy;
                        },
                        set: function (t) {
                            this.texture.anisotropy = t;
                        },
                    },
                    offset: {
                        get: function () {
                            return this.texture.offset;
                        },
                        set: function (t) {
                            this.texture.offset = t;
                        },
                    },
                    repeat: {
                        get: function () {
                            return this.texture.repeat;
                        },
                        set: function (t) {
                            this.texture.repeat = t;
                        },
                    },
                    format: {
                        get: function () {
                            return this.texture.format;
                        },
                        set: function (t) {
                            this.texture.format = t;
                        },
                    },
                    type: {
                        get: function () {
                            return this.texture.type;
                        },
                        set: function (t) {
                            this.texture.type = t;
                        },
                    },
                    generateMipmaps: {
                        get: function () {
                            return this.texture.generateMipmaps;
                        },
                        set: function (t) {
                            this.texture.generateMipmaps = t;
                        },
                    },
                }),
                (class extends Be {
                    constructor(t) {
                        super(), (this.type = "Audio"), (this.listener = t), (this.context = t.context), (this.gain = this.context.createGain()), this.gain.connect(t.getInput()), (this.autoplay = !1), (this.buffer = null), (this.detune = 0), (this.loop = !1), (this.loopStart = 0), (this.loopEnd = 0), (this.offset = 0), (this.duration = void 0), (this.playbackRate = 1), (this.isPlaying = !1), (this.hasPlaybackControl = !0), (this.source = null), (this.sourceType = "empty"), (this._startedAt = 0), (this._progress = 0), (this._connected = !1), (this.filters = []);
                    }
                    getOutput() {
                        return this.gain;
                    }
                    setNodeSource(t) {
                        return (this.hasPlaybackControl = !1), (this.sourceType = "audioNode"), (this.source = t), this.connect(), this;
                    }
                    setMediaElementSource(t) {
                        return (this.hasPlaybackControl = !1), (this.sourceType = "mediaNode"), (this.source = this.context.createMediaElementSource(t)), this.connect(), this;
                    }
                    setMediaStreamSource(t) {
                        return (this.hasPlaybackControl = !1), (this.sourceType = "mediaStreamNode"), (this.source = this.context.createMediaStreamSource(t)), this.connect(), this;
                    }
                    setBuffer(t) {
                        return (this.buffer = t), (this.sourceType = "buffer"), this.autoplay && this.play(), this;
                    }
                    play(t = 0) {
                        if (!0 === this.isPlaying) return;
                        if (!1 === this.hasPlaybackControl) return;
                        this._startedAt = this.context.currentTime + t;
                        const e = this.context.createBufferSource();
                        return (e.buffer = this.buffer), (e.loop = this.loop), (e.loopStart = this.loopStart), (e.loopEnd = this.loopEnd), (e.onended = this.onEnded.bind(this)), e.start(this._startedAt, this._progress + this.offset, this.duration), (this.isPlaying = !0), (this.source = e), this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
                    }
                    pause() {
                        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && ((this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate), !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1)), this;
                    }
                    stop() {
                        if (!1 !== this.hasPlaybackControl) return (this._progress = 0), this.source.stop(), (this.source.onended = null), (this.isPlaying = !1), this;
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                            this.filters[this.filters.length - 1].connect(this.getOutput());
                        } else this.source.connect(this.getOutput());
                        return (this._connected = !0), this;
                    }
                    disconnect() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                            this.filters[this.filters.length - 1].disconnect(this.getOutput());
                        } else this.source.disconnect(this.getOutput());
                        return (this._connected = !1), this;
                    }
                    getFilters() {
                        return this.filters;
                    }
                    setFilters(t) {
                        return t || (t = []), !0 === this._connected ? (this.disconnect(), (this.filters = t.slice()), this.connect()) : (this.filters = t.slice()), this;
                    }
                    setDetune(t) {
                        if (((this.detune = t), void 0 !== this.source.detune)) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
                    }
                    getDetune() {
                        return this.detune;
                    }
                    getFilter() {
                        return this.getFilters()[0];
                    }
                    setFilter(t) {
                        return this.setFilters(t ? [t] : []);
                    }
                    setPlaybackRate(t) {
                        if (!1 !== this.hasPlaybackControl) return (this.playbackRate = t), !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
                    }
                    getPlaybackRate() {
                        return this.playbackRate;
                    }
                    onEnded() {
                        this.isPlaying = !1;
                    }
                    getLoop() {
                        return !1 !== this.hasPlaybackControl && this.loop;
                    }
                    setLoop(t) {
                        if (!1 !== this.hasPlaybackControl) return (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    }
                    setLoopStart(t) {
                        return (this.loopStart = t), this;
                    }
                    setLoopEnd(t) {
                        return (this.loopEnd = t), this;
                    }
                    getVolume() {
                        return this.gain.gain.value;
                    }
                    setVolume(t) {
                        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
                    }
                }.prototype.load = function (t) {
                    const e = this;
                    return (
                        new El().load(t, function (t) {
                            e.setBuffer(t);
                        }),
                        this
                    );
                }),
                (Ui.prototype.updateCubeMap = function (t, e) {
                    return this.update(t, e);
                }),
                (Ui.prototype.clear = function (t, e, i, n) {
                    return this.renderTarget.clear(t, e, i, n);
                }),
                (yt.crossOrigin = void 0),
                (yt.loadTexture = function (t, e, i, n) {
                    const s = new nl();
                    s.setCrossOrigin(this.crossOrigin);
                    const r = s.load(t, i, void 0, n);
                    return e && (r.mapping = e), r;
                }),
                (yt.loadTextureCube = function (t, e, i, n) {
                    const s = new el();
                    s.setCrossOrigin(this.crossOrigin);
                    const r = s.load(t, i, void 0, n);
                    return e && (r.mapping = e), r;
                }),
                (yt.loadCompressedTexture = function () {}),
                (yt.loadCompressedTextureCube = function () {}),
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "131" } })),
                "undefined" != typeof window && (window.__THREE__ || (window.__THREE__ = "131"));
            const Xl = new WeakMap();
            function Kl() {
                let t, e;
                function i(t, e, i, n, s, r) {
                    const a = r.num_components(),
                        o = i.num_points() * a,
                        l = o * s.BYTES_PER_ELEMENT,
                        c = (function (t, e) {
                            switch (e) {
                                case Float32Array:
                                    return t.DT_FLOAT32;
                                case Int8Array:
                                    return t.DT_INT8;
                                case Int16Array:
                                    return t.DT_INT16;
                                case Int32Array:
                                    return t.DT_INT32;
                                case Uint8Array:
                                    return t.DT_UINT8;
                                case Uint16Array:
                                    return t.DT_UINT16;
                                case Uint32Array:
                                    return t.DT_UINT32;
                            }
                        })(t, s),
                        h = t._malloc(l);
                    e.GetAttributeDataArrayForAllPoints(i, r, c, l, h);
                    const u = new s(t.HEAPF32.buffer, h, o).slice();
                    return t._free(h), { name: n, array: u, itemSize: a };
                }
                onmessage = function (n) {
                    const s = n.data;
                    switch (s.type) {
                        case "init":
                            (t = s.decoderConfig),
                                (e = new Promise(function (e) {
                                    (t.onModuleLoaded = function (t) {
                                        e({ draco: t });
                                    }),
                                        DracoDecoderModule(t);
                                }));
                            break;
                        case "decode":
                            const n = s.buffer,
                                r = s.taskConfig;
                            e.then((t) => {
                                const e = t.draco,
                                    a = new e.Decoder(),
                                    o = new e.DecoderBuffer();
                                o.Init(new Int8Array(n), n.byteLength);
                                try {
                                    const t = (function (t, e, n, s) {
                                            const r = s.attributeIDs,
                                                a = s.attributeTypes;
                                            let o, l;
                                            const c = e.GetEncodedGeometryType(n);
                                            if (c === t.TRIANGULAR_MESH) (o = new t.Mesh()), (l = e.DecodeBufferToMesh(n, o));
                                            else {
                                                if (c !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                (o = new t.PointCloud()), (l = e.DecodeBufferToPointCloud(n, o));
                                            }
                                            if (!l.ok() || 0 === o.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                            const h = { index: null, attributes: [] };
                                            for (const n in r) {
                                                const l = self[a[n]];
                                                let c, u;
                                                if (s.useUniqueIDs) (u = r[n]), (c = e.GetAttributeByUniqueId(o, u));
                                                else {
                                                    if (((u = e.GetAttributeId(o, t[r[n]])), -1 === u)) continue;
                                                    c = e.GetAttribute(o, u);
                                                }
                                                h.attributes.push(i(t, e, o, n, l, c));
                                            }
                                            return (
                                                c === t.TRIANGULAR_MESH &&
                                                    (h.index = (function (t, e, i) {
                                                        const n = 3 * i.num_faces(),
                                                            s = 4 * n,
                                                            r = t._malloc(s);
                                                        e.GetTrianglesUInt32Array(i, s, r);
                                                        const a = new Uint32Array(t.HEAPF32.buffer, r, n).slice();
                                                        return t._free(r), { array: a, itemSize: 1 };
                                                    })(t, e, o)),
                                                t.destroy(o),
                                                h
                                            );
                                        })(e, a, o, r),
                                        n = t.attributes.map((t) => t.array.buffer);
                                    t.index && n.push(t.index.array.buffer), self.postMessage({ type: "decode", id: s.id, geometry: t }, n);
                                } catch (t) {
                                    self.postMessage({ type: "error", id: s.id, error: t.message });
                                } finally {
                                    e.destroy(o), e.destroy(a);
                                }
                            });
                    }
                };
            }
            class Zl extends Xo {
                constructor(t) {
                    super(t),
                        (this.dracoLoader = null),
                        (this.ktx2Loader = null),
                        (this.meshoptDecoder = null),
                        (this.pluginCallbacks = []),
                        this.register(function (t) {
                            return new nc(t);
                        }),
                        this.register(function (t) {
                            return new lc(t);
                        }),
                        this.register(function (t) {
                            return new cc(t);
                        }),
                        this.register(function (t) {
                            return new sc(t);
                        }),
                        this.register(function (t) {
                            return new rc(t);
                        }),
                        this.register(function (t) {
                            return new ac(t);
                        }),
                        this.register(function (t) {
                            return new oc(t);
                        }),
                        this.register(function (t) {
                            return new ec(t);
                        }),
                        this.register(function (t) {
                            return new hc(t);
                        });
                }
                load(t, e, i, n) {
                    const s = this;
                    let r;
                    (r = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Il.extractUrlBase(t)), this.manager.itemStart(t);
                    const a = function (e) {
                            n && n(e), s.manager.itemError(t), s.manager.itemEnd(t);
                        },
                        o = new Zo(this.manager);
                    o.setPath(this.path),
                        o.setResponseType("arraybuffer"),
                        o.setRequestHeader(this.requestHeader),
                        o.setWithCredentials(this.withCredentials),
                        o.load(
                            t,
                            function (i) {
                                try {
                                    s.parse(
                                        i,
                                        r,
                                        function (i) {
                                            e(i), s.manager.itemEnd(t);
                                        },
                                        a,
                                    );
                                } catch (t) {
                                    a(t);
                                }
                            },
                            i,
                            a,
                        );
                }
                setDRACOLoader(t) {
                    return (this.dracoLoader = t), this;
                }
                setDDSLoader() {
                    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
                }
                setKTX2Loader(t) {
                    return (this.ktx2Loader = t), this;
                }
                setMeshoptDecoder(t) {
                    return (this.meshoptDecoder = t), this;
                }
                register(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
                }
                unregister(t) {
                    return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
                }
                parse(t, e, i, n) {
                    let s;
                    const r = {},
                        a = {};
                    if ("string" == typeof t) s = t;
                    else if (Il.decodeText(new Uint8Array(t, 0, 4)) === uc) {
                        try {
                            r[tc.KHR_BINARY_GLTF] = new dc(t);
                        } catch (t) {
                            return void (n && n(t));
                        }
                        s = r[tc.KHR_BINARY_GLTF].content;
                    } else s = Il.decodeText(new Uint8Array(t));
                    const o = JSON.parse(s);
                    if (void 0 === o.asset || o.asset.version[0] < 2) return void (n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                    const l = new Rc(o, { path: e || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
                    l.fileLoader.setRequestHeader(this.requestHeader);
                    for (let t = 0; t < this.pluginCallbacks.length; t++) {
                        const e = this.pluginCallbacks[t](l);
                        (a[e.name] = e), (r[e.name] = !0);
                    }
                    if (o.extensionsUsed)
                        for (let t = 0; t < o.extensionsUsed.length; ++t) {
                            const e = o.extensionsUsed[t],
                                i = o.extensionsRequired || [];
                            switch (e) {
                                case tc.KHR_MATERIALS_UNLIT:
                                    r[e] = new ic();
                                    break;
                                case tc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                                    r[e] = new mc();
                                    break;
                                case tc.KHR_DRACO_MESH_COMPRESSION:
                                    r[e] = new pc(o, this.dracoLoader);
                                    break;
                                case tc.KHR_TEXTURE_TRANSFORM:
                                    r[e] = new Ac();
                                    break;
                                case tc.KHR_MESH_QUANTIZATION:
                                    r[e] = new fc();
                                    break;
                                default:
                                    i.indexOf(e) >= 0 && a[e];
                            }
                        }
                    l.setExtensions(r), l.setPlugins(a), l.parse(i, n);
                }
            }
            function $l() {
                let t = {};
                return {
                    get: function (e) {
                        return t[e];
                    },
                    add: function (e, i) {
                        t[e] = i;
                    },
                    remove: function (e) {
                        delete t[e];
                    },
                    removeAll: function () {
                        t = {};
                    },
                };
            }
            const tc = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_IOR: "KHR_materials_ior", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_SPECULAR: "KHR_materials_specular", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_MATERIALS_VOLUME: "KHR_materials_volume", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
            class ec {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_LIGHTS_PUNCTUAL), (this.cache = { refs: {}, uses: {} });
                }
                _markDefs() {
                    const t = this.parser,
                        e = this.parser.json.nodes || [];
                    for (let i = 0, n = e.length; i < n; i++) {
                        const n = e[i];
                        n.extensions && n.extensions[this.name] && void 0 !== n.extensions[this.name].light && t._addNodeRef(this.cache, n.extensions[this.name].light);
                    }
                }
                _loadLight(t) {
                    const e = this.parser,
                        i = "light:" + t;
                    let n = e.cache.get(i);
                    if (n) return n;
                    const s = e.json,
                        r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[t];
                    let a;
                    const o = new Je(16777215);
                    void 0 !== r.color && o.fromArray(r.color);
                    const l = void 0 !== r.range ? r.range : 0;
                    switch (r.type) {
                        case "directional":
                            (a = new xl(o)), a.target.position.set(0, 0, -1), a.add(a.target);
                            break;
                        case "point":
                            (a = new vl(o)), (a.distance = l);
                            break;
                        case "spot":
                            (a = new pl(o)), (a.distance = l), (r.spot = r.spot || {}), (r.spot.innerConeAngle = void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0), (r.spot.outerConeAngle = void 0 !== r.spot.outerConeAngle ? r.spot.outerConeAngle : Math.PI / 4), (a.angle = r.spot.outerConeAngle), (a.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle), a.target.position.set(0, 0, -1), a.add(a.target);
                            break;
                        default:
                            throw new Error("THREE.GLTFLoader: Unexpected light type: " + r.type);
                    }
                    return a.position.set(0, 0, 0), (a.decay = 2), void 0 !== r.intensity && (a.intensity = r.intensity), (a.name = e.createUniqueName(r.name || "light_" + t)), (n = Promise.resolve(a)), e.cache.add(i, n), n;
                }
                createNodeAttachment(t) {
                    const e = this,
                        i = this.parser,
                        n = i.json.nodes[t],
                        s = ((n.extensions && n.extensions[this.name]) || {}).light;
                    return void 0 === s
                        ? null
                        : this._loadLight(s).then(function (t) {
                              return i._getNodeRef(e.cache, s, t);
                          });
                }
            }
            class ic {
                constructor() {
                    this.name = tc.KHR_MATERIALS_UNLIT;
                }
                getMaterialType() {
                    return Xe;
                }
                extendParams(t, e, i) {
                    const n = [];
                    (t.color = new Je(1, 1, 1)), (t.opacity = 1);
                    const s = e.pbrMetallicRoughness;
                    if (s) {
                        if (Array.isArray(s.baseColorFactor)) {
                            const e = s.baseColorFactor;
                            t.color.fromArray(e), (t.opacity = e[3]);
                        }
                        void 0 !== s.baseColorTexture && n.push(i.assignTexture(t, "map", s.baseColorTexture));
                    }
                    return Promise.all(n);
                }
            }
            class nc {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_MATERIALS_CLEARCOAT);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Do : null;
                }
                extendMaterialParams(t, e) {
                    const i = this.parser,
                        n = i.json.materials[t];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        r = n.extensions[this.name];
                    if ((void 0 !== r.clearcoatFactor && (e.clearcoat = r.clearcoatFactor), void 0 !== r.clearcoatTexture && s.push(i.assignTexture(e, "clearcoatMap", r.clearcoatTexture)), void 0 !== r.clearcoatRoughnessFactor && (e.clearcoatRoughness = r.clearcoatRoughnessFactor), void 0 !== r.clearcoatRoughnessTexture && s.push(i.assignTexture(e, "clearcoatRoughnessMap", r.clearcoatRoughnessTexture)), void 0 !== r.clearcoatNormalTexture && (s.push(i.assignTexture(e, "clearcoatNormalMap", r.clearcoatNormalTexture)), void 0 !== r.clearcoatNormalTexture.scale))) {
                        const t = r.clearcoatNormalTexture.scale;
                        e.clearcoatNormalScale = new mt(t, -t);
                    }
                    return Promise.all(s);
                }
            }
            class sc {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_MATERIALS_TRANSMISSION);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Do : null;
                }
                extendMaterialParams(t, e) {
                    const i = this.parser,
                        n = i.json.materials[t];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        r = n.extensions[this.name];
                    return void 0 !== r.transmissionFactor && (e.transmission = r.transmissionFactor), void 0 !== r.transmissionTexture && s.push(i.assignTexture(e, "transmissionMap", r.transmissionTexture)), Promise.all(s);
                }
            }
            class rc {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_MATERIALS_VOLUME);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Do : null;
                }
                extendMaterialParams(t, e) {
                    const i = this.parser,
                        n = i.json.materials[t];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        r = n.extensions[this.name];
                    (e.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0), void 0 !== r.thicknessTexture && s.push(i.assignTexture(e, "thicknessMap", r.thicknessTexture)), (e.attenuationDistance = r.attenuationDistance || 0);
                    const a = r.attenuationColor || [1, 1, 1];
                    return (e.attenuationTint = new Je(a[0], a[1], a[2])), Promise.all(s);
                }
            }
            class ac {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_MATERIALS_IOR);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Do : null;
                }
                extendMaterialParams(t, e) {
                    const i = this.parser.json.materials[t];
                    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                    const n = i.extensions[this.name];
                    return (e.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
                }
            }
            class oc {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_MATERIALS_SPECULAR);
                }
                getMaterialType(t) {
                    const e = this.parser.json.materials[t];
                    return e.extensions && e.extensions[this.name] ? Do : null;
                }
                extendMaterialParams(t, e) {
                    const i = this.parser,
                        n = i.json.materials[t];
                    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                    const s = [],
                        r = n.extensions[this.name];
                    (e.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1), void 0 !== r.specularTexture && s.push(i.assignTexture(e, "specularIntensityMap", r.specularTexture));
                    const a = r.specularColorFactor || [1, 1, 1];
                    return (
                        (e.specularTint = new Je(a[0], a[1], a[2])),
                        void 0 !== r.specularColorTexture &&
                            s.push(
                                i.assignTexture(e, "specularTintMap", r.specularColorTexture).then(function (t) {
                                    t.encoding = 3001;
                                }),
                            ),
                        Promise.all(s)
                    );
                }
            }
            class lc {
                constructor(t) {
                    (this.parser = t), (this.name = tc.KHR_TEXTURE_BASISU);
                }
                loadTexture(t) {
                    const e = this.parser,
                        i = e.json,
                        n = i.textures[t];
                    if (!n.extensions || !n.extensions[this.name]) return null;
                    const s = n.extensions[this.name],
                        r = i.images[s.source],
                        a = e.options.ktx2Loader;
                    if (!a) {
                        if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                        return null;
                    }
                    return e.loadTextureImage(t, r, a);
                }
            }
            class cc {
                constructor(t) {
                    (this.parser = t), (this.name = tc.EXT_TEXTURE_WEBP), (this.isSupported = null);
                }
                loadTexture(t) {
                    const e = this.name,
                        i = this.parser,
                        n = i.json,
                        s = n.textures[t];
                    if (!s.extensions || !s.extensions[e]) return null;
                    const r = s.extensions[e],
                        a = n.images[r.source];
                    let o = i.textureLoader;
                    if (a.uri) {
                        const t = i.options.manager.getHandler(a.uri);
                        null !== t && (o = t);
                    }
                    return this.detectSupport().then(function (s) {
                        if (s) return i.loadTextureImage(t, a, o);
                        if (n.extensionsRequired && n.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                        return i.loadTexture(t);
                    });
                }
                detectSupport() {
                    return (
                        this.isSupported ||
                            (this.isSupported = new Promise(function (t) {
                                const e = new Image();
                                (e.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                                    (e.onload = e.onerror =
                                        function () {
                                            t(1 === e.height);
                                        });
                            })),
                        this.isSupported
                    );
                }
            }
            class hc {
                constructor(t) {
                    (this.name = tc.EXT_MESHOPT_COMPRESSION), (this.parser = t);
                }
                loadBufferView(t) {
                    const e = this.parser.json,
                        i = e.bufferViews[t];
                    if (i.extensions && i.extensions[this.name]) {
                        const t = i.extensions[this.name],
                            n = this.parser.getDependency("buffer", t.buffer),
                            s = this.parser.options.meshoptDecoder;
                        if (!s || !s.supported) {
                            if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                            return null;
                        }
                        return Promise.all([n, s.ready]).then(function (e) {
                            const i = t.byteOffset || 0,
                                n = t.byteLength || 0,
                                r = t.count,
                                a = t.byteStride,
                                o = new ArrayBuffer(r * a),
                                l = new Uint8Array(e[0], i, n);
                            return s.decodeGltfBuffer(new Uint8Array(o), r, a, l, t.mode, t.filter), o;
                        });
                    }
                    return null;
                }
            }
            const uc = "glTF";
            class dc {
                constructor(t) {
                    (this.name = tc.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
                    const e = new DataView(t, 0, 12);
                    if (((this.header = { magic: Il.decodeText(new Uint8Array(t.slice(0, 4))), version: e.getUint32(4, !0), length: e.getUint32(8, !0) }), this.header.magic !== uc)) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    const i = this.header.length - 12,
                        n = new DataView(t, 12);
                    let s = 0;
                    for (; s < i; ) {
                        const e = n.getUint32(s, !0);
                        s += 4;
                        const i = n.getUint32(s, !0);
                        if (((s += 4), 1313821514 === i)) {
                            const i = new Uint8Array(t, 12 + s, e);
                            this.content = Il.decodeText(i);
                        } else if (5130562 === i) {
                            const i = 12 + s;
                            this.body = t.slice(i, i + e);
                        }
                        s += e;
                    }
                    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
                }
            }
            class pc {
                constructor(t, e) {
                    if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                    (this.name = tc.KHR_DRACO_MESH_COMPRESSION), (this.json = t), (this.dracoLoader = e), this.dracoLoader.preload();
                }
                decodePrimitive(t, e) {
                    const i = this.json,
                        n = this.dracoLoader,
                        s = t.extensions[this.name].bufferView,
                        r = t.extensions[this.name].attributes,
                        a = {},
                        o = {},
                        l = {};
                    for (const t in r) {
                        const e = Ic[t] || t.toLowerCase();
                        a[e] = r[t];
                    }
                    for (const e in t.attributes) {
                        const n = Ic[e] || e.toLowerCase();
                        if (void 0 !== r[e]) {
                            const s = i.accessors[t.attributes[e]],
                                r = yc[s.componentType];
                            (l[n] = r), (o[n] = !0 === s.normalized);
                        }
                    }
                    return e.getDependency("bufferView", s).then(function (t) {
                        return new Promise(function (e) {
                            n.decodeDracoFile(
                                t,
                                function (t) {
                                    for (const e in t.attributes) {
                                        const i = t.attributes[e],
                                            n = o[e];
                                        void 0 !== n && (i.normalized = n);
                                    }
                                    e(t);
                                },
                                a,
                                l,
                            );
                        });
                    });
                }
            }
            class Ac {
                constructor() {
                    this.name = tc.KHR_TEXTURE_TRANSFORM;
                }
                extendTexture(t, e) {
                    return e.texCoord, (void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale) || ((t = t.clone()), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), (t.needsUpdate = !0)), t;
                }
            }
            class gc extends Lo {
                constructor(t) {
                    super(), (this.isGLTFSpecularGlossinessMaterial = !0);
                    const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
                        i = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
                        n = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
                        s = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
                        r = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
                        a = { specular: { value: new Je().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
                    (this._extraUniforms = a),
                        (this.onBeforeCompile = function (t) {
                            for (const e in a) t.uniforms[e] = a[e];
                            t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", i).replace("#include <roughnessmap_fragment>", n).replace("#include <metalnessmap_fragment>", s).replace("#include <lights_physical_fragment>", r);
                        }),
                        Object.defineProperties(this, {
                            specular: {
                                get: function () {
                                    return a.specular.value;
                                },
                                set: function (t) {
                                    a.specular.value = t;
                                },
                            },
                            specularMap: {
                                get: function () {
                                    return a.specularMap.value;
                                },
                                set: function (t) {
                                    (a.specularMap.value = t), t ? (this.defines.USE_SPECULARMAP = "") : delete this.defines.USE_SPECULARMAP;
                                },
                            },
                            glossiness: {
                                get: function () {
                                    return a.glossiness.value;
                                },
                                set: function (t) {
                                    a.glossiness.value = t;
                                },
                            },
                            glossinessMap: {
                                get: function () {
                                    return a.glossinessMap.value;
                                },
                                set: function (t) {
                                    (a.glossinessMap.value = t), t ? ((this.defines.USE_GLOSSINESSMAP = ""), (this.defines.USE_UV = "")) : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
                                },
                            },
                        }),
                        delete this.metalness,
                        delete this.roughness,
                        delete this.metalnessMap,
                        delete this.roughnessMap,
                        this.setValues(t);
                }
                copy(t) {
                    return super.copy(t), (this.specularMap = t.specularMap), this.specular.copy(t.specular), (this.glossinessMap = t.glossinessMap), (this.glossiness = t.glossiness), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
                }
            }
            class mc {
                constructor() {
                    (this.name = tc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS), (this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]);
                }
                getMaterialType() {
                    return gc;
                }
                extendParams(t, e, i) {
                    const n = e.extensions[this.name];
                    (t.color = new Je(1, 1, 1)), (t.opacity = 1);
                    const s = [];
                    if (Array.isArray(n.diffuseFactor)) {
                        const e = n.diffuseFactor;
                        t.color.fromArray(e), (t.opacity = e[3]);
                    }
                    if ((void 0 !== n.diffuseTexture && s.push(i.assignTexture(t, "map", n.diffuseTexture)), (t.emissive = new Je(0, 0, 0)), (t.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1), (t.specular = new Je(1, 1, 1)), Array.isArray(n.specularFactor) && t.specular.fromArray(n.specularFactor), void 0 !== n.specularGlossinessTexture)) {
                        const e = n.specularGlossinessTexture;
                        s.push(i.assignTexture(t, "glossinessMap", e)), s.push(i.assignTexture(t, "specularMap", e));
                    }
                    return Promise.all(s);
                }
                createMaterial(t) {
                    const e = new gc(t);
                    return (e.fog = !0), (e.color = t.color), (e.map = void 0 === t.map ? null : t.map), (e.lightMap = null), (e.lightMapIntensity = 1), (e.aoMap = void 0 === t.aoMap ? null : t.aoMap), (e.aoMapIntensity = 1), (e.emissive = t.emissive), (e.emissiveIntensity = 1), (e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap), (e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap), (e.bumpScale = 1), (e.normalMap = void 0 === t.normalMap ? null : t.normalMap), (e.normalMapType = 0), t.normalScale && (e.normalScale = t.normalScale), (e.displacementMap = null), (e.displacementScale = 1), (e.displacementBias = 0), (e.specularMap = void 0 === t.specularMap ? null : t.specularMap), (e.specular = t.specular), (e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap), (e.glossiness = t.glossiness), (e.alphaMap = null), (e.envMap = void 0 === t.envMap ? null : t.envMap), (e.envMapIntensity = 1), (e.refractionRatio = 0.98), e;
                }
            }
            class fc {
                constructor() {
                    this.name = tc.KHR_MESH_QUANTIZATION;
                }
            }
            class vc extends Ro {
                constructor(t, e, i, n) {
                    super(t, e, i, n);
                }
                copySampleValue_(t) {
                    const e = this.resultBuffer,
                        i = this.sampleValues,
                        n = this.valueSize,
                        s = t * n * 3 + n;
                    for (let t = 0; t !== n; t++) e[t] = i[s + t];
                    return e;
                }
            }
            (vc.prototype.beforeStart_ = vc.prototype.copySampleValue_),
                (vc.prototype.afterEnd_ = vc.prototype.copySampleValue_),
                (vc.prototype.interpolate_ = function (t, e, i, n) {
                    const s = this.resultBuffer,
                        r = this.sampleValues,
                        a = this.valueSize,
                        o = 2 * a,
                        l = 3 * a,
                        c = n - e,
                        h = (i - e) / c,
                        u = h * h,
                        d = u * h,
                        p = t * l,
                        A = p - l,
                        g = -2 * d + 3 * u,
                        m = d - u,
                        f = 1 - g,
                        v = m - u + h;
                    for (let t = 0; t !== a; t++) {
                        const e = r[A + t + a],
                            i = r[A + t + o] * c,
                            n = r[p + t + a],
                            l = r[p + t] * c;
                        s[t] = f * e + v * i + g * n + m * l;
                    }
                    return s;
                });
            const yc = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array },
                xc = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 },
                wc = { 33071: 1001, 33648: 1002, 10497: 1e3 },
                _c = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
                Ic = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" },
                Cc = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" },
                Mc = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 };
            function Ec(t, e) {
                return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
            }
            function bc(t) {
                return void 0 === t.DefaultMaterial && (t.DefaultMaterial = new Lo({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 })), t.DefaultMaterial;
            }
            function Sc(t, e, i) {
                for (const n in i.extensions) void 0 === t[n] && ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}), (e.userData.gltfExtensions[n] = i.extensions[n]));
            }
            function Bc(t, e) {
                void 0 !== e.extras && "object" == typeof e.extras && Object.assign(t.userData, e.extras);
            }
            function Tc(t, e) {
                if ((t.updateMorphTargets(), void 0 !== e.weights)) for (let i = 0, n = e.weights.length; i < n; i++) t.morphTargetInfluences[i] = e.weights[i];
                if (e.extras && Array.isArray(e.extras.targetNames)) {
                    const i = e.extras.targetNames;
                    if (t.morphTargetInfluences.length === i.length) {
                        t.morphTargetDictionary = {};
                        for (let e = 0, n = i.length; e < n; e++) t.morphTargetDictionary[i[e]] = e;
                    }
                }
            }
            function Lc(t) {
                const e = t.extensions && t.extensions[tc.KHR_DRACO_MESH_COMPRESSION];
                let i;
                return (i = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + Dc(e.attributes) : t.indices + ":" + Dc(t.attributes) + ":" + t.mode), i;
            }
            function Dc(t) {
                let e = "";
                const i = Object.keys(t).sort();
                for (let n = 0, s = i.length; n < s; n++) e += i[n] + ":" + t[i[n]] + ";";
                return e;
            }
            function Qc(t) {
                switch (t) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
                }
            }
            class Rc {
                constructor(t = {}, e = {}) {
                    (this.json = t), (this.extensions = {}), (this.plugins = {}), (this.options = e), (this.cache = new $l()), (this.associations = new Map()), (this.primitiveCache = {}), (this.meshCache = { refs: {}, uses: {} }), (this.cameraCache = { refs: {}, uses: {} }), (this.lightCache = { refs: {}, uses: {} }), (this.textureCache = {}), (this.nodeNamesUsed = {}), "undefined" != typeof createImageBitmap && !1 === /Firefox/.test(navigator.userAgent) ? (this.textureLoader = new Cl(this.options.manager)) : (this.textureLoader = new nl(this.options.manager)), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), (this.fileLoader = new Zo(this.options.manager)), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0);
                }
                setExtensions(t) {
                    this.extensions = t;
                }
                setPlugins(t) {
                    this.plugins = t;
                }
                parse(t, e) {
                    const i = this,
                        n = this.json,
                        s = this.extensions;
                    this.cache.removeAll(),
                        this._invokeAll(function (t) {
                            return t._markDefs && t._markDefs();
                        }),
                        Promise.all(
                            this._invokeAll(function (t) {
                                return t.beforeRoot && t.beforeRoot();
                            }),
                        )
                            .then(function () {
                                return Promise.all([i.getDependencies("scene"), i.getDependencies("animation"), i.getDependencies("camera")]);
                            })
                            .then(function (e) {
                                const r = { scene: e[0][n.scene || 0], scenes: e[0], animations: e[1], cameras: e[2], asset: n.asset, parser: i, userData: {} };
                                Sc(s, r, n),
                                    Bc(r, n),
                                    Promise.all(
                                        i._invokeAll(function (t) {
                                            return t.afterRoot && t.afterRoot(r);
                                        }),
                                    ).then(function () {
                                        t(r);
                                    });
                            })
                            .catch(e);
                }
                _markDefs() {
                    const t = this.json.nodes || [],
                        e = this.json.skins || [],
                        i = this.json.meshes || [];
                    for (let i = 0, n = e.length; i < n; i++) {
                        const n = e[i].joints;
                        for (let e = 0, i = n.length; e < i; e++) t[n[e]].isBone = !0;
                    }
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        void 0 !== n.mesh && (this._addNodeRef(this.meshCache, n.mesh), void 0 !== n.skin && (i[n.mesh].isSkinnedMesh = !0)), void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
                    }
                }
                _addNodeRef(t, e) {
                    void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++);
                }
                _getNodeRef(t, e, i) {
                    if (t.refs[e] <= 1) return i;
                    const n = i.clone();
                    return (n.name += "_instance_" + t.uses[e]++), n;
                }
                _invokeOne(t) {
                    const e = Object.values(this.plugins);
                    e.push(this);
                    for (let i = 0; i < e.length; i++) {
                        const n = t(e[i]);
                        if (n) return n;
                    }
                    return null;
                }
                _invokeAll(t) {
                    const e = Object.values(this.plugins);
                    e.unshift(this);
                    const i = [];
                    for (let n = 0; n < e.length; n++) {
                        const s = t(e[n]);
                        s && i.push(s);
                    }
                    return i;
                }
                getDependency(t, e) {
                    const i = t + ":" + e;
                    let n = this.cache.get(i);
                    if (!n) {
                        switch (t) {
                            case "scene":
                                n = this.loadScene(e);
                                break;
                            case "node":
                                n = this.loadNode(e);
                                break;
                            case "mesh":
                                n = this._invokeOne(function (t) {
                                    return t.loadMesh && t.loadMesh(e);
                                });
                                break;
                            case "accessor":
                                n = this.loadAccessor(e);
                                break;
                            case "bufferView":
                                n = this._invokeOne(function (t) {
                                    return t.loadBufferView && t.loadBufferView(e);
                                });
                                break;
                            case "buffer":
                                n = this.loadBuffer(e);
                                break;
                            case "material":
                                n = this._invokeOne(function (t) {
                                    return t.loadMaterial && t.loadMaterial(e);
                                });
                                break;
                            case "texture":
                                n = this._invokeOne(function (t) {
                                    return t.loadTexture && t.loadTexture(e);
                                });
                                break;
                            case "skin":
                                n = this.loadSkin(e);
                                break;
                            case "animation":
                                n = this.loadAnimation(e);
                                break;
                            case "camera":
                                n = this.loadCamera(e);
                                break;
                            default:
                                throw new Error("Unknown type: " + t);
                        }
                        this.cache.add(i, n);
                    }
                    return n;
                }
                getDependencies(t) {
                    let e = this.cache.get(t);
                    if (!e) {
                        const i = this,
                            n = this.json[t + ("mesh" === t ? "es" : "s")] || [];
                        (e = Promise.all(
                            n.map(function (e, n) {
                                return i.getDependency(t, n);
                            }),
                        )),
                            this.cache.add(t, e);
                    }
                    return e;
                }
                loadBuffer(t) {
                    const e = this.json.buffers[t],
                        i = this.fileLoader;
                    if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
                    if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[tc.KHR_BINARY_GLTF].body);
                    const n = this.options;
                    return new Promise(function (t, s) {
                        i.load(Ec(e.uri, n.path), t, void 0, function () {
                            s(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'));
                        });
                    });
                }
                loadBufferView(t) {
                    const e = this.json.bufferViews[t];
                    return this.getDependency("buffer", e.buffer).then(function (t) {
                        const i = e.byteLength || 0,
                            n = e.byteOffset || 0;
                        return t.slice(n, n + i);
                    });
                }
                loadAccessor(t) {
                    const e = this,
                        i = this.json,
                        n = this.json.accessors[t];
                    if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null);
                    const s = [];
                    return (
                        void 0 !== n.bufferView ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null),
                        void 0 !== n.sparse && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
                        Promise.all(s).then(function (t) {
                            const s = t[0],
                                r = _c[n.type],
                                a = yc[n.componentType],
                                o = a.BYTES_PER_ELEMENT,
                                l = o * r,
                                c = n.byteOffset || 0,
                                h = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0,
                                u = !0 === n.normalized;
                            let d, p;
                            if (h && h !== l) {
                                const t = Math.floor(c / h),
                                    i = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + t + ":" + n.count;
                                let l = e.cache.get(i);
                                l || ((d = new a(s, t * h, (n.count * h) / o)), (l = new Nr(d, h / o)), e.cache.add(i, l)), (p = new Ur(l, r, (c % h) / o, u));
                            } else (d = null === s ? new a(n.count * r) : new a(s, c, n.count * r)), (p = new $e(d, r, u));
                            if (void 0 !== n.sparse) {
                                const e = _c.SCALAR,
                                    i = yc[n.sparse.indices.componentType],
                                    o = n.sparse.indices.byteOffset || 0,
                                    l = n.sparse.values.byteOffset || 0,
                                    c = new i(t[1], o, n.sparse.count * e),
                                    h = new a(t[2], l, n.sparse.count * r);
                                null !== s && (p = new $e(p.array.slice(), p.itemSize, p.normalized));
                                for (let t = 0, e = c.length; t < e; t++) {
                                    const e = c[t];
                                    if ((p.setX(e, h[t * r]), r >= 2 && p.setY(e, h[t * r + 1]), r >= 3 && p.setZ(e, h[t * r + 2]), r >= 4 && p.setW(e, h[t * r + 3]), r >= 5)) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
                                }
                            }
                            return p;
                        })
                    );
                }
                loadTexture(t) {
                    const e = this.json,
                        i = this.options,
                        n = e.textures[t],
                        s = e.images[n.source];
                    let r = this.textureLoader;
                    if (s.uri) {
                        const t = i.manager.getHandler(s.uri);
                        null !== t && (r = t);
                    }
                    return this.loadTextureImage(t, s, r);
                }
                loadTextureImage(t, e, i) {
                    const n = this,
                        s = this.json,
                        r = this.options,
                        a = s.textures[t],
                        o = (e.uri || e.bufferView) + ":" + a.sampler;
                    if (this.textureCache[o]) return this.textureCache[o];
                    const l = self.URL || self.webkitURL;
                    let c = e.uri || "",
                        h = !1,
                        u = !0;
                    const d = c.search(/\.jpe?g($|\?)/i) > 0 || 0 === c.search(/^data\:image\/jpeg/);
                    if ((("image/jpeg" === e.mimeType || d) && (u = !1), void 0 !== e.bufferView))
                        c = n.getDependency("bufferView", e.bufferView).then(function (t) {
                            if ("image/png" === e.mimeType) {
                                const e = new DataView(t, 25, 1).getUint8(0, !1);
                                u = 6 === e || 4 === e || 3 === e;
                            }
                            h = !0;
                            const i = new Blob([t], { type: e.mimeType });
                            return (c = l.createObjectURL(i)), c;
                        });
                    else if (void 0 === e.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
                    const p = Promise.resolve(c)
                        .then(function (t) {
                            return new Promise(function (e, n) {
                                let s = e;
                                !0 === i.isImageBitmapLoader &&
                                    (s = function (t) {
                                        const i = new wt(t);
                                        (i.needsUpdate = !0), e(i);
                                    }),
                                    i.load(Ec(t, r.path), s, void 0, n);
                            });
                        })
                        .then(function (e) {
                            !0 === h && l.revokeObjectURL(c), (e.flipY = !1), a.name && (e.name = a.name), u || (e.format = 1022);
                            const i = (s.samplers || {})[a.sampler] || {};
                            return (e.magFilter = xc[i.magFilter] || 1006), (e.minFilter = xc[i.minFilter] || 1008), (e.wrapS = wc[i.wrapS] || 1e3), (e.wrapT = wc[i.wrapT] || 1e3), n.associations.set(e, { type: "textures", index: t }), e;
                        })
                        .catch(function () {
                            return null;
                        });
                    return (this.textureCache[o] = p), p;
                }
                assignTexture(t, e, i) {
                    const n = this;
                    return this.getDependency("texture", i.index).then(function (s) {
                        if ((void 0 === i.texCoord || 0 == i.texCoord || ("aoMap" === e && i.texCoord), n.extensions[tc.KHR_TEXTURE_TRANSFORM])) {
                            const t = void 0 !== i.extensions ? i.extensions[tc.KHR_TEXTURE_TRANSFORM] : void 0;
                            if (t) {
                                const e = n.associations.get(s);
                                (s = n.extensions[tc.KHR_TEXTURE_TRANSFORM].extendTexture(s, t)), n.associations.set(s, e);
                            }
                        }
                        return (t[e] = s), s;
                    });
                }
                assignFinalMaterial(t) {
                    const e = t.geometry;
                    let i = t.material;
                    const n = void 0 !== e.attributes.tangent,
                        s = void 0 !== e.attributes.color,
                        r = void 0 === e.attributes.normal;
                    if (t.isPoints) {
                        const t = "PointsMaterial:" + i.uuid;
                        let e = this.cache.get(t);
                        e || ((e = new Ea()), ze.prototype.copy.call(e, i), e.color.copy(i.color), (e.map = i.map), (e.sizeAttenuation = !1), this.cache.add(t, e)), (i = e);
                    } else if (t.isLine) {
                        const t = "LineBasicMaterial:" + i.uuid;
                        let e = this.cache.get(t);
                        e || ((e = new ga()), ze.prototype.copy.call(e, i), e.color.copy(i.color), this.cache.add(t, e)), (i = e);
                    }
                    if (n || s || r) {
                        let t = "ClonedMaterial:" + i.uuid + ":";
                        i.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), n && (t += "vertex-tangents:"), s && (t += "vertex-colors:"), r && (t += "flat-shading:");
                        let e = this.cache.get(t);
                        e || ((e = i.clone()), s && (e.vertexColors = !0), r && (e.flatShading = !0), n && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(i))), (i = e);
                    }
                    i.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), (t.material = i);
                }
                getMaterialType() {
                    return Lo;
                }
                loadMaterial(t) {
                    const e = this,
                        i = this.json,
                        n = this.extensions,
                        s = i.materials[t];
                    let r;
                    const a = {},
                        o = s.extensions || {},
                        l = [];
                    if (o[tc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
                        const t = n[tc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
                        (r = t.getMaterialType()), l.push(t.extendParams(a, s, e));
                    } else if (o[tc.KHR_MATERIALS_UNLIT]) {
                        const t = n[tc.KHR_MATERIALS_UNLIT];
                        (r = t.getMaterialType()), l.push(t.extendParams(a, s, e));
                    } else {
                        const i = s.pbrMetallicRoughness || {};
                        if (((a.color = new Je(1, 1, 1)), (a.opacity = 1), Array.isArray(i.baseColorFactor))) {
                            const t = i.baseColorFactor;
                            a.color.fromArray(t), (a.opacity = t[3]);
                        }
                        void 0 !== i.baseColorTexture && l.push(e.assignTexture(a, "map", i.baseColorTexture)),
                            (a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1),
                            (a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1),
                            void 0 !== i.metallicRoughnessTexture && (l.push(e.assignTexture(a, "metalnessMap", i.metallicRoughnessTexture)), l.push(e.assignTexture(a, "roughnessMap", i.metallicRoughnessTexture))),
                            (r = this._invokeOne(function (e) {
                                return e.getMaterialType && e.getMaterialType(t);
                            })),
                            l.push(
                                Promise.all(
                                    this._invokeAll(function (e) {
                                        return e.extendMaterialParams && e.extendMaterialParams(t, a);
                                    }),
                                ),
                            );
                    }
                    !0 === s.doubleSided && (a.side = 2);
                    const c = s.alphaMode || "OPAQUE";
                    return (
                        "BLEND" === c ? ((a.transparent = !0), (a.depthWrite = !1)) : ((a.transparent = !1), "MASK" === c && (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
                        void 0 !== s.normalTexture && r !== Xe && (l.push(e.assignTexture(a, "normalMap", s.normalTexture)), (a.normalScale = new mt(1, -1)), void 0 !== s.normalTexture.scale && a.normalScale.set(s.normalTexture.scale, -s.normalTexture.scale)),
                        void 0 !== s.occlusionTexture && r !== Xe && (l.push(e.assignTexture(a, "aoMap", s.occlusionTexture)), void 0 !== s.occlusionTexture.strength && (a.aoMapIntensity = s.occlusionTexture.strength)),
                        void 0 !== s.emissiveFactor && r !== Xe && (a.emissive = new Je().fromArray(s.emissiveFactor)),
                        void 0 !== s.emissiveTexture && r !== Xe && l.push(e.assignTexture(a, "emissiveMap", s.emissiveTexture)),
                        Promise.all(l).then(function () {
                            let i;
                            return (i = r === gc ? n[tc.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new r(a)), s.name && (i.name = s.name), i.map && (i.map.encoding = 3001), i.emissiveMap && (i.emissiveMap.encoding = 3001), Bc(i, s), e.associations.set(i, { type: "materials", index: t }), s.extensions && Sc(n, i, s), i;
                        })
                    );
                }
                createUniqueName(t) {
                    const e = Nl.sanitizeNodeName(t || "");
                    let i = e;
                    for (let t = 1; this.nodeNamesUsed[i]; ++t) i = e + "_" + t;
                    return (this.nodeNamesUsed[i] = !0), i;
                }
                loadGeometries(t) {
                    const e = this,
                        i = this.extensions,
                        n = this.primitiveCache;
                    function s(t) {
                        return i[tc.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then(function (i) {
                            return Nc(i, t, e);
                        });
                    }
                    const r = [];
                    for (let i = 0, a = t.length; i < a; i++) {
                        const a = t[i],
                            o = Lc(a),
                            l = n[o];
                        if (l) r.push(l.promise);
                        else {
                            let t;
                            (t = a.extensions && a.extensions[tc.KHR_DRACO_MESH_COMPRESSION] ? s(a) : Nc(new ui(), a, e)), (n[o] = { primitive: a, promise: t }), r.push(t);
                        }
                    }
                    return Promise.all(r);
                }
                loadMesh(t) {
                    const e = this,
                        i = this.json,
                        n = this.extensions,
                        s = i.meshes[t],
                        r = s.primitives,
                        a = [];
                    for (let t = 0, e = r.length; t < e; t++) {
                        const e = void 0 === r[t].material ? bc(this.cache) : this.getDependency("material", r[t].material);
                        a.push(e);
                    }
                    return (
                        a.push(e.loadGeometries(r)),
                        Promise.all(a).then(function (i) {
                            const a = i.slice(0, i.length - 1),
                                o = i[i.length - 1],
                                l = [];
                            for (let i = 0, c = o.length; i < c; i++) {
                                const c = o[i],
                                    h = r[i];
                                let u;
                                const d = a[i];
                                if (4 === h.mode || 5 === h.mode || 6 === h.mode || void 0 === h.mode) (u = !0 === s.isSkinnedMesh ? new ra(c, d) : new Bi(c, d)), !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(), 5 === h.mode ? (u.geometry = Fc(u.geometry, 1)) : 6 === h.mode && (u.geometry = Fc(u.geometry, 2));
                                else if (1 === h.mode) u = new Ca(c, d);
                                else if (3 === h.mode) u = new wa(c, d);
                                else if (2 === h.mode) u = new Ma(c, d);
                                else {
                                    if (0 !== h.mode) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                                    u = new La(c, d);
                                }
                                Object.keys(u.geometry.morphAttributes).length > 0 && Tc(u, s), (u.name = e.createUniqueName(s.name || "mesh_" + t)), Bc(u, s), h.extensions && Sc(n, u, h), e.assignFinalMaterial(u), l.push(u);
                            }
                            if (1 === l.length) return l[0];
                            const c = new Br();
                            for (let t = 0, e = l.length; t < e; t++) c.add(l[t]);
                            return c;
                        })
                    );
                }
                loadCamera(t) {
                    let e;
                    const i = this.json.cameras[t],
                        n = i[i.type];
                    if (n) return "perspective" === i.type ? (e = new Fi(gt.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6)) : "orthographic" === i.type && (e = new on(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (e.name = this.createUniqueName(i.name)), Bc(e, i), Promise.resolve(e);
                }
                loadSkin(t) {
                    const e = this.json.skins[t],
                        i = { joints: e.joints };
                    return void 0 === e.inverseBindMatrices
                        ? Promise.resolve(i)
                        : this.getDependency("accessor", e.inverseBindMatrices).then(function (t) {
                              return (i.inverseBindMatrices = t), i;
                          });
                }
                loadAnimation(t) {
                    const e = this.json.animations[t],
                        i = [],
                        n = [],
                        s = [],
                        r = [],
                        a = [];
                    for (let t = 0, o = e.channels.length; t < o; t++) {
                        const o = e.channels[t],
                            l = e.samplers[o.sampler],
                            c = o.target,
                            h = void 0 !== c.node ? c.node : c.id,
                            u = void 0 !== e.parameters ? e.parameters[l.input] : l.input,
                            d = void 0 !== e.parameters ? e.parameters[l.output] : l.output;
                        i.push(this.getDependency("node", h)), n.push(this.getDependency("accessor", u)), s.push(this.getDependency("accessor", d)), r.push(l), a.push(c);
                    }
                    return Promise.all([Promise.all(i), Promise.all(n), Promise.all(s), Promise.all(r), Promise.all(a)]).then(function (i) {
                        const n = i[0],
                            s = i[1],
                            r = i[2],
                            a = i[3],
                            o = i[4],
                            l = [];
                        for (let t = 0, e = n.length; t < e; t++) {
                            const e = n[t],
                                i = s[t],
                                c = r[t],
                                h = a[t],
                                u = o[t];
                            if (void 0 === e) continue;
                            let d;
                            switch ((e.updateMatrix(), (e.matrixAutoUpdate = !0), Cc[u.path])) {
                                case Cc.weights:
                                    d = Go;
                                    break;
                                case Cc.rotation:
                                    d = Vo;
                                    break;
                                default:
                                    d = Wo;
                            }
                            const p = e.name ? e.name : e.uuid,
                                A = void 0 !== h.interpolation ? Mc[h.interpolation] : 2301,
                                g = [];
                            Cc[u.path] === Cc.weights
                                ? e.traverse(function (t) {
                                      !0 === t.isMesh && t.morphTargetInfluences && g.push(t.name ? t.name : t.uuid);
                                  })
                                : g.push(p);
                            let m = c.array;
                            if (c.normalized) {
                                const t = Qc(m.constructor),
                                    e = new Float32Array(m.length);
                                for (let i = 0, n = m.length; i < n; i++) e[i] = m[i] * t;
                                m = e;
                            }
                            for (let t = 0, e = g.length; t < e; t++) {
                                const e = new d(g[t] + "." + Cc[u.path], i.array, m, A);
                                "CUBICSPLINE" === h.interpolation &&
                                    ((e.createInterpolant = function (t) {
                                        return new vc(this.times, this.values, this.getValueSize() / 3, t);
                                    }),
                                    (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0)),
                                    l.push(e);
                            }
                        }
                        const c = e.name ? e.name : "animation_" + t;
                        return new qo(c, void 0, l);
                    });
                }
                createNodeMesh(t) {
                    const e = this.json,
                        i = this,
                        n = e.nodes[t];
                    return void 0 === n.mesh
                        ? null
                        : i.getDependency("mesh", n.mesh).then(function (t) {
                              const e = i._getNodeRef(i.meshCache, n.mesh, t);
                              return (
                                  void 0 !== n.weights &&
                                      e.traverse(function (t) {
                                          if (t.isMesh) for (let e = 0, i = n.weights.length; e < i; e++) t.morphTargetInfluences[e] = n.weights[e];
                                      }),
                                  e
                              );
                          });
                }
                loadNode(t) {
                    const e = this.json,
                        i = this.extensions,
                        n = this,
                        s = e.nodes[t],
                        r = s.name ? n.createUniqueName(s.name) : "";
                    return (function () {
                        const e = [],
                            i = n._invokeOne(function (e) {
                                return e.createNodeMesh && e.createNodeMesh(t);
                            });
                        return (
                            i && e.push(i),
                            void 0 !== s.camera &&
                                e.push(
                                    n.getDependency("camera", s.camera).then(function (t) {
                                        return n._getNodeRef(n.cameraCache, s.camera, t);
                                    }),
                                ),
                            n
                                ._invokeAll(function (e) {
                                    return e.createNodeAttachment && e.createNodeAttachment(t);
                                })
                                .forEach(function (t) {
                                    e.push(t);
                                }),
                            Promise.all(e)
                        );
                    })().then(function (e) {
                        let a;
                        if (((a = !0 === s.isBone ? new aa() : e.length > 1 ? new Br() : 1 === e.length ? e[0] : new Be()), a !== e[0])) for (let t = 0, i = e.length; t < i; t++) a.add(e[t]);
                        if ((s.name && ((a.userData.name = s.name), (a.name = r)), Bc(a, s), s.extensions && Sc(i, a, s), void 0 !== s.matrix)) {
                            const t = new se();
                            t.fromArray(s.matrix), a.applyMatrix4(t);
                        } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
                        return n.associations.set(a, { type: "nodes", index: t }), a;
                    });
                }
                loadScene(t) {
                    const e = this.json,
                        i = this.extensions,
                        n = this.json.scenes[t],
                        s = this,
                        r = new Br();
                    n.name && (r.name = s.createUniqueName(n.name)), Bc(r, n), n.extensions && Sc(i, r, n);
                    const a = n.nodes || [],
                        o = [];
                    for (let t = 0, i = a.length; t < i; t++) o.push(Pc(a[t], r, e, s));
                    return Promise.all(o).then(function () {
                        return r;
                    });
                }
            }
            function Pc(t, e, i, n) {
                const s = i.nodes[t];
                return n
                    .getDependency("node", t)
                    .then(function (t) {
                        if (void 0 === s.skin) return t;
                        let e;
                        return n
                            .getDependency("skin", s.skin)
                            .then(function (t) {
                                e = t;
                                const i = [];
                                for (let t = 0, s = e.joints.length; t < s; t++) i.push(n.getDependency("node", e.joints[t]));
                                return Promise.all(i);
                            })
                            .then(function (i) {
                                return (
                                    t.traverse(function (t) {
                                        if (!t.isMesh) return;
                                        const n = [],
                                            s = [];
                                        for (let t = 0, r = i.length; t < r; t++) {
                                            const r = i[t];
                                            if (r) {
                                                n.push(r);
                                                const i = new se();
                                                void 0 !== e.inverseBindMatrices && i.fromArray(e.inverseBindMatrices.array, 16 * t), s.push(i);
                                            }
                                        }
                                        t.bind(new ha(n, s), t.matrixWorld);
                                    }),
                                    t
                                );
                            });
                    })
                    .then(function (t) {
                        e.add(t);
                        const r = [];
                        if (s.children) {
                            const e = s.children;
                            for (let s = 0, a = e.length; s < a; s++) {
                                const a = e[s];
                                r.push(Pc(a, t, i, n));
                            }
                        }
                        return Promise.all(r);
                    });
            }
            function Nc(t, e, i) {
                const n = e.attributes,
                    s = [];
                function r(e, n) {
                    return i.getDependency("accessor", e).then(function (e) {
                        t.setAttribute(n, e);
                    });
                }
                for (const e in n) {
                    const i = Ic[e] || e.toLowerCase();
                    i in t.attributes || s.push(r(n[e], i));
                }
                if (void 0 !== e.indices && !t.index) {
                    const n = i.getDependency("accessor", e.indices).then(function (e) {
                        t.setIndex(e);
                    });
                    s.push(n);
                }
                return (
                    Bc(t, e),
                    (function (t, e, i) {
                        const n = e.attributes,
                            s = new Tt();
                        if (void 0 === n.POSITION) return;
                        {
                            const t = i.json.accessors[n.POSITION],
                                e = t.min,
                                r = t.max;
                            if (void 0 === e || void 0 === r) return;
                            if ((s.set(new bt(e[0], e[1], e[2]), new bt(r[0], r[1], r[2])), t.normalized)) {
                                const e = Qc(yc[t.componentType]);
                                s.min.multiplyScalar(e), s.max.multiplyScalar(e);
                            }
                        }
                        const r = e.targets;
                        if (void 0 !== r) {
                            const t = new bt(),
                                e = new bt();
                            for (let n = 0, s = r.length; n < s; n++) {
                                const s = r[n];
                                if (void 0 !== s.POSITION) {
                                    const n = i.json.accessors[s.POSITION],
                                        r = n.min,
                                        a = n.max;
                                    if (void 0 !== r && void 0 !== a) {
                                        if ((e.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))), e.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))), e.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))), n.normalized)) {
                                            const t = Qc(yc[n.componentType]);
                                            e.multiplyScalar(t);
                                        }
                                        t.max(e);
                                    }
                                }
                            }
                            s.expandByVector(t);
                        }
                        t.boundingBox = s;
                        const a = new Jt();
                        s.getCenter(a.center), (a.radius = s.min.distanceTo(s.max) / 2), (t.boundingSphere = a);
                    })(t, e, i),
                    Promise.all(s).then(function () {
                        return void 0 !== e.targets
                            ? (function (t, e, i) {
                                  let n = !1,
                                      s = !1;
                                  for (let t = 0, i = e.length; t < i; t++) {
                                      const i = e[t];
                                      if ((void 0 !== i.POSITION && (n = !0), void 0 !== i.NORMAL && (s = !0), n && s)) break;
                                  }
                                  if (!n && !s) return Promise.resolve(t);
                                  const r = [],
                                      a = [];
                                  for (let o = 0, l = e.length; o < l; o++) {
                                      const l = e[o];
                                      if (n) {
                                          const e = void 0 !== l.POSITION ? i.getDependency("accessor", l.POSITION) : t.attributes.position;
                                          r.push(e);
                                      }
                                      if (s) {
                                          const e = void 0 !== l.NORMAL ? i.getDependency("accessor", l.NORMAL) : t.attributes.normal;
                                          a.push(e);
                                      }
                                  }
                                  return Promise.all([Promise.all(r), Promise.all(a)]).then(function (e) {
                                      const i = e[0],
                                          r = e[1];
                                      return n && (t.morphAttributes.position = i), s && (t.morphAttributes.normal = r), (t.morphTargetsRelative = !0), t;
                                  });
                              })(t, e.targets, i)
                            : t;
                    })
                );
            }
            function Fc(t, e) {
                let i = t.getIndex();
                if (null === i) {
                    const e = [],
                        n = t.getAttribute("position");
                    if (void 0 === n) return t;
                    for (let t = 0; t < n.count; t++) e.push(t);
                    t.setIndex(e), (i = t.getIndex());
                }
                const n = i.count - 2,
                    s = [];
                if (2 === e) for (let t = 1; t <= n; t++) s.push(i.getX(0)), s.push(i.getX(t)), s.push(i.getX(t + 1));
                else for (let t = 0; t < n; t++) t % 2 == 0 ? (s.push(i.getX(t)), s.push(i.getX(t + 1)), s.push(i.getX(t + 2))) : (s.push(i.getX(t + 2)), s.push(i.getX(t + 1)), s.push(i.getX(t)));
                s.length;
                const r = t.clone();
                return r.setIndex(s), r;
            }
            const Uc = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
            var kc, Oc, Gc, zc, Vc, Hc, Wc, qc, jc;
            ((jc = kc || (kc = {}))[(jc.NONE = 0)] = "NONE"),
                (jc[(jc.BASISLZ = 1)] = "BASISLZ"),
                (jc[(jc.ZSTD = 2)] = "ZSTD"),
                (jc[(jc.ZLIB = 3)] = "ZLIB"),
                (function (t) {
                    t[(t.BASICFORMAT = 0)] = "BASICFORMAT";
                })(Oc || (Oc = {})),
                (function (t) {
                    (t[(t.UNSPECIFIED = 0)] = "UNSPECIFIED"), (t[(t.ETC1S = 163)] = "ETC1S"), (t[(t.UASTC = 166)] = "UASTC");
                })(Gc || (Gc = {})),
                (function (t) {
                    (t[(t.UNSPECIFIED = 0)] = "UNSPECIFIED"), (t[(t.SRGB = 1)] = "SRGB");
                })(zc || (zc = {})),
                (function (t) {
                    (t[(t.UNSPECIFIED = 0)] = "UNSPECIFIED"), (t[(t.LINEAR = 1)] = "LINEAR"), (t[(t.SRGB = 2)] = "SRGB"), (t[(t.ITU = 3)] = "ITU"), (t[(t.NTSC = 4)] = "NTSC"), (t[(t.SLOG = 5)] = "SLOG"), (t[(t.SLOG2 = 6)] = "SLOG2");
                })(Vc || (Vc = {})),
                (function (t) {
                    (t[(t.ALPHA_STRAIGHT = 0)] = "ALPHA_STRAIGHT"), (t[(t.ALPHA_PREMULTIPLIED = 1)] = "ALPHA_PREMULTIPLIED");
                })(Hc || (Hc = {})),
                (function (t) {
                    (t[(t.RGB = 0)] = "RGB"), (t[(t.RRR = 3)] = "RRR"), (t[(t.GGG = 4)] = "GGG"), (t[(t.AAA = 15)] = "AAA");
                })(Wc || (Wc = {})),
                (function (t) {
                    (t[(t.RGB = 0)] = "RGB"), (t[(t.RGBA = 3)] = "RGBA"), (t[(t.RRR = 4)] = "RRR"), (t[(t.RRRG = 5)] = "RRRG");
                })(qc || (qc = {}));
            class Yc {
                constructor() {
                    (this.vkFormat = 0), (this.typeSize = 1), (this.pixelWidth = 0), (this.pixelHeight = 0), (this.pixelDepth = 0), (this.layerCount = 0), (this.faceCount = 1), (this.supercompressionScheme = kc.NONE), (this.levels = []), (this.dataFormatDescriptor = [{ vendorId: 0, descriptorType: Oc.BASICFORMAT, versionNumber: 2, descriptorBlockSize: 40, colorModel: Gc.UNSPECIFIED, colorPrimaries: zc.SRGB, transferFunction: zc.SRGB, flags: Hc.ALPHA_STRAIGHT, texelBlockDimension: { x: 4, y: 4, z: 1, w: 1 }, bytesPlane: [], samples: [] }]), (this.keyValue = {}), (this.globalData = null);
                }
            }
            class Jc {
                constructor(t, e, i, n) {
                    (this._dataView = new DataView(t.buffer, t.byteOffset + e, i)), (this._littleEndian = n), (this._offset = 0);
                }
                _nextUint8() {
                    const t = this._dataView.getUint8(this._offset);
                    return (this._offset += 1), t;
                }
                _nextUint16() {
                    const t = this._dataView.getUint16(this._offset, this._littleEndian);
                    return (this._offset += 2), t;
                }
                _nextUint32() {
                    const t = this._dataView.getUint32(this._offset, this._littleEndian);
                    return (this._offset += 4), t;
                }
                _nextUint64() {
                    const t = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                    return (this._offset += 8), t;
                }
                _skip(t) {
                    return (this._offset += t), this;
                }
                _scan(t, e = 0) {
                    const i = this._offset;
                    let n = 0;
                    for (; this._dataView.getUint8(this._offset) !== e && n < t; ) n++, this._offset++;
                    return n < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n);
                }
            }
            function Xc(t) {
                return "undefined" != typeof TextDecoder ? new TextDecoder().decode(t) : n.from(t).toString("utf8");
            }
            const Kc = new WeakMap();
            class Zc extends Xo {
                constructor(t) {
                    super(t), (this.transcoderPath = ""), (this.transcoderBinary = null), (this.transcoderPending = null), (this.workerLimit = 4), (this.workerPool = []), (this.workerNextTaskID = 1), (this.workerSourceURL = ""), (this.workerConfig = null);
                }
                setTranscoderPath(t) {
                    return (this.transcoderPath = t), this;
                }
                setWorkerLimit(t) {
                    return (this.workerLimit = t), this;
                }
                detectSupport(t) {
                    return (this.workerConfig = { astcSupported: t.extensions.has("WEBGL_compressed_texture_astc"), etc1Supported: t.extensions.has("WEBGL_compressed_texture_etc1"), etc2Supported: t.extensions.has("WEBGL_compressed_texture_etc"), dxtSupported: t.extensions.has("WEBGL_compressed_texture_s3tc"), bptcSupported: t.extensions.has("EXT_texture_compression_bptc"), pvrtcSupported: t.extensions.has("WEBGL_compressed_texture_pvrtc") || t.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc") }), this;
                }
                load(t, e, i, n) {
                    const s = new Zo(this.manager);
                    s.setResponseType("arraybuffer"), s.setWithCredentials(this.withCredentials);
                    const r = new Qa();
                    return (
                        s.load(
                            t,
                            (t) => {
                                if (Kc.has(t)) return Kc.get(t).promise.then(e).catch(n);
                                this._createTexture([t])
                                    .then(function (t) {
                                        r.copy(t), (r.needsUpdate = !0), e && e(r);
                                    })
                                    .catch(n);
                            },
                            i,
                            n,
                        ),
                        r
                    );
                }
                parseInternalAsync(t) {
                    const { levels: e } = t,
                        i = new Set();
                    for (let t = 0; t < e.length; t++) i.add(e[t].data.buffer);
                    return this._createTexture(Array.from(i), { ...t, lowLevel: !0 });
                }
                _createTexture(t, e = {}) {
                    let i, n;
                    const s = e;
                    let r = 0;
                    for (let e = 0; e < t.length; e++) r += t[e].byteLength;
                    const a = this._allocateWorker(r)
                        .then(
                            (e) => (
                                (i = e),
                                (n = this.workerNextTaskID++),
                                new Promise((e, r) => {
                                    (i._callbacks[n] = { resolve: e, reject: r }), i.postMessage({ type: "transcode", id: n, buffers: t, taskConfig: s }, t);
                                })
                            ),
                        )
                        .then((t) => {
                            const { mipmaps: e, width: i, height: n, format: s } = t,
                                r = new Qa(e, i, n, s, 1009);
                            return (r.minFilter = 1 === e.length ? 1006 : 1008), (r.magFilter = 1006), (r.generateMipmaps = !1), (r.needsUpdate = !0), r;
                        });
                    return (
                        a
                            .catch(() => !0)
                            .then(() => {
                                i && n && ((i._taskLoad -= r), delete i._callbacks[n]);
                            }),
                        Kc.set(t[0], { promise: a }),
                        a
                    );
                }
                _initTranscoder() {
                    if (!this.transcoderPending) {
                        const t = new Zo(this.manager);
                        t.setPath(this.transcoderPath), t.setWithCredentials(this.withCredentials);
                        const e = new Promise((e, i) => {
                                t.load("basis_transcoder.js", e, void 0, i);
                            }),
                            i = new Zo(this.manager);
                        i.setPath(this.transcoderPath), i.setResponseType("arraybuffer"), i.setWithCredentials(this.withCredentials);
                        const n = new Promise((t, e) => {
                            i.load("basis_transcoder.wasm", t, void 0, e);
                        });
                        this.transcoderPending = Promise.all([e, n]).then(([t, e]) => {
                            const i = Zc.BasisWorker.toString(),
                                n = ["/* constants */", "let _EngineFormat = " + JSON.stringify(Zc.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(Zc.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(Zc.BasisFormat), "/* basis_transcoder.js */", t, "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                            (this.workerSourceURL = URL.createObjectURL(new Blob([n]))), (this.transcoderBinary = e);
                        });
                    }
                    return this.transcoderPending;
                }
                _allocateWorker(t) {
                    return this._initTranscoder().then(() => {
                        if (this.workerPool.length < this.workerLimit) {
                            const t = new Worker(this.workerSourceURL);
                            (t._callbacks = {}),
                                (t._taskLoad = 0),
                                t.postMessage({ type: "init", config: this.workerConfig, transcoderBinary: this.transcoderBinary }),
                                (t.onmessage = function (e) {
                                    const i = e.data;
                                    switch (i.type) {
                                        case "transcode":
                                            t._callbacks[i.id].resolve(i);
                                            break;
                                        case "error":
                                            t._callbacks[i.id].reject(i);
                                    }
                                }),
                                this.workerPool.push(t);
                        } else
                            this.workerPool.sort(function (t, e) {
                                return t._taskLoad > e._taskLoad ? -1 : 1;
                            });
                        const e = this.workerPool[this.workerPool.length - 1];
                        return (e._taskLoad += t), e;
                    });
                }
                dispose() {
                    for (let t = 0; t < this.workerPool.length; t++) this.workerPool[t].terminate();
                    return (this.workerPool.length = 0), this;
                }
            }
            let $c, th, eh;
            (Zc.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }),
                (Zc.TranscoderFormat = { ETC1: 0, ETC2: 1, BC1: 2, BC3: 3, BC4: 4, BC5: 5, BC7_M6_OPAQUE_ONLY: 6, BC7_M5: 7, PVRTC1_4_RGB: 8, PVRTC1_4_RGBA: 9, ASTC_4x4: 10, ATC_RGB: 11, ATC_RGBA_INTERPOLATED_ALPHA: 12, RGBA32: 13, RGB565: 14, BGR565: 15, RGBA4444: 16 }),
                (Zc.EngineFormat = { RGBAFormat: 1023, RGBA_ASTC_4x4_Format: 37808, RGBA_BPTC_Format: 36492, RGBA_ETC2_EAC_Format: 37496, RGBA_PVRTC_4BPPV1_Format: 35842, RGBA_S3TC_DXT5_Format: 33779, RGB_ETC1_Format: 36196, RGB_ETC2_Format: 37492, RGB_PVRTC_4BPPV1_Format: 35840, RGB_S3TC_DXT1_Format: 33776 }),
                (Zc.BasisWorker = function () {
                    let t, e, i;
                    const n = _EngineFormat,
                        s = _TranscoderFormat,
                        r = _BasisFormat;
                    onmessage = function (n) {
                        const s = n.data;
                        switch (s.type) {
                            case "init":
                                (t = s.config),
                                    (a = s.transcoderBinary),
                                    (e = new Promise((t) => {
                                        (i = { wasmBinary: a, onRuntimeInitialized: t }), BASIS(i);
                                    }).then(() => {
                                        i.initializeBasis();
                                    }));
                                break;
                            case "transcode":
                                e.then(() => {
                                    try {
                                        const {
                                                width: t,
                                                height: e,
                                                hasAlpha: n,
                                                mipmaps: a,
                                                format: o,
                                            } = s.taskConfig.lowLevel
                                                ? (function (t) {
                                                      const { basisFormat: e, width: n, height: s, hasAlpha: a } = t,
                                                          { transcoderFormat: o, engineFormat: l } = c(e, n, s, a),
                                                          A = i.getBytesPerBlockOrPixel(o);
                                                      h(i.isFormatSupported(o), "THREE.BasisTextureLoader: Unsupported format.");
                                                      const g = [];
                                                      if (e === r.ETC1S) {
                                                          const e = new i.LowLevelETC1SImageTranscoder(),
                                                              { endpointCount: n, endpointsData: s, selectorCount: r, selectorsData: l, tablesData: c } = t.globalData;
                                                          try {
                                                              let i;
                                                              (i = e.decodePalettes(n, s, r, l)), h(i, "THREE.BasisTextureLoader: decodePalettes() failed."), (i = e.decodeTables(c)), h(i, "THREE.BasisTextureLoader: decodeTables() failed.");
                                                              for (let n = 0; n < t.levels.length; n++) {
                                                                  const s = t.levels[n],
                                                                      r = t.globalData.imageDescs[n],
                                                                      l = p(o, s.width, s.height),
                                                                      c = new Uint8Array(l);
                                                                  (i = e.transcodeImage(o, c, l / A, s.data, u(o, s.width), d(o, s.height), s.width, s.height, s.index, r.rgbSliceByteOffset, r.rgbSliceByteLength, r.alphaSliceByteOffset, r.alphaSliceByteLength, r.imageFlags, a, !1, 0, 0)), h(i, "THREE.BasisTextureLoader: transcodeImage() failed for level " + s.index + "."), g.push({ data: c, width: s.width, height: s.height });
                                                              }
                                                          } finally {
                                                              e.delete();
                                                          }
                                                      } else
                                                          for (let e = 0; e < t.levels.length; e++) {
                                                              const n = t.levels[e],
                                                                  s = p(o, n.width, n.height),
                                                                  r = new Uint8Array(s);
                                                              h(i.transcodeUASTCImage(o, r, s / A, n.data, u(o, n.width), d(o, n.height), n.width, n.height, n.index, 0, n.data.byteLength, 0, a, !1, 0, 0, -1, -1), "THREE.BasisTextureLoader: transcodeUASTCImage() failed for level " + n.index + "."), g.push({ data: r, width: n.width, height: n.height });
                                                          }
                                                      return { width: n, height: s, hasAlpha: a, mipmaps: g, format: l };
                                                  })(s.taskConfig)
                                                : (function (t) {
                                                      const e = new i.BasisFile(new Uint8Array(t)),
                                                          n = e.isUASTC() ? r.UASTC_4x4 : r.ETC1S,
                                                          s = e.getImageWidth(0, 0),
                                                          a = e.getImageHeight(0, 0),
                                                          o = e.getNumLevels(0),
                                                          l = e.getHasAlpha();
                                                      function h() {
                                                          e.close(), e.delete();
                                                      }
                                                      const { transcoderFormat: u, engineFormat: d } = c(n, s, a, l);
                                                      if (!s || !a || !o) throw (h(), new Error("THREE.BasisTextureLoader:\tInvalid texture"));
                                                      if (!e.startTranscoding()) throw (h(), new Error("THREE.BasisTextureLoader: .startTranscoding failed"));
                                                      const p = [];
                                                      for (let t = 0; t < o; t++) {
                                                          const i = e.getImageWidth(0, t),
                                                              n = e.getImageHeight(0, t),
                                                              s = new Uint8Array(e.getImageTranscodedSizeInBytes(0, t, u));
                                                          if (!e.transcodeImage(s, 0, t, u, 0, l)) throw (h(), new Error("THREE.BasisTextureLoader: .transcodeImage failed."));
                                                          p.push({ data: s, width: i, height: n });
                                                      }
                                                      return h(), { width: s, height: a, hasAlpha: l, mipmaps: p, format: d };
                                                  })(s.buffers[0]),
                                            l = [];
                                        for (let t = 0; t < a.length; ++t) l.push(a[t].data.buffer);
                                        self.postMessage({ type: "transcode", id: s.id, width: t, height: e, hasAlpha: n, mipmaps: a, format: o }, l);
                                    } catch (t) {
                                        self.postMessage({ type: "error", id: s.id, error: t.message });
                                    }
                                });
                        }
                        var a;
                    };
                    const a = [
                            { if: "astcSupported", basisFormat: [r.UASTC_4x4], transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4], engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format], priorityETC1S: 1 / 0, priorityUASTC: 1, needsPowerOfTwo: !1 },
                            { if: "bptcSupported", basisFormat: [r.ETC1S, r.UASTC_4x4], transcoderFormat: [s.BC7_M5, s.BC7_M5], engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format], priorityETC1S: 3, priorityUASTC: 2, needsPowerOfTwo: !1 },
                            { if: "dxtSupported", basisFormat: [r.ETC1S, r.UASTC_4x4], transcoderFormat: [s.BC1, s.BC3], engineFormat: [n.RGB_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format], priorityETC1S: 4, priorityUASTC: 5, needsPowerOfTwo: !1 },
                            { if: "etc2Supported", basisFormat: [r.ETC1S, r.UASTC_4x4], transcoderFormat: [s.ETC1, s.ETC2], engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format], priorityETC1S: 1, priorityUASTC: 3, needsPowerOfTwo: !1 },
                            { if: "etc1Supported", basisFormat: [r.ETC1S, r.UASTC_4x4], transcoderFormat: [s.ETC1, s.ETC1], engineFormat: [n.RGB_ETC1_Format, n.RGB_ETC1_Format], priorityETC1S: 2, priorityUASTC: 4, needsPowerOfTwo: !1 },
                            { if: "pvrtcSupported", basisFormat: [r.ETC1S, r.UASTC_4x4], transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA], engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format], priorityETC1S: 5, priorityUASTC: 6, needsPowerOfTwo: !0 },
                        ],
                        o = a.sort(function (t, e) {
                            return t.priorityETC1S - e.priorityETC1S;
                        }),
                        l = a.sort(function (t, e) {
                            return t.priorityUASTC - e.priorityUASTC;
                        });
                    function c(e, i, a, c) {
                        let h, u;
                        const d = e === r.ETC1S ? o : l;
                        for (let n = 0; n < d.length; n++) {
                            const s = d[n];
                            if (t[s.if] && s.basisFormat.includes(e) && (!s.needsPowerOfTwo || (A(i) && A(a)))) return (h = s.transcoderFormat[c ? 1 : 0]), (u = s.engineFormat[c ? 1 : 0]), { transcoderFormat: h, engineFormat: u };
                        }
                        return (h = s.RGBA32), (u = n.RGBAFormat), { transcoderFormat: h, engineFormat: u };
                    }
                    function h(t, e) {
                        if (!t) throw new Error(e);
                    }
                    function u(t, e) {
                        return Math.ceil(e / i.getFormatBlockWidth(t));
                    }
                    function d(t, e) {
                        return Math.ceil(e / i.getFormatBlockHeight(t));
                    }
                    function p(t, e, n) {
                        const r = i.getBytesPerBlockOrPixel(t);
                        if (i.formatIsUncompressed(t)) return e * n * r;
                        if (t === s.PVRTC1_4_RGB || t === s.PVRTC1_4_RGBA) {
                            const t = (e + 3) & -4,
                                i = (n + 3) & -4;
                            return (Math.max(8, t) * Math.max(8, i) * 4 + 7) / 8;
                        }
                        return u(t, e) * d(t, n) * r;
                    }
                    function A(t) {
                        return t <= 2 || (!(t & (t - 1)) && 0 !== t);
                    }
                });
            const ih = {
                env: {
                    emscripten_notify_memory_growth: function (t) {
                        eh = new Uint8Array(th.exports.memory.buffer);
                    },
                },
            };
            class nh {
                init() {
                    return (
                        $c ||
                            ($c = fetch("data:application/wasm;base64," + sh)
                                .then((t) => t.arrayBuffer())
                                .then((t) => WebAssembly.instantiate(t, ih))
                                .then((t) => {
                                    (th = t.instance), ih.env.emscripten_notify_memory_growth(0);
                                })),
                        $c
                    );
                }
                decode(t, e = 0) {
                    const i = t.byteLength,
                        n = th.exports.malloc(i);
                    eh.set(t, n), (e = e || Number(th.exports.ZSTD_findDecompressedSize(n, i)));
                    const s = th.exports.malloc(e),
                        r = th.exports.ZSTD_decompress(s, e, n, i),
                        a = eh.slice(s, s + r);
                    return th.exports.free(n), th.exports.free(s), a;
                }
            }
            const sh =
                "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ";
            var rh,
                ah,
                oh = {
                    createLevels: async function (t, e) {
                        t.supercompressionScheme === kc.ZSTD && (await e.init());
                        for (var i = [], n = t.pixelWidth, s = t.pixelHeight, r = 0; r < t.levels.length; r++) {
                            var a = Math.max(1, Math.floor(n / Math.pow(2, r))),
                                o = Math.max(1, Math.floor(s / Math.pow(2, r))),
                                l = t.levels[r].levelData;
                            t.supercompressionScheme === kc.ZSTD && (l = e.decode(l, t.levels[r].uncompressedByteLength)), i.push({ index: r, width: a, height: o, data: l });
                        }
                        return i;
                    },
                    getBasicDFD: function (t) {
                        return t.dataFormatDescriptor[0];
                    },
                    getAlpha: function (t) {
                        var e = this.getBasicDFD(t);
                        return e.colorModel === Gc.UASTC ? (15 & e.samples[0].channelID) === qc.RGBA : 2 === e.samples.length && (15 & e.samples[1].channelID) === Wc.AAA;
                    },
                    getPremultiplyAlpha: function (t) {
                        return !!(this.getBasicDFD(t).flags & Hc.ALPHA_PREMULTIPLIED);
                    },
                };
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const lh = Symbol("retainerCount"),
                ch = Symbol("recentlyUsed"),
                hh = Symbol("evict"),
                uh = Symbol("evictionThreshold"),
                dh = Symbol("cache");
            class ph {
                constructor(t, e = 5) {
                    (this[rh] = new Map()), (this[ah] = []), (this[dh] = t), (this[uh] = e);
                }
                set evictionThreshold(t) {
                    (this[uh] = t), this[hh]();
                }
                get evictionThreshold() {
                    return this[uh];
                }
                get cache() {
                    return this[dh];
                }
                retainerCount(t) {
                    return this[lh].get(t) || 0;
                }
                reset() {
                    this[lh].clear(), (this[ch] = []);
                }
                retain(t) {
                    this[lh].has(t) || this[lh].set(t, 0), this[lh].set(t, this[lh].get(t) + 1);
                    const e = this[ch].indexOf(t);
                    -1 !== e && this[ch].splice(e, 1), this[ch].unshift(t), this[hh]();
                }
                release(t) {
                    this[lh].has(t) && this[lh].set(t, Math.max(this[lh].get(t) - 1, 0)), this[hh]();
                }
                [((rh = lh), (ah = ch), hh)]() {
                    if (!(this[ch].length < this[uh]))
                        for (let t = this[ch].length - 1; t >= this[uh]; --t) {
                            const e = this[ch][t];
                            0 === this[lh].get(e) && (this[dh].delete(e), this[ch].splice(t, 1));
                        }
                }
            }
            /* @license
             * Copyright 2021 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const Ah = (t, e) => {
                    const i = new Map();
                    for (const n of t.mappings) for (const t of n.variants) i.set(e[t], { material: null, gltfMaterialIndex: n.material });
                    return i;
                },
                gh = (t) => "material" in t && t.userData && t.userData.variantMaterials;
            class mh {
                constructor(t) {
                    (this.parser = t), (this.name = "KHR_materials_variants");
                }
                afterRoot(t) {
                    const e = this.parser,
                        i = e.json;
                    if (void 0 === i.extensions || void 0 === i.extensions[this.name]) return null;
                    const n = ((t) => {
                        const e = [],
                            i = new Set();
                        for (const n of t) {
                            let t = n,
                                s = 0;
                            for (; i.has(t); ) t = n + "." + ++s;
                            i.add(t), e.push(t);
                        }
                        return e;
                    })((i.extensions[this.name].variants || []).map((t) => t.name));
                    for (const s of t.scenes)
                        s.traverse((t) => {
                            const s = e.associations.get(t);
                            if (!s || "nodes" !== s.type) return;
                            const r = i.nodes[s.index].mesh;
                            if (void 0 === r) return;
                            const a = i.meshes[r].primitives,
                                o = "isMesh" in t ? [t] : t.children;
                            for (let t = 0; t < a.length; t++) {
                                const e = a[t].extensions;
                                e && e[this.name] && (o[t].userData.variantMaterials = Ah(e[this.name], n));
                            }
                        });
                    (t.userData.variants = n), (t.userData.functions = t.userData.functions || {});
                    const s = async (t, i, n) => {
                            t.userData.originalMaterial || (t.userData.originalMaterial = t.material);
                            const s = t.material;
                            let r = null;
                            if (null !== i && t.userData.variantMaterials.has(i)) {
                                const n = t.userData.variantMaterials.get(i);
                                n.material ? ((t.material = n.material), "gltfMaterialIndex" in n && (r = n.gltfMaterialIndex)) : ((r = n.gltfMaterialIndex), (t.material = await e.getDependency("material", r)), e.assignFinalMaterial(t), (n.material = t.material));
                            } else (t.material = t.userData.originalMaterial), e.associations.has(t.material) && (r = e.associations.get(t.material).index);
                            null !== n && n(t, s, r);
                        },
                        r = (t) => {
                            const i = t.material,
                                n = t.userData.variantMaterials,
                                s = [];
                            for (const i of n.keys()) {
                                const r = n.get(i);
                                if (r.material) continue;
                                const a = r.gltfMaterialIndex;
                                s.push(
                                    e.getDependency("material", a).then((s) => {
                                        (t.material = s), e.assignFinalMaterial(t), (n.get(i).material = t.material);
                                    }),
                                );
                            }
                            return Promise.all(s).then(() => {
                                t.material = i;
                            });
                        };
                    return (
                        (t.userData.functions.selectVariant = (t, e, i = !0, n = null) => {
                            const r = [];
                            return i ? t.traverse((t) => gh(t) && r.push(s(t, e, n))) : gh(t) && r.push(s(t, e, n)), Promise.all(r);
                        }),
                        (t.userData.functions.ensureLoadVariants = (t, e = !0) => {
                            const i = [];
                            return e ? t.traverse((t) => gh(t) && i.push(r(t))) : gh(t) && i.push(r(t)), Promise.all(i);
                        }),
                        Promise.resolve()
                    );
                    /* @license
                     * Copyright 2019 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            var fh, vh;
            const yh = new Map(),
                xh = new Map();
            let wh;
            const _h = new (class extends Xo {
                constructor(t) {
                    super(t), (this.decoderPath = ""), (this.decoderConfig = {}), (this.decoderBinary = null), (this.decoderPending = null), (this.workerLimit = 4), (this.workerPool = []), (this.workerNextTaskID = 1), (this.workerSourceURL = ""), (this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }), (this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" });
                }
                setDecoderPath(t) {
                    return (this.decoderPath = t), this;
                }
                setDecoderConfig(t) {
                    return (this.decoderConfig = t), this;
                }
                setWorkerLimit(t) {
                    return (this.workerLimit = t), this;
                }
                load(t, e, i, n) {
                    const s = new Zo(this.manager);
                    s.setPath(this.path),
                        s.setResponseType("arraybuffer"),
                        s.setRequestHeader(this.requestHeader),
                        s.setWithCredentials(this.withCredentials),
                        s.load(
                            t,
                            (t) => {
                                const i = { attributeIDs: this.defaultAttributeIDs, attributeTypes: this.defaultAttributeTypes, useUniqueIDs: !1 };
                                this.decodeGeometry(t, i).then(e).catch(n);
                            },
                            i,
                            n,
                        );
                }
                decodeDracoFile(t, e, i, n) {
                    const s = { attributeIDs: i || this.defaultAttributeIDs, attributeTypes: n || this.defaultAttributeTypes, useUniqueIDs: !!i };
                    this.decodeGeometry(t, s).then(e);
                }
                decodeGeometry(t, e) {
                    for (const t in e.attributeTypes) {
                        const i = e.attributeTypes[t];
                        void 0 !== i.BYTES_PER_ELEMENT && (e.attributeTypes[t] = i.name);
                    }
                    const i = JSON.stringify(e);
                    if (Xl.has(t)) {
                        const e = Xl.get(t);
                        if (e.key === i) return e.promise;
                        if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.");
                    }
                    let n;
                    const s = this.workerNextTaskID++,
                        r = t.byteLength,
                        a = this._getWorker(s, r)
                            .then(
                                (i) => (
                                    (n = i),
                                    new Promise((i, r) => {
                                        (n._callbacks[s] = { resolve: i, reject: r }), n.postMessage({ type: "decode", id: s, taskConfig: e, buffer: t }, [t]);
                                    })
                                ),
                            )
                            .then((t) => this._createGeometry(t.geometry));
                    return (
                        a
                            .catch(() => !0)
                            .then(() => {
                                n && s && this._releaseTask(n, s);
                            }),
                        Xl.set(t, { key: i, promise: a }),
                        a
                    );
                }
                _createGeometry(t) {
                    const e = new ui();
                    t.index && e.setIndex(new $e(t.index.array, 1));
                    for (let i = 0; i < t.attributes.length; i++) {
                        const n = t.attributes[i],
                            s = n.name,
                            r = n.array,
                            a = n.itemSize;
                        e.setAttribute(s, new $e(r, a));
                    }
                    return e;
                }
                _loadLibrary(t, e) {
                    const i = new Zo(this.manager);
                    return (
                        i.setPath(this.decoderPath),
                        i.setResponseType(e),
                        i.setWithCredentials(this.withCredentials),
                        new Promise((e, n) => {
                            i.load(t, e, void 0, n);
                        })
                    );
                }
                preload() {
                    return this._initDecoder(), this;
                }
                _initDecoder() {
                    if (this.decoderPending) return this.decoderPending;
                    const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                        e = [];
                    return (
                        t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                        (this.decoderPending = Promise.all(e).then((e) => {
                            const i = e[0];
                            t || (this.decoderConfig.wasmBinary = e[1]);
                            const n = Kl.toString(),
                                s = ["/* draco decoder */", i, "", "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                            this.workerSourceURL = URL.createObjectURL(new Blob([s]));
                        })),
                        this.decoderPending
                    );
                }
                _getWorker(t, e) {
                    return this._initDecoder().then(() => {
                        if (this.workerPool.length < this.workerLimit) {
                            const t = new Worker(this.workerSourceURL);
                            (t._callbacks = {}),
                                (t._taskCosts = {}),
                                (t._taskLoad = 0),
                                t.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
                                (t.onmessage = function (e) {
                                    const i = e.data;
                                    switch (i.type) {
                                        case "decode":
                                            t._callbacks[i.id].resolve(i);
                                            break;
                                        case "error":
                                            t._callbacks[i.id].reject(i);
                                    }
                                }),
                                this.workerPool.push(t);
                        } else
                            this.workerPool.sort(function (t, e) {
                                return t._taskLoad > e._taskLoad ? -1 : 1;
                            });
                        const i = this.workerPool[this.workerPool.length - 1];
                        return (i._taskCosts[t] = e), (i._taskLoad += e), i;
                    });
                }
                _releaseTask(t, e) {
                    (t._taskLoad -= t._taskCosts[e]), delete t._callbacks[e], delete t._taskCosts[e];
                }
                debug() {}
                dispose() {
                    for (let t = 0; t < this.workerPool.length; ++t) this.workerPool[t].terminate();
                    return (this.workerPool.length = 0), this;
                }
            })();
            let Ih;
            const Ch = new (class extends $o {
                    constructor(t) {
                        super(t), (this.basisLoader = new Zc(t)), (this.zstd = new nh()), this.zstd.init();
                    }
                    setTranscoderPath(t) {
                        return this.basisLoader.setTranscoderPath(t), this;
                    }
                    setWorkerLimit(t) {
                        return this.basisLoader.setWorkerLimit(t), this;
                    }
                    detectSupport(t) {
                        return this.basisLoader.detectSupport(t), this;
                    }
                    dispose() {
                        return this.basisLoader.dispose(), this;
                    }
                    load(t, e, i, n) {
                        var s = this,
                            r = new Qa();
                        return (
                            new Promise(function (e, n) {
                                new Zo(s.manager).setPath(s.path).setResponseType("arraybuffer").load(t, e, i, n);
                            })
                                .then(function (t) {
                                    s.parse(
                                        t,
                                        function (t) {
                                            r.copy(t), (r.needsUpdate = !0), e && e(r);
                                        },
                                        n,
                                    );
                                })
                                .catch(n),
                            r
                        );
                    }
                    parse(t, e, i) {
                        var n = this,
                            s = (function (t) {
                                const e = new Uint8Array(t.buffer, t.byteOffset, Uc.length);
                                if (e[0] !== Uc[0] || e[1] !== Uc[1] || e[2] !== Uc[2] || e[3] !== Uc[3] || e[4] !== Uc[4] || e[5] !== Uc[5] || e[6] !== Uc[6] || e[7] !== Uc[7] || e[8] !== Uc[8] || e[9] !== Uc[9] || e[10] !== Uc[10] || e[11] !== Uc[11]) throw new Error("Missing KTX 2.0 identifier.");
                                const i = new Yc(),
                                    n = 17 * Uint32Array.BYTES_PER_ELEMENT,
                                    s = new Jc(t, Uc.length, n, !0);
                                (i.vkFormat = s._nextUint32()), (i.typeSize = s._nextUint32()), (i.pixelWidth = s._nextUint32()), (i.pixelHeight = s._nextUint32()), (i.pixelDepth = s._nextUint32()), (i.layerCount = s._nextUint32()), (i.faceCount = s._nextUint32());
                                const r = s._nextUint32();
                                i.supercompressionScheme = s._nextUint32();
                                const a = s._nextUint32(),
                                    o = s._nextUint32(),
                                    l = s._nextUint32(),
                                    c = s._nextUint32(),
                                    h = s._nextUint64(),
                                    u = s._nextUint64(),
                                    d = new Jc(t, Uc.length + n, 3 * r * 8, !0);
                                for (let e = 0; e < r; e++) i.levels.push({ levelData: new Uint8Array(t.buffer, t.byteOffset + d._nextUint64(), d._nextUint64()), uncompressedByteLength: d._nextUint64() });
                                const p = new Jc(t, a, o, !0),
                                    A = { vendorId: p._skip(4)._nextUint16(), descriptorType: p._nextUint16(), versionNumber: p._nextUint16(), descriptorBlockSize: p._nextUint16(), colorModel: p._nextUint8(), colorPrimaries: p._nextUint8(), transferFunction: p._nextUint8(), flags: p._nextUint8(), texelBlockDimension: { x: p._nextUint8() + 1, y: p._nextUint8() + 1, z: p._nextUint8() + 1, w: p._nextUint8() + 1 }, bytesPlane: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], samples: [] },
                                    g = (A.descriptorBlockSize / 4 - 6) / 4;
                                for (let t = 0; t < g; t++) A.samples[t] = { bitOffset: p._nextUint16(), bitLength: p._nextUint8(), channelID: p._nextUint8(), samplePosition: [p._nextUint8(), p._nextUint8(), p._nextUint8(), p._nextUint8()], sampleLower: p._nextUint32(), sampleUpper: p._nextUint32() };
                                (i.dataFormatDescriptor.length = 0), i.dataFormatDescriptor.push(A);
                                const m = new Jc(t, l, c, !0);
                                for (; m._offset < c; ) {
                                    const t = m._nextUint32(),
                                        e = m._scan(t),
                                        n = Xc(e),
                                        s = m._scan(t - e.byteLength);
                                    (i.keyValue[n] = n.match(/^ktx/i) ? Xc(s) : s), m._offset % 4 && m._skip(4 - (m._offset % 4));
                                }
                                if (u <= 0) return i;
                                const f = new Jc(t, h, u, !0),
                                    v = f._nextUint16(),
                                    y = f._nextUint16(),
                                    x = f._nextUint32(),
                                    w = f._nextUint32(),
                                    _ = f._nextUint32(),
                                    I = f._nextUint32(),
                                    C = [];
                                for (let t = 0; t < r; t++) C.push({ imageFlags: f._nextUint32(), rgbSliceByteOffset: f._nextUint32(), rgbSliceByteLength: f._nextUint32(), alphaSliceByteOffset: f._nextUint32(), alphaSliceByteLength: f._nextUint32() });
                                const M = h + f._offset,
                                    E = M + x,
                                    b = E + w,
                                    S = b + _,
                                    B = new Uint8Array(t.buffer, t.byteOffset + M, x),
                                    T = new Uint8Array(t.buffer, t.byteOffset + E, w),
                                    L = new Uint8Array(t.buffer, t.byteOffset + b, _),
                                    D = new Uint8Array(t.buffer, t.byteOffset + S, I);
                                return (i.globalData = { endpointCount: v, selectorCount: y, imageDescs: C, endpointsData: B, selectorsData: T, tablesData: L, extendedData: D }), i;
                            })(new Uint8Array(t));
                        if (s.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Only 2D textures are currently supported.");
                        if (s.layerCount > 1) throw new Error("THREE.KTX2Loader: Array textures are not currently supported.");
                        if (s.faceCount > 1) throw new Error("THREE.KTX2Loader: Cube textures are not currently supported.");
                        var r = oh.getBasicDFD(s);
                        return (
                            oh
                                .createLevels(s, this.zstd)
                                .then(function (t) {
                                    var e = r.colorModel === Gc.UASTC ? Zc.BasisFormat.UASTC_4x4 : Zc.BasisFormat.ETC1S,
                                        i = { levels: t, width: s.pixelWidth, height: s.pixelHeight, basisFormat: e, hasAlpha: oh.getAlpha(s) };
                                    return e === Zc.BasisFormat.ETC1S && (i.globalData = s.globalData), n.basisLoader.parseInternalAsync(i);
                                })
                                .then(function (t) {
                                    (t.encoding = r.transferFunction === Vc.SRGB ? 3001 : 3e3), (t.premultiplyAlpha = oh.getPremultiplyAlpha(s)), e(t);
                                })
                                .catch(i),
                            this
                        );
                    }
                })(),
                Mh = Symbol("loader"),
                Eh = Symbol("evictionPolicy"),
                bh = Symbol("GLTFInstance");
            class Sh extends nt {
                constructor(t) {
                    super(), (this[vh] = new Zl().register((t) => new mh(t))), (this[bh] = t), this[Mh].setDRACOLoader(_h), this[Mh].setKTX2Loader(Ch);
                }
                static setDRACODecoderLocation(t) {
                    (wh = t), _h.setDecoderPath(t);
                }
                static getDRACODecoderLocation() {
                    return wh;
                }
                static setKTX2TranscoderLocation(t) {
                    (Ih = t), Ch.setTranscoderPath(t);
                }
                static getKTX2TranscoderLocation() {
                    return Ih;
                }
                static initializeKTX2Loader(t) {
                    Ch.detectSupport(t);
                }
                static get cache() {
                    return yh;
                }
                static clearCache() {
                    yh.forEach((t, e) => {
                        this.delete(e);
                    }),
                        this[Eh].reset();
                }
                static has(t) {
                    return yh.has(t);
                }
                static async delete(t) {
                    if (!this.has(t)) return;
                    const e = yh.get(t);
                    xh.delete(t), yh.delete(t), (await e).dispose();
                }
                static hasFinishedLoading(t) {
                    return !!xh.get(t);
                }
                get [((fh = Eh), (vh = Mh), Eh)]() {
                    return this.constructor[Eh];
                }
                async preload(t, e, i = () => {}) {
                    if ((this.dispatchEvent({ type: "preload", element: e, src: t }), !yh.has(t))) {
                        const e = ((t, e, i = () => {}) => {
                                const n = (t) => {
                                    const e = t.loaded / t.total;
                                    i(Math.max(0, Math.min(1, isFinite(e) ? e : 1)));
                                };
                                return new Promise((i, s) => {
                                    e.load(t, i, n, s);
                                });
                            })(t, this[Mh], (t) => {
                                i(0.8 * t);
                            }),
                            n = this[bh],
                            s = e.then((t) => n.prepare(t)).then((t) => (i(0.9), new n(t)));
                        yh.set(t, s);
                    }
                    await yh.get(t), xh.set(t, !0), i && i(1);
                }
                async load(t, e, i = () => {}) {
                    await this.preload(t, e, i);
                    const n = await yh.get(t),
                        s = await n.clone();
                    return (
                        this[Eh].retain(t),
                        (s.dispose = (() => {
                            const e = s.dispose;
                            let i = !1;
                            return () => {
                                i || ((i = !0), e.apply(s), this[Eh].release(t));
                            };
                        })()),
                        s
                    );
                }
            }
            Sh[fh] = new ph(Sh);
            class Bh extends Be {
                constructor(t) {
                    super(),
                        (this.element = t || document.createElement("div")),
                        (this.element.style.position = "absolute"),
                        (this.element.style.userSelect = "none"),
                        this.element.setAttribute("draggable", !1),
                        this.addEventListener("removed", function () {
                            this.traverse(function (t) {
                                t.element instanceof Element && null !== t.element.parentNode && t.element.parentNode.removeChild(t.element);
                            });
                        });
                }
                copy(t, e) {
                    return super.copy(t, e), (this.element = t.element.cloneNode(!0)), this;
                }
            }
            Bh.prototype.isCSS2DObject = !0;
            const Th = new bt(),
                Lh = new se(),
                Dh = new se(),
                Qh = new bt(),
                Rh = new bt();
            class Ph {
                constructor() {
                    const t = this;
                    let e, i, n, s;
                    const r = { objects: new WeakMap() },
                        a = document.createElement("div");
                    function o(e, i, c) {
                        if (e.isCSS2DObject) {
                            e.onBeforeRender(t, i, c), Th.setFromMatrixPosition(e.matrixWorld), Th.applyMatrix4(Dh);
                            const o = e.element;
                            /apple/i.test(navigator.vendor) ? (o.style.transform = "translate(-50%,-50%) translate(" + Math.round(Th.x * n + n) + "px," + Math.round(-Th.y * s + s) + "px)") : (o.style.transform = "translate(-50%,-50%) translate(" + (Th.x * n + n) + "px," + (-Th.y * s + s) + "px)"), (o.style.display = e.visible && Th.z >= -1 && Th.z <= 1 ? "" : "none");
                            const h = { distanceToCameraSquared: l(c, e) };
                            r.objects.set(e, h), o.parentNode !== a && a.appendChild(o), e.onAfterRender(t, i, c);
                        }
                        for (let t = 0, n = e.children.length; t < n; t++) o(e.children[t], i, c);
                    }
                    function l(t, e) {
                        return Qh.setFromMatrixPosition(t.matrixWorld), Rh.setFromMatrixPosition(e.matrixWorld), Qh.distanceToSquared(Rh);
                    }
                    (a.style.overflow = "hidden"),
                        (this.domElement = a),
                        (this.getSize = function () {
                            return { width: e, height: i };
                        }),
                        (this.render = function (t, e) {
                            !0 === t.autoUpdate && t.updateMatrixWorld(),
                                null === e.parent && e.updateMatrixWorld(),
                                Lh.copy(e.matrixWorldInverse),
                                Dh.multiplyMatrices(e.projectionMatrix, Lh),
                                o(t, t, e),
                                (function (t) {
                                    const e = (function (t) {
                                            const e = [];
                                            return (
                                                t.traverse(function (t) {
                                                    t.isCSS2DObject && e.push(t);
                                                }),
                                                e
                                            );
                                        })(t).sort(function (t, e) {
                                            return r.objects.get(t).distanceToCameraSquared - r.objects.get(e).distanceToCameraSquared;
                                        }),
                                        i = e.length;
                                    for (let t = 0, n = e.length; t < n; t++) e[t].element.style.zIndex = i - t;
                                })(t);
                        }),
                        (this.setSize = function (t, r) {
                            (e = t), (i = r), (n = e / 2), (s = i / 2), (a.style.width = t + "px"), (a.style.height = r + "px");
                        });
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const Nh = (t) => (t && "null" !== t ? Uh(t) : null),
                Fh = () => {
                    if (J) return;
                    const t = [];
                    throw (W || t.push("WebXR Device API"), q || t.push("WebXR Hit Test API"), new Error(`The following APIs are required for AR, but are missing in this browser: ${t.join(", ")}`));
                },
                Uh = (t) => new URL(t, window.location.toString()).toString(),
                kh = (t, e) => {
                    let i = null;
                    return (...n) => {
                        null != i && self.clearTimeout(i),
                            (i = self.setTimeout(() => {
                                (i = null), t(...n);
                            }, e));
                    };
                },
                Oh = (t, e, i) => Math.max(e, Math.min(i, t)),
                Gh = (() => {
                    const t = (() => {
                        const t = null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [];
                        for (const e of t) if ("viewport" === e.name) return !0;
                        return !1;
                    })();
                    return () => (t ? window.devicePixelRatio : 1);
                })(),
                zh = (() => {
                    const t = new RegExp("[?&]model-viewer-debug-mode(&|$)");
                    return () => (self.ModelViewerElement && self.ModelViewerElement.debugMode) || (self.location && self.location.search && self.location.search.match(t));
                })();
            class Vh {
                constructor(t = 50) {
                    (this.velocity = 0), (this.naturalFrequency = 0), this.setDecayTime(t);
                }
                setDecayTime(t) {
                    this.naturalFrequency = 1 / Math.max(0.001, t);
                }
                update(t, e, i, n) {
                    const s = 2e-4 * this.naturalFrequency;
                    if (null == t || 0 === n) return e;
                    if (t === e && 0 === this.velocity) return e;
                    if (i < 0) return t;
                    const r = t - e,
                        a = this.velocity + this.naturalFrequency * r,
                        o = r + i * a,
                        l = Math.exp(-this.naturalFrequency * i),
                        c = (a - this.naturalFrequency * o) * l,
                        h = -this.naturalFrequency * (c + a * l);
                    return Math.abs(c) < s * Math.abs(n) && h * r >= 0
                        ? ((this.velocity = 0), e)
                        : ((this.velocity = c), e + o * l);
                          /* @license
                           * Copyright 2019 Google LLC. All Rights Reserved.
                           * Licensed under the Apache License, Version 2.0 (the 'License');
                           * you may not use this file except in compliance with the License.
                           * You may obtain a copy of the License at
                           *
                           *     http://www.apache.org/licenses/LICENSE-2.0
                           *
                           * Unless required by applicable law or agreed to in writing, software
                           * distributed under the License is distributed on an 'AS IS' BASIS,
                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                           * See the License for the specific language governing permissions and
                           * limitations under the License.
                           */
                }
            }
            const Hh = (t, e) => ({ type: "number", number: t, unit: e }),
                Wh = (() => {
                    const t = {};
                    return (e) => {
                        const i = e;
                        if (i in t) return t[i];
                        const n = [];
                        let s = 0;
                        for (; e; ) {
                            if (++s > 1e3) {
                                e = "";
                                break;
                            }
                            const t = qh(e),
                                i = t.nodes[0];
                            if (null == i || 0 === i.terms.length) break;
                            n.push(i), (e = t.remainingInput);
                        }
                        return (t[i] = n);
                    };
                })(),
                qh = (() => {
                    const t = /^(\-\-|[a-z\u0240-\uffff])/i,
                        e = /^([\*\+\/]|[\-]\s)/i,
                        i = /^[\),]/;
                    return (n) => {
                        const s = [];
                        for (; n.length && ((n = n.trim()), !i.test(n)); )
                            if ("(" === n[0]) {
                                const { nodes: t, remainingInput: e } = Xh(n);
                                (n = e), s.push({ type: "function", name: { type: "ident", value: "calc" }, arguments: t });
                            } else if (t.test(n)) {
                                const t = jh(n),
                                    e = t.nodes[0];
                                if ("(" === (n = t.remainingInput)[0]) {
                                    const { nodes: t, remainingInput: i } = Xh(n);
                                    s.push({ type: "function", name: e, arguments: t }), (n = i);
                                } else s.push(e);
                            } else if (e.test(n)) s.push({ type: "operator", value: n[0] }), (n = n.slice(1));
                            else {
                                const { nodes: t, remainingInput: e } = "#" === n[0] ? Jh(n) : Yh(n);
                                if (0 === t.length) break;
                                s.push(t[0]), (n = e);
                            }
                        return { nodes: [{ type: "expression", terms: s }], remainingInput: n };
                    };
                })(),
                jh = (() => {
                    const t = /[^a-z0-9_\-\u0240-\uffff]/i;
                    return (e) => {
                        const i = e.match(t);
                        return { nodes: [{ type: "ident", value: null == i ? e : e.substr(0, i.index) }], remainingInput: null == i ? "" : e.substr(i.index) };
                    };
                })(),
                Yh = (() => {
                    const t = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
                        e = /^[a-z%]+/i,
                        i = /^(m|mm|cm|rad|deg|[%])$/;
                    return (n) => {
                        const s = n.match(t),
                            r = null == s ? "0" : s[0],
                            a = (n = null == r ? n : n.slice(r.length)).match(e);
                        let o = null != a && "" !== a[0] ? a[0] : null;
                        const l = null == a ? n : n.slice(o.length);
                        return null == o || i.test(o) || (o = null), { nodes: [{ type: "number", number: parseFloat(r) || 0, unit: o }], remainingInput: l };
                    };
                })(),
                Jh = (() => {
                    const t = /^[a-f0-9]*/i;
                    return (e) => {
                        const i = (e = e.slice(1).trim()).match(t);
                        return { nodes: null == i ? [] : [{ type: "hex", value: i[0] }], remainingInput: null == i ? e : e.slice(i[0].length) };
                    };
                })(),
                Xh = (t) => {
                    const e = [];
                    for (t = t.slice(1).trim(); t.length; ) {
                        const i = qh(t);
                        if ((e.push(i.nodes[0]), "," === (t = i.remainingInput.trim())[0])) t = t.slice(1).trim();
                        else if (")" === t[0]) {
                            t = t.slice(1);
                            break;
                        }
                    }
                    return { nodes: e, remainingInput: t };
                },
                Kh = Symbol("visitedTypes");
            class Zh {
                constructor(t) {
                    this[Kh] = t;
                }
                walk(t, e) {
                    const i = t.slice();
                    for (; i.length; ) {
                        const t = i.shift();
                        switch ((this[Kh].indexOf(t.type) > -1 && e(t), t.type)) {
                            case "expression":
                                i.unshift(...t.terms);
                                break;
                            case "function":
                                i.unshift(t.name, ...t.arguments);
                        }
                    }
                }
            }
            const $h = Object.freeze({ type: "number", number: 0, unit: null }),
                tu = (t, e = 0) => {
                    let { number: i, unit: n } = t;
                    if (isFinite(i)) {
                        if ("rad" === t.unit || null == t.unit) return t;
                    } else (i = e), (n = "rad");
                    return { type: "number", number: (("deg" === n && null != i ? i : 0) * Math.PI) / 180, unit: "rad" };
                },
                eu = (t, e = 0) => {
                    let i,
                        { number: n, unit: s } = t;
                    if (isFinite(n)) {
                        if ("m" === t.unit) return t;
                    } else (n = e), (s = "m");
                    switch (s) {
                        default:
                            i = 1;
                            break;
                        case "cm":
                            i = 0.01;
                            break;
                        case "mm":
                            i = 0.001;
                    }
                    return { type: "number", number: i * n, unit: "m" };
                },
                iu = (() => {
                    const t = (t) => t,
                        e = { rad: t, deg: tu, m: t, mm: eu, cm: eu };
                    return (t, i = $h) => {
                        isFinite(t.number) || ((t.number = i.number), (t.unit = i.unit));
                        const { unit: n } = t;
                        if (null == n) return t;
                        const s = e[n];
                        return null == s ? i : s(t);
                    };
                })();
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ class nu extends Bh {
                constructor(t) {
                    super(document.createElement("div")), (this.normal = new bt(0, 1, 0)), (this.initialized = !1), (this.referenceCount = 1), (this.pivot = document.createElement("div")), (this.slot = document.createElement("slot")), this.element.classList.add("annotation-wrapper"), (this.slot.name = t.name), this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(t.position), this.updateNormal(t.normal);
                }
                get facingCamera() {
                    return !this.element.classList.contains("hide");
                }
                show() {
                    (this.facingCamera && this.initialized) || this.updateVisibility(!0);
                }
                hide() {
                    (!this.facingCamera && this.initialized) || this.updateVisibility(!1);
                }
                increment() {
                    this.referenceCount++;
                }
                decrement() {
                    return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount;
                }
                updatePosition(t) {
                    if (null == t) return;
                    const e = Wh(t)[0].terms;
                    for (let t = 0; t < 3; ++t) this.position.setComponent(t, iu(e[t]).number);
                    this.updateMatrixWorld();
                }
                updateNormal(t) {
                    if (null == t) return;
                    const e = Wh(t)[0].terms;
                    for (let t = 0; t < 3; ++t) this.normal.setComponent(t, iu(e[t]).number);
                }
                orient(t) {
                    this.pivot.style.transform = `rotate(${t}rad)`;
                }
                updateVisibility(t) {
                    t ? this.element.classList.remove("hide") : this.element.classList.add("hide"),
                        this.slot.assignedNodes().forEach((e) => {
                            if (e.nodeType !== Node.ELEMENT_NODE) return;
                            const i = e,
                                n = i.dataset.visibilityAttribute;
                            if (null != n) {
                                const e = `data-${n}`;
                                t ? i.setAttribute(e, "") : i.removeAttribute(e);
                            }
                            i.dispatchEvent(new CustomEvent("hotspot-visibility", { detail: { visible: t } }));
                        }),
                        (this.initialized = !0);
                    /* @license
                     * Copyright 2019 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            const su = (t, e, i) => {
                let n = i;
                const s = new bt();
                return (
                    t.traverse((t) => {
                        let i, r;
                        t.updateWorldMatrix(!1, !1);
                        const a = t.geometry;
                        if (void 0 !== a)
                            if (a.isGeometry) {
                                const o = a.vertices;
                                for (i = 0, r = o.length; i < r; i++) s.copy(o[i]), s.applyMatrix4(t.matrixWorld), (n = e(n, s));
                            } else if (a.isBufferGeometry) {
                                const { position: o } = a.attributes;
                                if (void 0 !== o) {
                                    const a = ((t) => {
                                        if (!t.normalized) return 1;
                                        const e = t.array;
                                        return e instanceof Int8Array ? 1 / 127 : e instanceof Uint8Array ? 1 / 255 : e instanceof Int16Array ? 1 / 32767 : e instanceof Uint16Array ? 1 / 65535 : 1;
                                    })(o);
                                    for (i = 0, r = o.count; i < r; i++) s.fromBufferAttribute(o, i), s.multiplyScalar(a), s.applyMatrix4(t.matrixWorld), (n = e(n, s));
                                }
                            }
                    }),
                    n
                );
            };
            class ru extends xl {
                constructor(t, e, i) {
                    super(), (this.shadowMaterial = new To()), (this.boundingBox = new Tt()), (this.size = new bt()), (this.shadowScale = 1), (this.isAnimated = !1), (this.side = "bottom"), (this.needsUpdate = !1), (this.intensity = 0), (this.castShadow = !0), (this.frustumCulled = !1), (this.floor = new Bi(new Xi(), this.shadowMaterial)), this.floor.rotateX(-Math.PI / 2), (this.floor.receiveShadow = !0), (this.floor.castShadow = !1), (this.floor.frustumCulled = !1), this.add(this.floor), t.target.add(this), (this.target = t.target), this.setScene(t, e, i);
                }
                setScene(t, e, i) {
                    if (((this.side = i), (this.isAnimated = t.animationNames.length > 0), this.boundingBox.copy(t.boundingBox), this.size.copy(t.size), "back" === this.side)) {
                        const { min: t, max: e } = this.boundingBox;
                        ([t.y, t.z] = [t.z, t.y]), ([e.y, e.z] = [e.z, e.y]), ([this.size.y, this.size.z] = [this.size.z, this.size.y]), (this.rotation.x = Math.PI / 2), (this.rotation.y = Math.PI);
                    }
                    const { boundingBox: n, size: s } = this;
                    if (this.isAnimated) {
                        const t = 2 * Math.max(s.x, s.y, s.z);
                        (s.y = t), n.expandByVector(s.subScalar(t).multiplyScalar(-0.5)), (n.max.y = n.min.y + t), s.set(t, t, t);
                    }
                    n.getCenter(this.floor.position);
                    const r = n.max.y + 0.002 * s.y;
                    "bottom" === i ? ((this.position.y = r), this.shadow.camera.up.set(0, 0, 1)) : ((this.position.y = 0), (this.position.z = r), this.shadow.camera.up.set(0, 1, 0)), this.setSoftness(e);
                }
                setSoftness(t) {
                    const e = Math.pow(2, 9 - 3 * t);
                    this.setMapSize(e);
                }
                setMapSize(t) {
                    const { camera: e, mapSize: i, map: n } = this.shadow,
                        { size: s, boundingBox: r } = this;
                    null != n && (n.dispose(), (this.shadow.map = null)), this.isAnimated && (t *= 2);
                    const a = Math.floor(s.x > s.z ? t : (t * s.x) / s.z),
                        o = Math.floor(s.x > s.z ? (t * s.z) / s.x : t);
                    i.set(a, o);
                    const l = (2.5 * s.x) / a,
                        c = (2.5 * s.z) / o;
                    (e.left = -r.max.x - l), (e.right = -r.min.x + l), (e.bottom = r.min.z - c), (e.top = r.max.z + c), this.setScaleAndOffset(this.shadowScale, 0), this.floor.scale.set(s.x + 2 * l, s.z + 2 * c, 1), (this.needsUpdate = !0);
                }
                setIntensity(t) {
                    (this.shadowMaterial.opacity = t), t > 0 ? ((this.visible = !0), (this.floor.visible = !0)) : ((this.visible = !1), (this.floor.visible = !1));
                }
                getIntensity() {
                    return this.shadowMaterial.opacity;
                }
                setRotation(t) {
                    "bottom" === this.side ? (this.shadow.camera.up.set(Math.sin(t), 0, Math.cos(t)), this.shadow.updateMatrices(this)) : this.shadow.updateMatrices(this);
                }
                setScaleAndOffset(t, e) {
                    const i = this.size.y,
                        { camera: n } = this.shadow;
                    (this.shadowScale = t), (n.near = 0), (n.far = i - e / t), n.updateProjectionMatrix(), n.scale.setScalar(t);
                    const s = 0.002 * i;
                    this.floor.position.y = 2 * s - n.far;
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const au = (22.5 * Math.PI) / 180,
                ou = Math.sin(au),
                lu = Math.tan(au),
                cu = new bt(),
                hu = new bt(),
                uu = new bt(),
                du = new (class {
                    constructor(t, e, i = 0, n = 1 / 0) {
                        (this.ray = new ne(t, e)), (this.near = i), (this.far = n), (this.camera = null), (this.layers = new ge()), (this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} });
                    }
                    set(t, e) {
                        this.ray.set(t, e);
                    }
                    setFromCamera(t, e) {
                        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), (this.camera = e)) : e && e.isOrthographicCamera && (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), (this.camera = e));
                    }
                    intersectObject(t, e = !1, i = []) {
                        return Ol(t, this, i, e), i.sort(kl), i;
                    }
                    intersectObjects(t, e = !1, i = []) {
                        for (let n = 0, s = t.length; n < s; n++) Ol(t[n], this, i, e);
                        return i.sort(kl), i;
                    }
                })(),
                pu = new bt();
            class Au extends Pr {
                constructor({ canvas: t, element: e, width: i, height: n }) {
                    super(), (this.context = null), (this.annotationRenderer = new Ph()), (this.width = 1), (this.height = 1), (this.aspect = 1), (this.isDirty = !1), (this.renderCount = 0), (this.externalRenderer = null), (this.camera = new Fi(45, 1, 0.1, 100)), (this.xrCamera = null), (this.url = null), (this.target = new Be()), (this.modelContainer = new Be()), (this.animationNames = []), (this.boundingBox = new Tt()), (this.size = new bt()), (this.idealCameraDistance = 0), (this.fieldOfViewAspect = 0), (this.framedFieldOfView = 45), (this.shadow = null), (this.shadowIntensity = 0), (this.shadowSoftness = 1), (this.exposure = 1), (this.canScale = !0), (this.tightBounds = !1), (this.goalTarget = new bt()), (this.targetDamperX = new Vh()), (this.targetDamperY = new Vh()), (this.targetDamperZ = new Vh()), (this._currentGLTF = null), (this.cancelPendingSourceChange = null), (this.animationsByName = new Map()), (this.currentAnimationAction = null), (this.name = "ModelScene"), (this.element = e), (this.canvas = t), (this.camera = new Fi(45, 1, 0.1, 100)), (this.camera.name = "MainCamera"), this.add(this.target), this.setSize(i, n), (this.target.name = "Target"), (this.modelContainer.name = "ModelContainer"), this.target.add(this.modelContainer), (this.mixer = new Ul(this.modelContainer));
                    const { domElement: s } = this.annotationRenderer,
                        { style: r } = s;
                    (r.display = "none"), (r.pointerEvents = "none"), (r.position = "absolute"), (r.top = "0"), this.element.shadowRoot.querySelector(".default").appendChild(s);
                }
                createContext() {
                    this.context = this.canvas.getContext("2d");
                }
                getCamera() {
                    return null != this.xrCamera ? this.xrCamera : this.camera;
                }
                async setObject(t) {
                    this.reset(), this.modelContainer.add(t), await this.setupScene();
                }
                async setSource(t, e = () => {}) {
                    if (!t || t === this.url) return void e(1);
                    if ((this.reset(), (this.url = t), null != this.externalRenderer)) {
                        const t = await this.externalRenderer.load(e);
                        return (this.idealCameraDistance = t.framedRadius / ou), (this.fieldOfViewAspect = t.fieldOfViewAspect), this.frameModel(), void this.dispatchEvent({ type: "model-load", url: this.url });
                    }
                    let i;
                    null != this.cancelPendingSourceChange && (this.cancelPendingSourceChange(), (this.cancelPendingSourceChange = null));
                    try {
                        i = await new Promise(async (i, n) => {
                            this.cancelPendingSourceChange = () => n();
                            try {
                                i(await this.element[sp].loader.load(t, this.element, e));
                            } catch (t) {
                                n(t);
                            }
                        });
                    } catch (t) {
                        if (null == t) return;
                        throw t;
                    }
                    this.reset(), (this.url = t), (this._currentGLTF = i), null != i && this.modelContainer.add(i.scene);
                    const { animations: n } = i,
                        s = new Map(),
                        r = [];
                    for (const t of n) s.set(t.name, t), r.push(t.name);
                    (this.animations = n), (this.animationsByName = s), (this.animationNames = r), await this.setupScene();
                }
                async setupScene() {
                    this.updateBoundingBox();
                    let t = null;
                    !0 === this.tightBounds && (await this.element.requestUpdate("cameraTarget"), (t = this.getTarget())), this.updateFraming(t), this.frameModel(), this.setShadowIntensity(this.shadowIntensity), this.dispatchEvent({ type: "model-load", url: this.url });
                }
                reset() {
                    (this.url = null), (this.isDirty = !0), null != this.shadow && this.shadow.setIntensity(0);
                    const t = this._currentGLTF;
                    if (null != t) {
                        for (const t of this.modelContainer.children) this.modelContainer.remove(t);
                        t.dispose(), (this._currentGLTF = null);
                    }
                    null != this.currentAnimationAction && (this.currentAnimationAction.stop(), (this.currentAnimationAction = null)), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this);
                }
                get currentGLTF() {
                    return this._currentGLTF;
                }
                setSize(t, e) {
                    if (this.width !== t || this.height !== e) {
                        if (((this.width = Math.max(t, 1)), (this.height = Math.max(e, 1)), this.annotationRenderer.setSize(t, e), (this.aspect = this.width / this.height), this.frameModel(), null != this.externalRenderer)) {
                            const i = Gh();
                            this.externalRenderer.resize(t * i, e * i);
                        }
                        this.isDirty = !0;
                    }
                }
                updateBoundingBox() {
                    if ((this.target.remove(this.modelContainer), !0 === this.tightBounds)) {
                        const t = (t, e) => t.expandByPoint(e);
                        this.boundingBox = su(this.modelContainer, t, new Tt());
                    } else this.boundingBox.setFromObject(this.modelContainer);
                    this.boundingBox.getSize(this.size), this.target.add(this.modelContainer);
                }
                updateFraming(t = null) {
                    this.target.remove(this.modelContainer), null == t && (t = this.boundingBox.getCenter(new bt()));
                    const e = Math.sqrt(su(this.modelContainer, (e, i) => Math.max(e, t.distanceToSquared(i)), 0));
                    (this.idealCameraDistance = e / ou),
                        (this.fieldOfViewAspect =
                            su(
                                this.modelContainer,
                                (e, i) => {
                                    i.sub(t);
                                    const n = Math.sqrt(i.x * i.x + i.z * i.z);
                                    return Math.max(e, n / (this.idealCameraDistance - Math.abs(i.y)));
                                },
                                0,
                            ) / lu),
                        this.target.add(this.modelContainer);
                }
                frameModel() {
                    const t = lu * Math.max(1, this.fieldOfViewAspect / this.aspect);
                    this.framedFieldOfView = (2 * Math.atan(t) * 180) / Math.PI;
                }
                getSize() {
                    return { width: this.width, height: this.height };
                }
                setTarget(t, e, i) {
                    this.goalTarget.set(-t, -e, -i);
                }
                setTargetDamperDecayTime(t) {
                    this.targetDamperX.setDecayTime(t), this.targetDamperY.setDecayTime(t), this.targetDamperZ.setDecayTime(t);
                }
                getTarget() {
                    return pu.copy(this.goalTarget).multiplyScalar(-1);
                }
                jumpToGoal() {
                    this.updateTarget(1e4);
                }
                updateTarget(t) {
                    const e = this.goalTarget,
                        i = this.target.position;
                    if (!e.equals(i)) {
                        const n = this.idealCameraDistance;
                        let { x: s, y: r, z: a } = i;
                        (s = this.targetDamperX.update(s, e.x, t, n)), (r = this.targetDamperY.update(r, e.y, t, n)), (a = this.targetDamperZ.update(a, e.z, t, n)), this.target.position.set(s, r, a), this.target.updateMatrixWorld(), this.setShadowRotation(this.yaw), (this.isDirty = !0);
                    }
                }
                pointTowards(t, e) {
                    const { x: i, z: n } = this.position;
                    this.yaw = Math.atan2(t - i, e - n);
                }
                set yaw(t) {
                    (this.rotation.y = t), this.updateMatrixWorld(!0), this.setShadowRotation(t), (this.isDirty = !0);
                }
                get yaw() {
                    return this.rotation.y;
                }
                set animationTime(t) {
                    this.mixer.setTime(t);
                }
                get animationTime() {
                    return null != this.currentAnimationAction ? this.currentAnimationAction.time : 0;
                }
                get duration() {
                    return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0;
                }
                get hasActiveAnimation() {
                    return null != this.currentAnimationAction;
                }
                playAnimation(t = null, e = 0) {
                    if (null == this._currentGLTF) return;
                    const { animations: i } = this;
                    if (null == i || 0 === i.length) return;
                    let n = null;
                    null != t && (n = this.animationsByName.get(t)), null == n && (n = i[0]);
                    try {
                        const { currentAnimationAction: t } = this;
                        (this.currentAnimationAction = this.mixer.clipAction(n, this).play()), (this.currentAnimationAction.enabled = !0), null != t && this.currentAnimationAction !== t && this.currentAnimationAction.crossFadeFrom(t, e, !1);
                    } catch (t) {}
                }
                stopAnimation() {
                    null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction.reset(), (this.currentAnimationAction = null)), this.mixer.stopAllAction();
                }
                updateAnimation(t) {
                    this.mixer.update(t);
                }
                updateShadow() {
                    const t = this.shadow;
                    if (null != t) {
                        const e = "wall" === this.element.arPlacement ? "back" : "bottom";
                        t.setScene(this, this.shadowSoftness, e);
                    }
                }
                setShadowIntensity(t) {
                    if (((this.shadowIntensity = t), null == this._currentGLTF)) return;
                    let e = this.shadow;
                    const i = "wall" === this.element.arPlacement ? "back" : "bottom";
                    null != e ? (e.setIntensity(t), e.setScene(this, this.shadowSoftness, i)) : t > 0 && ((e = new ru(this, this.shadowSoftness, i)), e.setIntensity(t), (this.shadow = e));
                }
                setShadowSoftness(t) {
                    this.shadowSoftness = t;
                    const e = this.shadow;
                    null != e && e.setSoftness(t);
                }
                setShadowRotation(t) {
                    const e = this.shadow;
                    null != e && e.setRotation(t);
                }
                isShadowDirty() {
                    const t = this.shadow;
                    if (null == t) return !1;
                    {
                        const { needsUpdate: e } = t;
                        return (t.needsUpdate = !1), e;
                    }
                }
                setShadowScaleAndOffset(t, e) {
                    const i = this.shadow;
                    null != i && i.setScaleAndOffset(t, e);
                }
                positionAndNormalFromPoint(t, e = this) {
                    du.setFromCamera(t, this.getCamera());
                    const i = du.intersectObject(e, !0);
                    if (0 === i.length) return null;
                    const n = i[0];
                    return null == n.face ? null : (n.face.normal.applyNormalMatrix(new ft().getNormalMatrix(n.object.matrixWorld)), { position: n.point, normal: n.face.normal });
                }
                addHotspot(t) {
                    this.target.add(t), this.annotationRenderer.domElement.appendChild(t.element);
                }
                removeHotspot(t) {
                    this.target.remove(t);
                }
                forHotspots(t) {
                    const { children: e } = this.target;
                    for (let i = 0, n = e.length; i < n; i++) {
                        const n = e[i];
                        n instanceof nu && t(n);
                    }
                }
                updateHotspots(t) {
                    this.forHotspots((e) => {
                        cu.copy(t), hu.setFromMatrixPosition(e.matrixWorld), cu.sub(hu), uu.copy(e.normal).transformDirection(this.target.matrixWorld), cu.dot(uu) < 0 ? e.hide() : e.show();
                    });
                }
                orientHotspots(t) {
                    this.forHotspots((e) => {
                        e.orient(t);
                    });
                }
                setHotspotsVisibility(t) {
                    this.forHotspots((e) => {
                        e.visible = t;
                    });
                }
            }
            const gu = (function () {
                    const t = new ln({
                        uniforms: { roughnessMap: { value: null }, normalMap: { value: null }, texelSize: { value: new mt(1, 1) } },
                        vertexShader: "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tattribute vec3 position;\n\t\t\tattribute vec2 uv;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tvoid main() {\n\n\t\t\t\tvUv = uv;\n\n\t\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t\t}\n\t\t",
                        fragmentShader:
                            "\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec2 vUv;\n\n\t\t\tuniform sampler2D roughnessMap;\n\t\t\tuniform sampler2D normalMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\n\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\n\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tfloat roughnessToVariance( float roughness ) {\n\n\t\t\t\tfloat variance = 0.0;\n\n\t\t\t\tif ( roughness >= r1 ) {\n\n\t\t\t\t\tvariance = ( r0 - roughness ) * ( v1 - v0 ) / ( r0 - r1 ) + v0;\n\n\t\t\t\t} else if ( roughness >= r4 ) {\n\n\t\t\t\t\tvariance = ( r1 - roughness ) * ( v4 - v1 ) / ( r1 - r4 ) + v1;\n\n\t\t\t\t} else if ( roughness >= r5 ) {\n\n\t\t\t\t\tvariance = ( r4 - roughness ) * ( v5 - v4 ) / ( r4 - r5 ) + v4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfloat roughness2 = roughness * roughness;\n\n\t\t\t\t\tvariance = 1.79 * roughness2 * roughness2;\n\n\t\t\t\t}\n\n\t\t\t\treturn variance;\n\n\t\t\t}\n\n\t\t\tfloat varianceToRoughness( float variance ) {\n\n\t\t\t\tfloat roughness = 0.0;\n\n\t\t\t\tif ( variance >= v1 ) {\n\n\t\t\t\t\troughness = ( v0 - variance ) * ( r1 - r0 ) / ( v0 - v1 ) + r0;\n\n\t\t\t\t} else if ( variance >= v4 ) {\n\n\t\t\t\t\troughness = ( v1 - variance ) * ( r4 - r1 ) / ( v1 - v4 ) + r1;\n\n\t\t\t\t} else if ( variance >= v5 ) {\n\n\t\t\t\t\troughness = ( v4 - variance ) * ( r5 - r4 ) / ( v4 - v5 ) + r4;\n\n\t\t\t\t} else {\n\n\t\t\t\t\troughness = pow( 0.559 * variance, 0.25 ); // 0.559 = 1.0 / 1.79\n\n\t\t\t\t}\n\n\t\t\t\treturn roughness;\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = texture2D( roughnessMap, vUv, - 1.0 );\n\n\t\t\t\tif ( texelSize.x == 0.0 ) return;\n\n\t\t\t\tfloat roughness = gl_FragColor.g;\n\n\t\t\t\tfloat variance = roughnessToVariance( roughness );\n\n\t\t\t\tvec3 avgNormal;\n\n\t\t\t\tfor ( float x = - 1.0; x < 2.0; x += 2.0 ) {\n\n\t\t\t\t\tfor ( float y = - 1.0; y < 2.0; y += 2.0 ) {\n\n\t\t\t\t\t\tvec2 uv = vUv + vec2( x, y ) * 0.25 * texelSize;\n\n\t\t\t\t\t\tavgNormal += normalize( texture2D( normalMap, uv, - 1.0 ).xyz - 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvariance += 1.0 - 0.25 * length( avgNormal );\n\n\t\t\t\tgl_FragColor.g = varianceToRoughness( variance );\n\n\t\t\t}\n\t\t",
                        blending: 0,
                        depthTest: !1,
                        depthWrite: !1,
                    });
                    return (t.type = "RoughnessMipmapper"), t;
                })(),
                /* @license
                 * Copyright 2019 Google LLC. All Rights Reserved.
                 * Licensed under the Apache License, Version 2.0 (the 'License');
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *     http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an 'AS IS' BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                mu = new Bi(new Xi(2, 2), gu),
                fu = new on(0, 1, 0, 1, 0, 1);
            let vu = null,
                yu = null;
            class xu {
                constructor(t) {
                    (yu = t), yu.compile(mu, fu);
                }
                generateMipmaps(t) {
                    if ("roughnessMap" in t == 0) return;
                    const { roughnessMap: e, normalMap: i } = t;
                    if (null === e || null === i || !e.generateMipmaps || t.userData.roughnessUpdated) return;
                    t.userData.roughnessUpdated = !0;
                    let n = Math.max(e.image.width, i.image.width),
                        s = Math.max(e.image.height, i.image.height);
                    if (!gt.isPowerOfTwo(n) || !gt.isPowerOfTwo(s)) return;
                    const r = yu.getRenderTarget(),
                        a = yu.autoClear;
                    if (((yu.autoClear = !1), (null !== vu && vu.width === n && vu.height === s) || (null !== vu && vu.dispose(), (vu = new Ct(n, s, { depthBuffer: !1 })), (vu.scissorTest = !0)), n !== e.image.width || s !== e.image.height)) {
                        const i = { wrapS: e.wrapS, wrapT: e.wrapT, magFilter: e.magFilter, minFilter: e.minFilter, depthBuffer: !1 },
                            r = new Ct(n, s, i);
                        (r.texture.generateMipmaps = !0), yu.setRenderTarget(r), (t.roughnessMap = r.texture), t.metalnessMap == e && (t.metalnessMap = t.roughnessMap), t.aoMap == e && (t.aoMap = t.roughnessMap), t.roughnessMap.offset.copy(e.offset), t.roughnessMap.repeat.copy(e.repeat), t.roughnessMap.center.copy(e.center), (t.roughnessMap.rotation = e.rotation), (t.roughnessMap.matrixAutoUpdate = e.matrixAutoUpdate), t.roughnessMap.matrix.copy(e.matrix);
                    }
                    (gu.uniforms.roughnessMap.value = e), (gu.uniforms.normalMap.value = i);
                    const o = new mt(0, 0),
                        l = gu.uniforms.texelSize.value;
                    for (let e = 0; n >= 1 && s >= 1; ++e, n /= 2, s /= 2) l.set(1 / n, 1 / s), 0 == e && l.set(0, 0), vu.viewport.set(o.x, o.y, n, s), vu.scissor.set(o.x, o.y, n, s), yu.setRenderTarget(vu), yu.render(mu, fu), yu.copyFramebufferToTexture(o, t.roughnessMap, e), (gu.uniforms.roughnessMap.value = t.roughnessMap);
                    e !== t.roughnessMap && e.dispose(), yu.setRenderTarget(r), (yu.autoClear = a);
                }
                dispose() {
                    gu.dispose(), mu.geometry.dispose(), null != vu && vu.dispose();
                }
            }
            var wu = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            const _u = Symbol("currentEnvironmentMap"),
                Iu = Symbol("applyEnvironmentMap"),
                Cu = Symbol("updateEnvironment"),
                Mu = Symbol("cancelEnvironmentUpdate"),
                Eu = Symbol("onPreload");
            class bu {
                constructor(t, e, i, n, s) {
                    (this.xrLight = t), (this.renderer = e), (this.lightProbe = i), (this.xrWebGLBinding = null), (this.estimationStartCallback = s), (this.frameCallback = this.onXRFrame.bind(this));
                    const r = e.xr.getSession();
                    if (n && "XRWebGLBinding" in window) {
                        const i = new Oi(16);
                        t.environment = i.texture;
                        const n = e.getContext();
                        switch (r.preferredReflectionFormat) {
                            case "srgba8":
                                n.getExtension("EXT_sRGB");
                                break;
                            case "rgba16f":
                                n.getExtension("OES_texture_half_float");
                        }
                        (this.xrWebGLBinding = new XRWebGLBinding(r, n)),
                            this.lightProbe.addEventListener("reflectionchange", () => {
                                this.updateReflection();
                            });
                    }
                    r.requestAnimationFrame(this.frameCallback);
                }
                updateReflection() {
                    const t = this.renderer.properties.get(this.xrLight.environment);
                    if (t) {
                        const e = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
                        e && (t.__webglTexture = e);
                    }
                }
                onXRFrame(t, e) {
                    if (!this.xrLight) return;
                    e.session.requestAnimationFrame(this.frameCallback);
                    const i = e.getLightEstimate(this.lightProbe);
                    if (i) {
                        this.xrLight.lightProbe.sh.fromArray(i.sphericalHarmonicsCoefficients), (this.xrLight.lightProbe.intensity = 1);
                        const t = Math.max(1, Math.max(i.primaryLightIntensity.x, Math.max(i.primaryLightIntensity.y, i.primaryLightIntensity.z)));
                        this.xrLight.directionalLight.color.setRGB(i.primaryLightIntensity.x / t, i.primaryLightIntensity.y / t, i.primaryLightIntensity.z / t), (this.xrLight.directionalLight.intensity = t), this.xrLight.directionalLight.position.copy(i.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), (this.estimationStartCallback = null));
                    }
                }
                dispose() {
                    (this.xrLight = null), (this.renderer = null), (this.lightProbe = null), (this.xrWebGLBinding = null);
                }
            }
            class Su extends Br {
                constructor(t, e = !0) {
                    super(), (this.lightProbe = new _l()), (this.lightProbe.intensity = 0), this.add(this.lightProbe), (this.directionalLight = new xl()), (this.directionalLight.intensity = 0), this.add(this.directionalLight), (this.environment = null);
                    let i = null,
                        n = !1;
                    t.xr.addEventListener("sessionstart", () => {
                        const s = t.xr.getSession();
                        "requestLightProbe" in s &&
                            s.requestLightProbe({ reflectionFormat: s.preferredReflectionFormat }).then((s) => {
                                i = new bu(this, t, s, e, () => {
                                    (n = !0), this.dispatchEvent({ type: "estimationstart" });
                                });
                            });
                    }),
                        t.xr.addEventListener("sessionend", () => {
                            i && (i.dispose(), (i = null)), n && this.dispatchEvent({ type: "estimationend" });
                        }),
                        (this.dispose = () => {
                            i && (i.dispose(), (i = null)), this.remove(this.lightProbe), (this.lightProbe = null), this.remove(this.directionalLight), (this.directionalLight = null), (this.environment = null);
                        });
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const Bu = Math.PI / 24,
                Tu = new mt(),
                Lu = (t, e, i) => {
                    let n = e > 0 ? (i > 0 ? 0 : -Math.PI / 2) : i > 0 ? Math.PI / 2 : Math.PI;
                    for (let s = 0; s <= 12; ++s) t.push(e + 0.17 * Math.cos(n), i + 0.17 * Math.sin(n), 0, e + 0.2 * Math.cos(n), i + 0.2 * Math.sin(n), 0), (n += Bu);
                };
            class Du extends Bi {
                constructor(t, e) {
                    const i = new ui(),
                        n = [],
                        s = [],
                        { size: r, boundingBox: a } = t,
                        o = r.x / 2,
                        l = ("back" === e ? r.y : r.z) / 2;
                    Lu(s, o, l), Lu(s, -o, l), Lu(s, -o, -l), Lu(s, o, -l);
                    const c = s.length / 3;
                    for (let t = 0; t < c - 2; t += 2) n.push(t, t + 1, t + 3, t, t + 3, t + 2);
                    const h = c - 2;
                    n.push(h, h + 1, 1, h, 1, 0), i.setAttribute("position", new ii(s, 3)), i.setIndex(n), super(i), (this.side = e);
                    const u = this.material;
                    switch (((u.side = 2), (u.transparent = !0), (u.opacity = 0), (this.goalOpacity = 0), (this.opacityDamper = new Vh()), (this.hitPlane = new Bi(new Xi(2 * (o + 0.2), 2 * (l + 0.2)))), (this.hitPlane.visible = !1), this.add(this.hitPlane), a.getCenter(this.position), e)) {
                        case "bottom":
                            this.rotateX(-Math.PI / 2), (this.shadowHeight = a.min.y), (this.position.y = this.shadowHeight);
                            break;
                        case "back":
                            (this.shadowHeight = a.min.z), (this.position.z = this.shadowHeight);
                    }
                    t.target.add(this);
                }
                getHit(t, e, i) {
                    Tu.set(e, -i), (this.hitPlane.visible = !0);
                    const n = t.positionAndNormalFromPoint(Tu, this.hitPlane);
                    return (this.hitPlane.visible = !1), null == n ? null : n.position;
                }
                getExpandedHit(t, e, i) {
                    this.hitPlane.scale.set(1e3, 1e3, 1e3);
                    const n = this.getHit(t, e, i);
                    return this.hitPlane.scale.set(1, 1, 1), n;
                }
                set offsetHeight(t) {
                    "back" === this.side ? (this.position.z = this.shadowHeight + t) : (this.position.y = this.shadowHeight + t);
                }
                get offsetHeight() {
                    return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight;
                }
                set show(t) {
                    this.goalOpacity = t ? 0.75 : 0;
                }
                updateOpacity(t) {
                    const e = this.material;
                    (e.opacity = this.opacityDamper.update(e.opacity, this.goalOpacity, t, 1)), (this.visible = e.opacity > 0);
                }
                dispose() {
                    var t;
                    const { geometry: e, material: i } = this.hitPlane;
                    e.dispose(), i.dispose(), this.geometry.dispose(), this.material.dispose(), null === (t = this.parent) || void 0 === t || t.remove(this);
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const Qu = "not-presenting",
                Ru = "session-started",
                Pu = "tracking",
                Nu = new bt(),
                Fu = new se(),
                Uu = new bt(),
                ku = new Fi(45, 1, 0.1, 100);
            class Ou extends nt {
                constructor(t) {
                    super(),
                        (this.renderer = t),
                        (this.currentSession = null),
                        (this.placeOnWall = !1),
                        (this.placementBox = null),
                        (this.lastTick = null),
                        (this.turntableRotation = null),
                        (this.oldShadowIntensity = null),
                        (this.oldBackground = null),
                        (this.oldEnvironment = null),
                        (this.frame = null),
                        (this.initialHitSource = null),
                        (this.transientHitTestSource = null),
                        (this.inputSource = null),
                        (this._presentedScene = null),
                        (this.resolveCleanup = null),
                        (this.exitWebXRButtonContainer = null),
                        (this.overlay = null),
                        (this.xrLight = null),
                        (this.environmentEstimation = !1),
                        (this.tracking = !0),
                        (this.frames = 0),
                        (this.initialized = !1),
                        (this.oldTarget = new bt()),
                        (this.oldFramedFieldOfView = 45),
                        (this.placementComplete = !1),
                        (this.isTranslating = !1),
                        (this.isRotating = !1),
                        (this.isTwoFingering = !1),
                        (this.lastDragPosition = new bt()),
                        (this.firstRatio = 0),
                        (this.lastAngle = 0),
                        (this.goalPosition = new bt()),
                        (this.goalYaw = 0),
                        (this.goalScale = 1),
                        (this.xDamper = new Vh()),
                        (this.yDamper = new Vh()),
                        (this.zDamper = new Vh()),
                        (this.yawDamper = new Vh()),
                        (this.scaleDamper = new Vh()),
                        (this.onExitWebXRButtonContainerClick = () => this.stopPresenting()),
                        (this.onUpdateScene = () => {
                            null != this.placementBox && this.isPresenting && (this.placementBox.dispose(), (this.placementBox = new Du(this.presentedScene, this.placeOnWall ? "back" : "bottom")));
                        }),
                        (this.onSelectStart = (t) => {
                            const e = this.transientHitTestSource;
                            if (null == e) return;
                            const i = this.frame.getHitTestResultsForTransientInput(e),
                                n = this.presentedScene,
                                s = this.placementBox;
                            if (1 === i.length) {
                                this.inputSource = t.inputSource;
                                const { axes: e } = this.inputSource.gamepad,
                                    i = s.getHit(this.presentedScene, e[0], e[1]);
                                (s.show = !0), null != i ? ((this.isTranslating = !0), this.lastDragPosition.copy(i)) : !1 === this.placeOnWall && ((this.isRotating = !0), (this.lastAngle = 1.5 * e[0]));
                            } else if (2 === i.length) {
                                (s.show = !0), (this.isTwoFingering = !0);
                                const { separation: t } = this.fingerPolar(i);
                                this.firstRatio = t / n.scale.x;
                            }
                        }),
                        (this.onSelectEnd = () => {
                            (this.isTranslating = !1), (this.isRotating = !1), (this.isTwoFingering = !1), (this.inputSource = null), (this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x), (this.placementBox.show = !1);
                        }),
                        (this.threeRenderer = t.threeRenderer),
                        (this.threeRenderer.xr.enabled = !0),
                        (this.xrLight = new Su(this.threeRenderer)),
                        this.xrLight.addEventListener("estimationstart", () => {
                            if (!this.isPresenting || null == this.xrLight) return;
                            const t = this.presentedScene;
                            t.add(this.xrLight), this.environmentEstimation && this.xrLight.environment && ((this.oldEnvironment = t.environment), (t.environment = this.xrLight.environment));
                        });
                }
                async resolveARSession() {
                    Fh();
                    const t = await navigator.xr.requestSession("immersive-ar", { requiredFeatures: ["hit-test"], optionalFeatures: ["dom-overlay", "light-estimation"], domOverlay: { root: this.overlay } });
                    return this.threeRenderer.xr.setReferenceSpaceType("local"), await this.threeRenderer.xr.setSession(t), (this.threeRenderer.xr.cameraAutoUpdate = !1), t;
                }
                get presentedScene() {
                    return this._presentedScene;
                }
                async supportsPresentation() {
                    try {
                        return Fh(), await navigator.xr.isSessionSupported("immersive-ar");
                    } catch (t) {
                        return !1;
                    }
                }
                async present(t, e = !1) {
                    this.isPresenting;
                    let i = new Promise((t, e) => {
                        requestAnimationFrame(() => t());
                    });
                    t.setHotspotsVisibility(!1), (t.isDirty = !0), await i, (this._presentedScene = t), (this.overlay = t.element.shadowRoot.querySelector("div.default")), (this.environmentEstimation = e);
                    const n = await this.resolveARSession();
                    n.addEventListener(
                        "end",
                        () => {
                            this.postSessionCleanup();
                        },
                        { once: !0 },
                    );
                    const s = t.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
                    s.classList.add("enabled"), s.addEventListener("click", this.onExitWebXRButtonContainerClick), (this.exitWebXRButtonContainer = s);
                    const r = await n.requestReferenceSpace("viewer");
                    (this.tracking = !0), (this.frames = 0), (this.initialized = !1), (this.turntableRotation = t.yaw), (this.goalYaw = t.yaw), (this.goalScale = 1), (this.oldBackground = t.background), (t.background = null), (this.oldShadowIntensity = t.shadowIntensity), t.setShadowIntensity(0), this.oldTarget.copy(t.getTarget()), (this.oldFramedFieldOfView = t.framedFieldOfView), t.addEventListener("model-load", this.onUpdateScene);
                    const a = (20 * Math.PI) / 180,
                        o = !0 === this.placeOnWall ? void 0 : new XRRay(new DOMPoint(0, 0, 0), { x: 0, y: -Math.sin(a), z: -Math.cos(a) });
                    n.requestHitTestSource({ space: r, offsetRay: o }).then((t) => {
                        this.initialHitSource = t;
                    }),
                        (this.currentSession = n),
                        (this.placementBox = new Du(t, this.placeOnWall ? "back" : "bottom")),
                        (this.placementComplete = !1),
                        (this.lastTick = performance.now()),
                        this.dispatchEvent({ type: "status", status: Ru });
                }
                async stopPresenting() {
                    if (!this.isPresenting) return;
                    const t = new Promise((t) => {
                        this.resolveCleanup = t;
                    });
                    try {
                        await this.currentSession.end(), await t;
                    } catch (t) {
                        this.postSessionCleanup();
                    }
                }
                get isPresenting() {
                    return null != this.presentedScene;
                }
                get target() {
                    return this.oldTarget;
                }
                updateTarget() {
                    const t = this.presentedScene;
                    if (null != t) {
                        const e = t.getTarget();
                        this.oldTarget.copy(e), this.placeOnWall ? (e.z = t.boundingBox.min.z) : (e.y = t.boundingBox.min.y), t.setTarget(e.x, e.y, e.z);
                    }
                }
                postSessionCleanup() {
                    const t = this.currentSession;
                    null != t && (t.removeEventListener("selectstart", this.onSelectStart), t.removeEventListener("selectend", this.onSelectEnd), (this.currentSession = null));
                    const e = this.presentedScene;
                    if (null != e) {
                        const { element: t } = e;
                        null != this.xrLight && null != this.xrLight.parent && (e.remove(this.xrLight), null != this.oldEnvironment && ((e.environment = this.oldEnvironment), (this.oldEnvironment = null))), e.position.set(0, 0, 0), e.scale.set(1, 1, 1), e.setShadowScaleAndOffset(1, 0);
                        const i = this.turntableRotation;
                        null != i && (e.yaw = i);
                        const n = this.oldShadowIntensity;
                        null != n && e.setShadowIntensity(n);
                        const s = this.oldBackground;
                        null != s && (e.background = s);
                        const r = this.oldTarget;
                        e.setTarget(r.x, r.y, r.z), (e.framedFieldOfView = this.oldFramedFieldOfView), (e.xrCamera = null), e.removeEventListener("model-load", this.onUpdateScene), e.orientHotspots(0), t.requestUpdate("cameraTarget"), t.requestUpdate("maxCameraOrbit"), t[np](t.getBoundingClientRect());
                    }
                    this.renderer.height = 0;
                    const i = this.exitWebXRButtonContainer;
                    null != i && (i.classList.remove("enabled"), i.removeEventListener("click", this.onExitWebXRButtonContainerClick), (this.exitWebXRButtonContainer = null));
                    const n = this.transientHitTestSource;
                    null != n && (n.cancel(), (this.transientHitTestSource = null));
                    const s = this.initialHitSource;
                    null != s && (s.cancel(), (this.initialHitSource = null)), null != this.placementBox && (this.placementBox.dispose(), (this.placementBox = null)), (this.lastTick = null), (this.turntableRotation = null), (this.oldShadowIntensity = null), (this.oldBackground = null), (this._presentedScene = null), (this.frame = null), (this.inputSource = null), (this.overlay = null), null != this.resolveCleanup && this.resolveCleanup(), this.dispatchEvent({ type: "status", status: Qu });
                }
                updateView(t) {
                    const e = this.presentedScene,
                        i = this.threeRenderer.xr;
                    i.updateCamera(ku), (e.xrCamera = i.getCamera());
                    const { elements: n } = e.getCamera().matrixWorld;
                    if ((e.orientHotspots(Math.atan2(n[1], n[5])), this.initialized || (this.placeInitially(), (this.initialized = !0)), t.requestViewportScale && t.recommendedViewportScale)) {
                        const e = t.recommendedViewportScale;
                        t.requestViewportScale(Math.max(e, 0.25));
                    }
                    const s = this.currentSession.renderState.baseLayer.getViewport(t);
                    this.threeRenderer.setViewport(s.x, s.y, s.width, s.height);
                }
                placeInitially() {
                    const t = this.presentedScene,
                        { position: e, element: i } = t,
                        n = t.getCamera(),
                        { width: s, height: r } = this.overlay.getBoundingClientRect();
                    t.setSize(s, r), n.projectionMatrixInverse.copy(n.projectionMatrix).invert();
                    const { theta: a, radius: o } = i.getCameraOrbit(),
                        l = n.getWorldDirection(Nu);
                    (t.yaw = Math.atan2(-l.x, -l.z) - a), (this.goalYaw = t.yaw), e.copy(n.position).add(l.multiplyScalar(o)), this.updateTarget();
                    const c = t.getTarget();
                    e.add(c).sub(this.oldTarget), this.goalPosition.copy(e), t.setHotspotsVisibility(!0);
                    const { session: h } = this.frame;
                    h.addEventListener("selectstart", this.onSelectStart),
                        h.addEventListener("selectend", this.onSelectEnd),
                        h.requestHitTestSourceForTransientInput({ profile: "generic-touchscreen" }).then((t) => {
                            this.transientHitTestSource = t;
                        });
                }
                getTouchLocation() {
                    const { axes: t } = this.inputSource.gamepad;
                    let e = this.placementBox.getExpandedHit(this.presentedScene, t[0], t[1]);
                    return null != e && (Nu.copy(e).sub(this.presentedScene.getCamera().position), Nu.length() > 10) ? null : e;
                }
                getHitPoint(t) {
                    const e = this.threeRenderer.xr.getReferenceSpace(),
                        i = t.getPose(e);
                    if (null == i) return null;
                    const n = Fu.fromArray(i.transform.matrix);
                    return !0 === this.placeOnWall && (this.goalYaw = Math.atan2(n.elements[4], n.elements[6])), n.elements[5] > 0.75 !== this.placeOnWall ? Uu.setFromMatrixPosition(n) : null;
                }
                moveToFloor(t) {
                    const e = this.initialHitSource;
                    if (null == e) return;
                    const i = t.getHitTestResults(e);
                    if (0 == i.length) return;
                    const n = i[0],
                        s = this.getHitPoint(n);
                    null != s && ((this.placementBox.show = !0), this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(s) : (this.goalPosition.y = s.y)), e.cancel(), (this.initialHitSource = null), this.dispatchEvent({ type: "status", status: "object-placed" }));
                }
                fingerPolar(t) {
                    const e = t[0].inputSource.gamepad.axes,
                        i = t[1].inputSource.gamepad.axes,
                        n = i[0] - e[0],
                        s = i[1] - e[1],
                        r = Math.atan2(s, n);
                    let a = this.lastAngle - r;
                    return a > Math.PI ? (a -= 2 * Math.PI) : a < -Math.PI && (a += 2 * Math.PI), (this.lastAngle = r), { separation: Math.sqrt(n * n + s * s), deltaYaw: a };
                }
                processInput(t) {
                    const e = this.transientHitTestSource;
                    if (null == e) return;
                    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
                    const i = t.getHitTestResultsForTransientInput(e),
                        n = this.presentedScene,
                        s = n.scale.x;
                    if (this.isTwoFingering)
                        if (i.length < 2) this.isTwoFingering = !1;
                        else {
                            const { separation: t, deltaYaw: e } = this.fingerPolar(i);
                            if ((!1 === this.placeOnWall && (this.goalYaw += e), n.canScale)) {
                                const e = t / this.firstRatio;
                                this.goalScale = e < 1.3 && e > 0.7692307692307692 ? 1 : e;
                            }
                        }
                    else if (2 !== i.length)
                        if (this.isRotating) {
                            const t = 1.5 * this.inputSource.gamepad.axes[0];
                            (this.goalYaw += t - this.lastAngle), (this.lastAngle = t);
                        } else
                            this.isTranslating &&
                                i.forEach((t) => {
                                    if (t.inputSource !== this.inputSource) return;
                                    let e = null;
                                    if ((t.results.length > 0 && (e = this.getHitPoint(t.results[0])), null == e && (e = this.getTouchLocation()), null != e)) {
                                        if ((this.goalPosition.sub(this.lastDragPosition), !1 === this.placeOnWall)) {
                                            const t = e.y - this.lastDragPosition.y;
                                            if (t < 0) {
                                                (this.placementBox.offsetHeight = t / s), this.presentedScene.setShadowScaleAndOffset(s, t);
                                                const i = Nu.copy(n.getCamera().position),
                                                    r = -t / (i.y - e.y);
                                                i.multiplyScalar(r), e.multiplyScalar(1 - r).add(i);
                                            }
                                        }
                                        this.goalPosition.add(e), this.lastDragPosition.copy(e);
                                    }
                                });
                    else {
                        (this.isTranslating = !1), (this.isRotating = !1), (this.isTwoFingering = !0);
                        const { separation: t } = this.fingerPolar(i);
                        this.firstRatio = t / s;
                    }
                }
                moveScene(t) {
                    const e = this.presentedScene,
                        { position: i, yaw: n, idealCameraDistance: s } = e,
                        r = this.goalPosition,
                        a = e.scale.x,
                        o = this.placementBox;
                    if (!r.equals(i) || this.goalScale !== a) {
                        let { x: n, y: l, z: c } = i;
                        (n = this.xDamper.update(n, r.x, t, s)), (l = this.yDamper.update(l, r.y, t, s)), (c = this.zDamper.update(c, r.z, t, s)), i.set(n, l, c);
                        const h = this.scaleDamper.update(a, this.goalScale, t, 1);
                        if ((e.scale.set(h, h, h), !this.isTranslating)) {
                            const t = r.y - l;
                            this.placementComplete && !1 === this.placeOnWall ? ((o.offsetHeight = t / h), e.setShadowScaleAndOffset(h, t)) : 0 === t && ((this.placementComplete = !0), (o.show = !1), e.setShadowIntensity(0.3));
                        }
                    }
                    o.updateOpacity(t), e.updateTarget(t), (e.yaw = this.yawDamper.update(n, this.goalYaw, t, Math.PI));
                }
                onWebXRFrame(t, e) {
                    (this.frame = e), ++this.frames;
                    const i = this.threeRenderer.xr.getReferenceSpace(),
                        n = e.getViewerPose(i);
                    null == n && !0 === this.tracking && this.frames > 30 && ((this.tracking = !1), this.dispatchEvent({ type: "tracking", status: "not-tracking" }));
                    const s = this.presentedScene;
                    if (null == n || null == s || !s.element[cp]()) return void this.threeRenderer.clear();
                    !1 === this.tracking && ((this.tracking = !0), this.dispatchEvent({ type: "tracking", status: Pu }));
                    let r = !0;
                    for (const i of n.views) {
                        if ((this.updateView(i), r)) {
                            this.moveToFloor(e), this.processInput(e);
                            const i = t - this.lastTick;
                            this.moveScene(i), this.renderer.preRender(s, t, i), (this.lastTick = t);
                        }
                        const n = this.threeRenderer.getContext();
                        n.depthMask(!1), n.clear(n.DEPTH_BUFFER_BIT), n.depthMask(!0), this.threeRenderer.render(s, s.getCamera()), (r = !1);
                    }
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ class Gu {
                constructor(t) {
                    (t.threeRenderer.debug = { checkShaderErrors: !0 }),
                        Promise.resolve().then(() => {
                            self.dispatchEvent(new CustomEvent("model-viewer-renderer-debug", { detail: { renderer: t, THREE: { ShaderMaterial: Pi, Texture: wt, Mesh: Bi, Scene: Pr, PlaneBufferGeometry: Xi, OrthographicCamera: on, WebGLRenderTarget: Ct } } }));
                        });
                }
                addScene(t) {
                    self.dispatchEvent(new CustomEvent("model-viewer-scene-added-debug", { detail: { scene: t } }));
                }
                removeScene(t) {
                    self.dispatchEvent(new CustomEvent("model-viewer-scene-removed-debug", { detail: { scene: t } }));
                }
            }
            function zu(t, e, i) {
                i(t, e);
                for (let n = 0; n < t.children.length; n++) zu(t.children[n], e.children[n], i);
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const Vu = Symbol("prepared"),
                Hu = Symbol("prepare"),
                Wu = Symbol("preparedGLTF"),
                qu = Symbol("clone");
            class ju {
                constructor(t) {
                    this[Wu] = t;
                }
                static prepare(t) {
                    if (null == t.scene) throw new Error("Model does not have a scene");
                    if (t[Vu]) return t;
                    const e = this[Hu](t);
                    return (e[Vu] = !0), e;
                }
                static [Hu](t) {
                    const { scene: e } = t,
                        i = [e];
                    return Object.assign(Object.assign({}, t), { scene: e, scenes: i });
                }
                get parser() {
                    return this[Wu].parser;
                }
                get animations() {
                    return this[Wu].animations;
                }
                get scene() {
                    return this[Wu].scene;
                }
                get scenes() {
                    return this[Wu].scenes;
                }
                get cameras() {
                    return this[Wu].cameras;
                }
                get asset() {
                    return this[Wu].asset;
                }
                get userData() {
                    return this[Wu].userData;
                }
                clone() {
                    return new (0, this.constructor)(this[qu]());
                }
                dispose() {
                    this.scenes.forEach((t) => {
                        t.traverse((t) => {
                            if (!t.isMesh) return;
                            const e = t;
                            (Array.isArray(e.material) ? e.material : [e.material]).forEach((t) => {
                                for (const e in t) {
                                    const i = t[e];
                                    i instanceof wt && i.dispose();
                                }
                                t.dispose();
                            }),
                                e.geometry.dispose();
                        });
                    });
                }
                [qu]() {
                    const t = this[Wu],
                        e = class {
                            static retarget(t, e, i = {}) {
                                const n = new bt(),
                                    s = new Et(),
                                    r = new bt(),
                                    a = new se(),
                                    o = new se(),
                                    l = new se();
                                (i.preserveMatrix = void 0 === i.preserveMatrix || i.preserveMatrix), (i.preservePosition = void 0 === i.preservePosition || i.preservePosition), (i.preserveHipPosition = void 0 !== i.preserveHipPosition && i.preserveHipPosition), (i.useTargetMatrix = void 0 !== i.useTargetMatrix && i.useTargetMatrix), (i.hip = void 0 !== i.hip ? i.hip : "hip"), (i.names = i.names || {});
                                const c = e.isObject3D ? e.skeleton.bones : this.getBones(e),
                                    h = t.isObject3D ? t.skeleton.bones : this.getBones(t);
                                let u, d, p, A, g;
                                if ((t.isObject3D ? t.skeleton.pose() : ((i.useTargetMatrix = !0), (i.preserveMatrix = !1)), i.preservePosition)) {
                                    g = [];
                                    for (let t = 0; t < h.length; t++) g.push(h[t].position.clone());
                                }
                                if (i.preserveMatrix) {
                                    t.updateMatrixWorld(), t.matrixWorld.identity();
                                    for (let e = 0; e < t.children.length; ++e) t.children[e].updateMatrixWorld(!0);
                                }
                                if (i.offsets) {
                                    u = [];
                                    for (let t = 0; t < h.length; ++t) (d = h[t]), (p = i.names[d.name] || d.name), i.offsets && i.offsets[p] && (d.matrix.multiply(i.offsets[p]), d.matrix.decompose(d.position, d.quaternion, d.scale), d.updateMatrixWorld()), u.push(d.matrixWorld.clone());
                                }
                                for (let e = 0; e < h.length; ++e) {
                                    if (((d = h[e]), (p = i.names[d.name] || d.name), (A = this.getBoneByName(p, c)), l.copy(d.matrixWorld), A)) {
                                        if ((A.updateMatrixWorld(), i.useTargetMatrix ? o.copy(A.matrixWorld) : (o.copy(t.matrixWorld).invert(), o.multiply(A.matrixWorld)), r.setFromMatrixScale(o), o.scale(r.set(1 / r.x, 1 / r.y, 1 / r.z)), l.makeRotationFromQuaternion(s.setFromRotationMatrix(o)), t.isObject3D)) {
                                            const e = h.indexOf(d),
                                                i = u ? u[e] : a.copy(t.skeleton.boneInverses[e]).invert();
                                            l.multiply(i);
                                        }
                                        l.copyPosition(o);
                                    }
                                    d.parent && d.parent.isBone ? (d.matrix.copy(d.parent.matrixWorld).invert(), d.matrix.multiply(l)) : d.matrix.copy(l), i.preserveHipPosition && p === i.hip && d.matrix.setPosition(n.set(0, d.position.y, 0)), d.matrix.decompose(d.position, d.quaternion, d.scale), d.updateMatrixWorld();
                                }
                                if (i.preservePosition) for (let t = 0; t < h.length; ++t) (d = h[t]), (p = i.names[d.name] || d.name), p !== i.hip && d.position.copy(g[t]);
                                i.preserveMatrix && t.updateMatrixWorld(!0);
                            }
                            static retargetClip(t, e, i, n = {}) {
                                (n.useFirstFramePosition = void 0 !== n.useFirstFramePosition && n.useFirstFramePosition), (n.fps = void 0 !== n.fps ? n.fps : 30), (n.names = n.names || []), e.isObject3D || (e = this.getHelperFromSkeleton(e));
                                const s = Math.round(i.duration * (n.fps / 1e3) * 1e3),
                                    r = 1 / n.fps,
                                    a = [],
                                    o = new Ul(e),
                                    l = this.getBones(t.skeleton),
                                    c = [];
                                let h, u, d, p, A;
                                o.clipAction(i).play(), o.update(0), e.updateMatrixWorld();
                                for (let i = 0; i < s; ++i) {
                                    const a = i * r;
                                    this.retarget(t, e, n);
                                    for (let t = 0; t < l.length; ++t) (A = n.names[l[t].name] || l[t].name), (d = this.getBoneByName(A, e.skeleton)), d && ((u = l[t]), (p = c[t] = c[t] || { bone: u }), n.hip === A && (p.pos || (p.pos = { times: new Float32Array(s), values: new Float32Array(3 * s) }), n.useFirstFramePosition && (0 === i && (h = u.position.clone()), u.position.sub(h)), (p.pos.times[i] = a), u.position.toArray(p.pos.values, 3 * i)), p.quat || (p.quat = { times: new Float32Array(s), values: new Float32Array(4 * s) }), (p.quat.times[i] = a), u.quaternion.toArray(p.quat.values, 4 * i));
                                    o.update(r), e.updateMatrixWorld();
                                }
                                for (let t = 0; t < c.length; ++t) (p = c[t]), p && (p.pos && a.push(new Wo(".bones[" + p.bone.name + "].position", p.pos.times, p.pos.values)), a.push(new Vo(".bones[" + p.bone.name + "].quaternion", p.quat.times, p.quat.values)));
                                return o.uncacheAction(i), new qo(i.name, -1, a);
                            }
                            static getHelperFromSkeleton(t) {
                                const e = new Wl(t.bones[0]);
                                return (e.skeleton = t), e;
                            }
                            static getSkeletonOffsets(t, e, i = {}) {
                                const n = new bt(),
                                    s = new bt(),
                                    r = new bt(),
                                    a = new bt(),
                                    o = new mt(),
                                    l = new mt();
                                (i.hip = void 0 !== i.hip ? i.hip : "hip"), (i.names = i.names || {}), e.isObject3D || (e = this.getHelperFromSkeleton(e));
                                const c = Object.keys(i.names),
                                    h = Object.values(i.names),
                                    u = e.isObject3D ? e.skeleton.bones : this.getBones(e),
                                    d = t.isObject3D ? t.skeleton.bones : this.getBones(t),
                                    p = [];
                                let A, g, m, f;
                                for (t.skeleton.pose(), f = 0; f < d.length; ++f)
                                    if (((A = d[f]), (m = i.names[A.name] || A.name), (g = this.getBoneByName(m, u)), g && m !== i.hip)) {
                                        const t = this.getNearestBone(A.parent, c),
                                            e = this.getNearestBone(g.parent, h);
                                        t.updateMatrixWorld(), e.updateMatrixWorld(), n.setFromMatrixPosition(t.matrixWorld), s.setFromMatrixPosition(A.matrixWorld), r.setFromMatrixPosition(e.matrixWorld), a.setFromMatrixPosition(g.matrixWorld), o.subVectors(new mt(s.x, s.y), new mt(n.x, n.y)).normalize(), l.subVectors(new mt(a.x, a.y), new mt(r.x, r.y)).normalize();
                                        const i = o.angle() - l.angle(),
                                            u = new se().makeRotationFromEuler(new Ae(0, 0, i));
                                        A.matrix.multiply(u), A.matrix.decompose(A.position, A.quaternion, A.scale), A.updateMatrixWorld(), (p[m] = u);
                                    }
                                return p;
                            }
                            static renameBones(t, e) {
                                const i = this.getBones(t);
                                for (let t = 0; t < i.length; ++t) {
                                    const n = i[t];
                                    e[n.name] && (n.name = e[n.name]);
                                }
                                return this;
                            }
                            static getBones(t) {
                                return Array.isArray(t) ? t : t.bones;
                            }
                            static getBoneByName(t, e) {
                                for (let i = 0, n = this.getBones(e); i < n.length; i++) if (t === n[i].name) return n[i];
                            }
                            static getNearestBone(t, e) {
                                for (; t.isBone; ) {
                                    if (-1 !== e.indexOf(t.name)) return t;
                                    t = t.parent;
                                }
                            }
                            static findBoneTrackData(t, e) {
                                const i = /\[(.*)\]\.(.*)/,
                                    n = { name: t };
                                for (let s = 0; s < e.length; ++s) {
                                    const r = i.exec(e[s].name);
                                    r && t === r[1] && (n[r[2]] = s);
                                }
                                return n;
                            }
                            static getEqualsBonesNames(t, e) {
                                const i = this.getBones(t),
                                    n = this.getBones(e),
                                    s = [];
                                t: for (let t = 0; t < i.length; t++) {
                                    const e = i[t].name;
                                    for (let t = 0; t < n.length; t++)
                                        if (e === n[t].name) {
                                            s.push(e);
                                            continue t;
                                        }
                                }
                                return s;
                            }
                            static clone(t) {
                                const e = new Map(),
                                    i = new Map(),
                                    n = t.clone();
                                return (
                                    zu(t, n, function (t, n) {
                                        e.set(n, t), i.set(t, n);
                                    }),
                                    n.traverse(function (t) {
                                        if (!t.isSkinnedMesh) return;
                                        const n = t,
                                            s = e.get(t),
                                            r = s.skeleton.bones;
                                        (n.skeleton = s.skeleton.clone()),
                                            n.bindMatrix.copy(s.bindMatrix),
                                            (n.skeleton.bones = r.map(function (t) {
                                                return i.get(t);
                                            })),
                                            n.bind(n.skeleton, n.bindMatrix);
                                    }),
                                    n
                                );
                            }
                        }.clone(this.scene);
                    Yu(e, this.scene);
                    const i = [e],
                        n = t.userData ? Object.assign({}, t.userData) : {};
                    return Object.assign(Object.assign({}, t), { scene: e, scenes: i, userData: n });
                }
            }
            const Yu = (t, e) => {
                    Ju(t, e, (t, e) => {
                        void 0 !== e.userData.variantMaterials && (t.userData.variantMaterials = new Map(e.userData.variantMaterials)), void 0 !== e.userData.originalMaterial && (t.userData.originalMaterial = e.userData.originalMaterial);
                    });
                },
                Ju = (t, e, i) => {
                    i(t, e);
                    for (let n = 0; n < t.children.length; n++) Ju(t.children[n], e.children[n], i);
                },
                Xu = "\n#ifdef ALPHATEST\n\n    if ( diffuseColor.a < ALPHATEST ) discard;\n    diffuseColor.a = 1.0;\n\n#endif\n",
                Ku = Symbol("threeGLTF"),
                Zu = Symbol("gltf"),
                $u = Symbol("gltfElementMap"),
                td = Symbol("threeObjectMap"),
                ed = Symbol("parallelTraverseThreeScene"),
                id = Symbol("correlateOriginalThreeGLTF"),
                nd = Symbol("correlateCloneThreeGLTF");
            class sd {
                constructor(t, e, i, n) {
                    (this[Ku] = t), (this[Zu] = e), (this[$u] = n), (this[td] = i);
                }
                static from(t, e) {
                    return null != e ? this[nd](t, e) : this[id](t);
                }
                static [id](t) {
                    const e = t.parser.json,
                        { associations: i } = t.parser,
                        n = new Map(),
                        s = { name: "Default" },
                        r = { type: "materials", index: -1 };
                    return (
                        i.forEach((t, i) => {
                            null == t && (r.index < 0 && (null == e.materials && (e.materials = []), (r.index = e.materials.length), e.materials.push(s)), (t = r));
                            const { type: a, index: o } = t,
                                l = (e[a] || [])[o];
                            if (null == l) return;
                            let c = n.get(l);
                            null == c && ((c = new Set()), n.set(l, c)), c.add(i);
                        }),
                        new sd(t, e, i, n)
                    );
                }
                static [nd](t, e) {
                    const i = e.threeGLTF,
                        n = e.gltf,
                        s = JSON.parse(JSON.stringify(n)),
                        r = new Map(),
                        a = new Map(),
                        o = { name: "Default" },
                        l = { type: "materials", index: -1 };
                    for (let n = 0; n < i.scenes.length; n++)
                        this[ed](i.scenes[n], t.scenes[n], (t, i) => {
                            let n = e.threeObjectMap.get(t);
                            if (((t.isMesh || t.isMaterial) && null == n && (s.materials && s.materials.length && "Default" === s.materials[s.materials.length - 1].name && (l.index = s.materials.length - 1), l.index < 0 && (null == s.materials && (s.materials = []), (l.index = s.materials.length), s.materials.push(o)), (n = l)), null == n)) return;
                            const { type: c, index: h } = n,
                                u = s[c][h];
                            r.set(i, { type: c, index: h });
                            const d = a.get(u) || new Set();
                            d.add(i), a.set(u, d);
                        });
                    return new sd(t, s, r, a);
                }
                static [ed](t, e, i) {
                    const n = (t, e) => {
                        if ((i(t, e), t.isObject3D)) {
                            if (t.isMesh)
                                if (Array.isArray(t.material)) for (let i = 0; i < t.material.length; ++i) n(t.material[i], e.material[i]);
                                else n(t.material, e.material);
                            for (let i = 0; i < t.children.length; ++i) n(t.children[i], e.children[i]);
                        }
                    };
                    n(t, e);
                }
                get threeGLTF() {
                    return this[Ku];
                }
                get gltf() {
                    return this[Zu];
                }
                get gltfElementMap() {
                    return this[$u];
                }
                get threeObjectMap() {
                    return this[td];
                }
                async loadVariant(t) {
                    const e = new Set();
                    return "variants" in this.threeGLTF.userData && "functions" in this.threeGLTF.userData && "selectVariant" in this.threeGLTF.userData.functions
                        ? (await this.threeGLTF.userData.functions.selectVariant(this.threeGLTF.scene, t, !0, (t, i, n) => {
                              e.add(n);
                              const s = this.gltf.materials[n];
                              let r = this.gltfElementMap.get(s);
                              null == r && ((r = new Set()), this.gltfElementMap.set(s, r)), r.add(t.material);
                          }),
                          e)
                        : e;
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const rd = Symbol("cloneAndPatchMaterial"),
                ad = Symbol("correlatedSceneGraph");
            class od extends ju {
                static [Hu](t) {
                    const e = super[Hu](t);
                    null == e[ad] && (e[ad] = sd.from(e));
                    const { scene: i } = e;
                    return (
                        i.traverse((t) => {
                            (t.renderOrder = 1e3), (t.frustumCulled = !1), t.name || (t.name = t.uuid), t.isMesh && (t.castShadow = !0);
                        }),
                        e
                    );
                }
                get correlatedSceneGraph() {
                    return this[Wu][ad];
                }
                [qu]() {
                    const t = super[qu](),
                        e = new Map();
                    return (
                        t.scene.traverse((t) => {
                            if (t.isMesh) {
                                const i = t;
                                Array.isArray(i.material) ? (i.material = i.material.map((t) => this[rd](t, e))) : null != i.material && (i.material = this[rd](i.material, e));
                            }
                        }),
                        (t[ad] = sd.from(t, this.correlatedSceneGraph)),
                        t
                    );
                }
                [rd](t, e) {
                    if (e.has(t.uuid)) return e.get(t.uuid);
                    const i = t.clone();
                    null != t.map && ((i.map = t.map.clone()), (i.map.needsUpdate = !0)), null != t.normalMap && ((i.normalMap = t.normalMap.clone()), (i.normalMap.needsUpdate = !0)), null != t.emissiveMap && ((i.emissiveMap = t.emissiveMap.clone()), (i.emissiveMap.needsUpdate = !0));
                    let n = null;
                    if ((null != t.roughnessMap && (n = t.roughnessMap.clone()), null != n)) {
                        (n.needsUpdate = !0), (i.roughnessMap = n);
                        const { threeRenderer: t, roughnessMipmapper: e } = md.singleton,
                            { enabled: s } = t.xr;
                        (t.xr.enabled = !1), e.generateMipmaps(i), (t.xr.enabled = s);
                    }
                    t.roughnessMap === t.metalnessMap ? (i.metalnessMap = n) : null != t.metalnessMap && ((i.metalnessMap = t.metalnessMap.clone()), (i.metalnessMap.needsUpdate = !0)), t.roughnessMap === t.aoMap ? (i.aoMap = n) : null != t.aoMap && ((i.aoMap = t.aoMap.clone()), (i.aoMap.needsUpdate = !0));
                    const s = t.onBeforeCompile;
                    return (
                        (i.onBeforeCompile = t.isGLTFSpecularGlossinessMaterial
                            ? (t) => {
                                  s(t, void 0), (t.fragmentShader = t.fragmentShader.replace("#include <alphatest_fragment>", Xu));
                              }
                            : (t) => {
                                  (t.fragmentShader = t.fragmentShader.replace("#include <alphatest_fragment>", Xu)), s(t, void 0);
                              }),
                        (i.shadowSide = 0),
                        i.transparent && (i.depthWrite = !1),
                        i.alphaTest || i.transparent || (i.alphaTest = -0.5),
                        e.set(t.uuid, i),
                        i
                    );
                    /* @license
                     * Copyright 2021 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            class ld extends Pr {
                constructor() {
                    super(), (this.position.y = -3.5);
                    const t = new Li();
                    t.deleteAttribute("uv");
                    const e = new Lo({ metalness: 0, side: 1 }),
                        i = new Lo({ metalness: 0 }),
                        n = new vl(16777215, 500, 28, 2);
                    n.position.set(0.418, 16.199, 0.3), this.add(n);
                    const s = new Bi(t, e);
                    s.position.set(-0.757, 13.219, 0.717), s.scale.set(31.713, 28.305, 28.591), this.add(s);
                    const r = new Bi(t, i);
                    r.position.set(-10.906, 2.009, 1.846), r.rotation.set(0, -0.195, 0), r.scale.set(2.328, 7.905, 4.651), this.add(r);
                    const a = new Bi(t, i);
                    a.position.set(-5.607, -0.754, -0.758), a.rotation.set(0, 0.994, 0), a.scale.set(1.97, 1.534, 3.955), this.add(a);
                    const o = new Bi(t, i);
                    o.position.set(6.167, 0.857, 7.803), o.rotation.set(0, 0.561, 0), o.scale.set(3.927, 6.285, 3.687), this.add(o);
                    const l = new Bi(t, i);
                    l.position.set(-2.017, 0.018, 6.124), l.rotation.set(0, 0.333, 0), l.scale.set(2.002, 4.566, 2.064), this.add(l);
                    const c = new Bi(t, i);
                    c.position.set(2.291, -0.756, -2.621), c.rotation.set(0, -0.286, 0), c.scale.set(1.546, 1.552, 1.496), this.add(c);
                    const h = new Bi(t, i);
                    h.position.set(-2.193, -0.369, -5.547), h.rotation.set(0, 0.516, 0), h.scale.set(3.875, 3.487, 2.986), this.add(h);
                    const u = new Bi(t, this.createAreaLightMaterial(50));
                    u.position.set(-16.116, 14.37, 8.208), u.scale.set(0.1, 2.428, 2.739), this.add(u);
                    const d = new Bi(t, this.createAreaLightMaterial(50));
                    d.position.set(-16.109, 18.021, -8.207), d.scale.set(0.1, 2.425, 2.751), this.add(d);
                    const p = new Bi(t, this.createAreaLightMaterial(17));
                    p.position.set(14.904, 12.198, -1.832), p.scale.set(0.15, 4.265, 6.331), this.add(p);
                    const A = new Bi(t, this.createAreaLightMaterial(43));
                    A.position.set(-0.462, 8.89, 14.52), A.scale.set(4.38, 5.441, 0.088), this.add(A);
                    const g = new Bi(t, this.createAreaLightMaterial(20));
                    g.position.set(3.235, 11.486, -12.541), g.scale.set(2.5, 2, 0.1), this.add(g);
                    const m = new Bi(t, this.createAreaLightMaterial(100));
                    m.position.set(0, 20, 0), m.scale.set(1, 0.1, 1), this.add(m);
                }
                createAreaLightMaterial(t) {
                    const e = new Xe();
                    return e.color.setScalar(t), e;
                    /* @license
                     * Copyright 2021 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            class cd extends Pr {
                constructor() {
                    super(), (this.position.y = -3.5);
                    const t = new Li();
                    t.deleteAttribute("uv");
                    const e = new Lo({ metalness: 0, side: 1 }),
                        i = new Lo({ metalness: 0 }),
                        n = new vl(16777215, 400, 28, 2);
                    n.position.set(0.5, 14, 0.5), this.add(n);
                    const s = new Bi(t, e);
                    s.position.set(0, 13.2, 0), s.scale.set(31.5, 28.5, 31.5), this.add(s);
                    const r = new Bi(t, i);
                    r.position.set(-10.906, -1, 1.846), r.rotation.set(0, -0.195, 0), r.scale.set(2.328, 7.905, 4.651), this.add(r);
                    const a = new Bi(t, i);
                    a.position.set(-5.607, -0.754, -0.758), a.rotation.set(0, 0.994, 0), a.scale.set(1.97, 1.534, 3.955), this.add(a);
                    const o = new Bi(t, i);
                    o.position.set(6.167, -0.16, 7.803), o.rotation.set(0, 0.561, 0), o.scale.set(3.927, 6.285, 3.687), this.add(o);
                    const l = new Bi(t, i);
                    l.position.set(-2.017, 0.018, 6.124), l.rotation.set(0, 0.333, 0), l.scale.set(2.002, 4.566, 2.064), this.add(l);
                    const c = new Bi(t, i);
                    c.position.set(2.291, -0.756, -2.621), c.rotation.set(0, -0.286, 0), c.scale.set(1.546, 1.552, 1.496), this.add(c);
                    const h = new Bi(t, i);
                    h.position.set(-2.193, -0.369, -5.547), h.rotation.set(0, 0.516, 0), h.scale.set(3.875, 3.487, 2.986), this.add(h);
                    const u = new Bi(t, this.createAreaLightMaterial(80));
                    u.position.set(-14, 10, 8), u.scale.set(0.1, 2.5, 2.5), this.add(u);
                    const d = new Bi(t, this.createAreaLightMaterial(80));
                    d.position.set(-14, 14, -4), d.scale.set(0.1, 2.5, 2.5), this.add(d);
                    const p = new Bi(t, this.createAreaLightMaterial(23));
                    p.position.set(14, 12, 0), p.scale.set(0.1, 5, 5), this.add(p);
                    const A = new Bi(t, this.createAreaLightMaterial(16));
                    A.position.set(0, 9, 14), A.scale.set(5, 5, 0.1), this.add(A);
                    const g = new Bi(t, this.createAreaLightMaterial(80));
                    g.position.set(7, 8, -14), g.scale.set(2.5, 2.5, 0.1), this.add(g);
                    const m = new Bi(t, this.createAreaLightMaterial(80));
                    m.position.set(-7, 16, -14), m.scale.set(2.5, 2.5, 0.1), this.add(m);
                    const f = new Bi(t, this.createAreaLightMaterial(1));
                    f.position.set(0, 20, 0), f.scale.set(0.1, 0.1, 0.1), this.add(f);
                }
                createAreaLightMaterial(t) {
                    const e = new Xe();
                    return e.color.setScalar(t), e;
                    /* @license
                     * Copyright 2019 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            const hd = /\.hdr(\.js)?$/,
                ud = new nl(),
                dd = new (class extends il {
                    constructor(t) {
                        super(t), (this.type = 1015);
                    }
                    parse(t) {
                        const e = function (t, e, i) {
                                e = e || 1024;
                                let n = t.pos,
                                    s = -1,
                                    r = 0,
                                    a = "",
                                    o = String.fromCharCode.apply(null, new Uint16Array(t.subarray(n, n + 128)));
                                for (; 0 > (s = o.indexOf("\n")) && r < e && n < t.byteLength; ) (a += o), (r += o.length), (n += 128), (o += String.fromCharCode.apply(null, new Uint16Array(t.subarray(n, n + 128))));
                                return -1 < s && (!1 !== i && (t.pos += r + s + 1), a + o.slice(0, s));
                            },
                            i = function (t, e, i, n) {
                                const s = t[e + 3],
                                    r = Math.pow(2, s - 128) / 255;
                                (i[n + 0] = t[e + 0] * r), (i[n + 1] = t[e + 1] * r), (i[n + 2] = t[e + 2] * r);
                            },
                            n = function (t, e, i, n) {
                                const s = t[e + 3],
                                    r = Math.pow(2, s - 128) / 255;
                                (i[n + 0] = Jl.toHalfFloat(t[e + 0] * r)), (i[n + 1] = Jl.toHalfFloat(t[e + 1] * r)), (i[n + 2] = Jl.toHalfFloat(t[e + 2] * r));
                            },
                            s = new Uint8Array(t);
                        s.pos = 0;
                        const r = (function (t) {
                            const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                                n = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                                s = /^\s*FORMAT=(\S+)\s*$/,
                                r = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                                a = { valid: 0, string: "", comments: "", programtype: "RGBE", format: "", gamma: 1, exposure: 1, width: 0, height: 0 };
                            let o, l;
                            if (t.pos >= t.byteLength || !(o = e(t))) return -1;
                            if (!(l = o.match(/^#\?(\S+)/))) return -1;
                            for (a.valid |= 1, a.programtype = l[1], a.string += o + "\n"; (o = e(t)), !1 !== o; )
                                if (((a.string += o + "\n"), "#" !== o.charAt(0))) {
                                    if (((l = o.match(i)) && (a.gamma = parseFloat(l[1], 10)), (l = o.match(n)) && (a.exposure = parseFloat(l[1], 10)), (l = o.match(s)) && ((a.valid |= 2), (a.format = l[1])), (l = o.match(r)) && ((a.valid |= 4), (a.height = parseInt(l[1], 10)), (a.width = parseInt(l[2], 10))), 2 & a.valid && 4 & a.valid)) break;
                                } else a.comments += o + "\n";
                            return 2 & a.valid && 4 & a.valid ? a : -1;
                        })(s);
                        if (-1 !== r) {
                            const t = r.width,
                                e = r.height,
                                a = (function (t, e, i) {
                                    const n = e;
                                    if (n < 8 || n > 32767 || 2 !== t[0] || 2 !== t[1] || 128 & t[2]) return new Uint8Array(t);
                                    if (n !== ((t[2] << 8) | t[3])) return -1;
                                    const s = new Uint8Array(4 * e * i);
                                    if (!s.length) return -1;
                                    let r = 0,
                                        a = 0;
                                    const o = 4 * n,
                                        l = new Uint8Array(4),
                                        c = new Uint8Array(o);
                                    let h = i;
                                    for (; h > 0 && a < t.byteLength; ) {
                                        if (a + 4 > t.byteLength) return -1;
                                        if (((l[0] = t[a++]), (l[1] = t[a++]), (l[2] = t[a++]), (l[3] = t[a++]), 2 != l[0] || 2 != l[1] || ((l[2] << 8) | l[3]) != n)) return -1;
                                        let e,
                                            i = 0;
                                        for (; i < o && a < t.byteLength; ) {
                                            e = t[a++];
                                            const n = e > 128;
                                            if ((n && (e -= 128), 0 === e || i + e > o)) return -1;
                                            if (n) {
                                                const n = t[a++];
                                                for (let t = 0; t < e; t++) c[i++] = n;
                                            } else c.set(t.subarray(a, a + e), i), (i += e), (a += e);
                                        }
                                        const u = n;
                                        for (let t = 0; t < u; t++) {
                                            let e = 0;
                                            (s[r] = c[t + e]), (e += n), (s[r + 1] = c[t + e]), (e += n), (s[r + 2] = c[t + e]), (e += n), (s[r + 3] = c[t + e]), (r += 4);
                                        }
                                        h--;
                                    }
                                    return s;
                                })(s.subarray(s.pos), t, e);
                            if (-1 !== a) {
                                let s, o, l, c;
                                switch (this.type) {
                                    case 1009:
                                        (s = a), (o = 1023), (l = 1009);
                                        break;
                                    case 1015:
                                        c = (a.length / 4) * 3;
                                        const t = new Float32Array(c);
                                        for (let e = 0; e < c; e++) i(a, 4 * e, t, 3 * e);
                                        (s = t), (o = 1022), (l = 1015);
                                        break;
                                    case 1016:
                                        c = (a.length / 4) * 3;
                                        const e = new Uint16Array(c);
                                        for (let t = 0; t < c; t++) n(a, 4 * t, e, 3 * t);
                                        (s = e), (o = 1022), (l = 1016);
                                }
                                return { width: t, height: e, data: s, header: r.string, gamma: r.gamma, exposure: r.exposure, format: o, type: l };
                            }
                        }
                        return null;
                    }
                    setDataType(t) {
                        return (this.type = t), this;
                    }
                    load(t, e, i, n) {
                        return super.load(
                            t,
                            function (t, i) {
                                switch (t.type) {
                                    case 1009:
                                        (t.encoding = 3002), (t.minFilter = 1003), (t.magFilter = 1003), (t.generateMipmaps = !1), (t.flipY = !0);
                                        break;
                                    case 1015:
                                    case 1016:
                                        (t.encoding = 3e3), (t.minFilter = 1006), (t.magFilter = 1006), (t.generateMipmaps = !1), (t.flipY = !0);
                                }
                                e && e(t, i);
                            },
                            i,
                            n,
                        );
                    }
                })();
            dd.setDataType(1009);
            const pd = { url: null };
            class Ad extends nt {
                constructor(t) {
                    super(), (this.generatedEnvironmentMap = null), (this.generatedEnvironmentMapAlt = null), (this.skyboxCache = new Map()), (this.environmentMapCache = new Map()), (this.PMREMGenerator = new Mn(t));
                }
                async load(t, e = () => {}) {
                    try {
                        const i = hd.test(t),
                            n = i ? dd : ud,
                            s = await new Promise((i, s) =>
                                n.load(
                                    t,
                                    i,
                                    (t) => {
                                        e((t.loaded / t.total) * 0.9);
                                    },
                                    s,
                                ),
                            );
                        return e(1), this.addMetadata(s, t), (s.mapping = 303), i || (s.encoding = 3007), s;
                    } finally {
                        e && e(1);
                    }
                }
                async generateEnvironmentMapAndSkybox(t = null, e = null, i = {}) {
                    const { progressTracker: n } = i,
                        s = null != n ? n.beginActivity() : () => {},
                        r = "neutral" === e;
                    !0 === r && (e = null);
                    const a = Nh(e);
                    try {
                        let e,
                            i = Promise.resolve(null);
                        t && (i = this.loadSkyboxFromUrl(t, n)), (e = a ? this.loadEnvironmentMapFromUrl(a, n) : t ? this.loadEnvironmentMapFromUrl(t, n) : !0 === r ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap());
                        let [s, o] = await Promise.all([e, i]);
                        if (null == s) throw new Error("Failed to load environment map.");
                        return { environmentMap: s, skybox: o };
                    } finally {
                        s(1);
                    }
                }
                addMetadata(t, e) {
                    null != t && (t.userData = Object.assign(Object.assign({}, pd), { url: e }));
                }
                loadSkyboxFromUrl(t, e) {
                    if (!this.skyboxCache.has(t)) {
                        const i = e ? e.beginActivity() : () => {},
                            n = this.load(t, i);
                        this.skyboxCache.set(t, n);
                    }
                    return this.skyboxCache.get(t);
                }
                loadEnvironmentMapFromUrl(t, e) {
                    if (!this.environmentMapCache.has(t)) {
                        const i = this.loadSkyboxFromUrl(t, e).then((e) => {
                            const i = this.PMREMGenerator.fromEquirectangular(e);
                            return this.addMetadata(i.texture, t), i;
                        });
                        this.PMREMGenerator.compileEquirectangularShader(), this.environmentMapCache.set(t, i);
                    }
                    return this.environmentMapCache.get(t);
                }
                loadGeneratedEnvironmentMap() {
                    if (null == this.generatedEnvironmentMap) {
                        const t = new ld();
                        (this.generatedEnvironmentMap = this.PMREMGenerator.fromScene(t, 0.04)), this.addMetadata(this.generatedEnvironmentMap.texture, null);
                    }
                    return Promise.resolve(this.generatedEnvironmentMap);
                }
                loadGeneratedEnvironmentMapAlt() {
                    if (null == this.generatedEnvironmentMapAlt) {
                        const t = new cd();
                        (this.generatedEnvironmentMapAlt = this.PMREMGenerator.fromScene(t, 0.04)), this.addMetadata(this.generatedEnvironmentMapAlt.texture, null);
                    }
                    return Promise.resolve(this.generatedEnvironmentMapAlt);
                }
                async dispose() {
                    const t = [];
                    this.environmentMapCache.forEach((e) => {
                        t.push(e);
                    }),
                        this.environmentMapCache.clear();
                    for (const e of t)
                        try {
                            (await e).dispose();
                        } catch (t) {}
                    null != this.generatedEnvironmentMap && (this.generatedEnvironmentMap.dispose(), (this.generatedEnvironmentMap = null)),
                        null != this.generatedEnvironmentMapAlt &&
                            (this.generatedEnvironmentMapAlt.dispose(), (this.generatedEnvironmentMapAlt = null));
                            /* @license
                             * Copyright 2019 Google LLC. All Rights Reserved.
                             * Licensed under the Apache License, Version 2.0 (the 'License');
                             * you may not use this file except in compliance with the License.
                             * You may obtain a copy of the License at
                             *
                             *     http://www.apache.org/licenses/LICENSE-2.0
                             *
                             * Unless required by applicable law or agreed to in writing, software
                             * distributed under the License is distributed on an 'AS IS' BASIS,
                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                             * See the License for the specific language governing permissions and
                             * limitations under the License.
                             */
                }
            }
            const gd = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];
            class md extends nt {
                constructor(t) {
                    super(),
                        (this.loader = new Sh(od)),
                        (this.width = 0),
                        (this.height = 0),
                        (this.dpr = 1),
                        (this.debugger = null),
                        (this.scenes = new Set()),
                        (this.multipleScenesVisible = !1),
                        (this.scaleStep = 0),
                        (this.lastStep = 3),
                        (this.avgFrameDuration = 22),
                        (this.onWebGLContextLost = (t) => {
                            this.dispatchEvent({ type: "contextlost", sourceEvent: t });
                        }),
                        (this.onWebGLContextRestored = () => {
                            var t;
                            null === (t = this.textureUtils) || void 0 === t || t.dispose(), (this.textureUtils = new Ad(this.threeRenderer)), (this.roughnessMipmapper = new xu(this.threeRenderer));
                            for (const t of this.scenes) t.element[Cu]();
                            this.threeRenderer.shadowMap.needsUpdate = !0;
                        }),
                        (this.dpr = Gh()),
                        (this.canvas3D = document.createElement("canvas")),
                        (this.canvas3D.id = "webgl-canvas");
                    try {
                        (this.threeRenderer = new Rr({ canvas: this.canvas3D, alpha: !0, antialias: !0, powerPreference: t.powerPreference, preserveDrawingBuffer: !0 })), (this.threeRenderer.autoClear = !0), (this.threeRenderer.outputEncoding = 3007), (this.threeRenderer.physicallyCorrectLights = !0), this.threeRenderer.setPixelRatio(1), (this.threeRenderer.shadowMap.enabled = !0), (this.threeRenderer.shadowMap.type = 2), (this.threeRenderer.shadowMap.autoUpdate = !1), (this.debugger = t.debug ? new Gu(this) : null), (this.threeRenderer.debug = { checkShaderErrors: !!this.debugger }), (this.threeRenderer.toneMapping = 4);
                    } catch (t) {}
                    (this.arRenderer = new Ou(this)), (this.textureUtils = this.canRender ? new Ad(this.threeRenderer) : null), (this.roughnessMipmapper = new xu(this.threeRenderer)), Sh.initializeKTX2Loader(this.threeRenderer), this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored), this.updateRendererSize(), (this.lastTick = performance.now()), (this.avgFrameDuration = 0);
                }
                static get singleton() {
                    return this._singleton;
                }
                static resetSingleton() {
                    const t = this._singleton.dispose();
                    for (const e of t) e.disconnectedCallback();
                    this._singleton = new md({ powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance", debug: zh() });
                    for (const e of t) e.connectedCallback();
                }
                get canRender() {
                    return null != this.threeRenderer;
                }
                get scaleFactor() {
                    return gd[this.scaleStep];
                }
                set minScale(t) {
                    let e = 1;
                    for (; e < gd.length && !(gd[e] < t); ) ++e;
                    this.lastStep = e - 1;
                }
                updateRendererSize() {
                    const t = Gh();
                    if (t !== this.dpr)
                        for (const t of this.scenes) {
                            const { element: e } = t;
                            e[zd](e.getBoundingClientRect());
                        }
                    let e = 0,
                        i = 0;
                    for (const t of this.scenes) (e = Math.max(e, t.width)), (i = Math.max(i, t.height));
                    if (e === this.width && i === this.height && t === this.dpr) return;
                    (this.width = e), (this.height = i), (this.dpr = t), this.canRender && this.threeRenderer.setSize(e * t, i * t, !1);
                    const n = this.scaleFactor,
                        s = e / n,
                        r = i / n;
                    (this.canvas3D.style.width = `${s}px`), (this.canvas3D.style.height = `${r}px`);
                    for (const n of this.scenes) {
                        const { canvas: a } = n;
                        (a.width = Math.round(e * t)), (a.height = Math.round(i * t)), (a.style.width = `${s}px`), (a.style.height = `${r}px`), (n.isDirty = !0);
                    }
                }
                updateRendererScale() {
                    const t = this.scaleStep;
                    if ((this.avgFrameDuration > 26 && this.scaleStep < this.lastStep ? ++this.scaleStep : this.avgFrameDuration < 18 && this.scaleStep > 0 && --this.scaleStep, t == this.scaleStep)) return;
                    const e = this.scaleFactor;
                    this.avgFrameDuration = 22;
                    const i = this.width / e,
                        n = this.height / e;
                    (this.canvas3D.style.width = `${i}px`), (this.canvas3D.style.height = `${n}px`);
                    for (const t of this.scenes) {
                        const { style: e } = t.canvas;
                        (e.width = `${i}px`), (e.height = `${n}px`), (t.isDirty = !0);
                    }
                }
                registerScene(t) {
                    this.scenes.add(t);
                    const { canvas: e } = t,
                        i = this.scaleFactor;
                    (e.width = Math.round(this.width * this.dpr)), (e.height = Math.round(this.height * this.dpr)), (e.style.width = this.width / i + "px"), (e.style.height = this.height / i + "px"), this.multipleScenesVisible && e.classList.add("show"), (t.isDirty = !0), this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((t, e) => this.render(t, e)), null != this.debugger && this.debugger.addScene(t);
                }
                unregisterScene(t) {
                    this.scenes.delete(t), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null), null != this.debugger && this.debugger.removeScene(t);
                }
                displayCanvas(t) {
                    return this.multipleScenesVisible ? t.element[Zd] : this.canvas3D;
                }
                selectCanvas() {
                    let t = 0,
                        e = null;
                    for (const i of this.scenes) {
                        const { element: n } = i;
                        n.modelIsVisible && null == i.externalRenderer && (++t, (e = i.canvas));
                    }
                    if (null == e) return;
                    const i = t > 1,
                        { canvas3D: n } = this;
                    if (i !== this.multipleScenesVisible || (!i && n.parentElement !== e.parentElement)) {
                        (this.multipleScenesVisible = i), i && n.classList.remove("show");
                        for (const t of this.scenes) {
                            if (null != t.externalRenderer) continue;
                            const s = t.element[Zd];
                            i ? (s.classList.add("show"), (t.isDirty = !0)) : t.canvas === e && (t.canvas.parentElement.appendChild(n), n.classList.add("show"), s.classList.remove("show"), (t.isDirty = !0));
                        }
                    }
                }
                orderedScenes() {
                    const t = [];
                    for (const e of [!1, !0]) for (const i of this.scenes) i.element.modelIsVisible === e && t.push(i);
                    return t;
                }
                get isPresenting() {
                    return this.arRenderer.isPresenting;
                }
                preRender(t, e, i) {
                    const { element: n, exposure: s } = t;
                    n[ep](e, i);
                    const r = "number" == typeof s && !self.isNaN(s);
                    (this.threeRenderer.toneMappingExposure = r ? s : 1), t.isShadowDirty() && (this.threeRenderer.shadowMap.needsUpdate = !0);
                }
                render(t, e) {
                    if (null != e) return void this.arRenderer.onWebXRFrame(t, e);
                    const i = t - this.lastTick;
                    if (((this.lastTick = t), !this.canRender || this.isPresenting)) return;
                    (this.avgFrameDuration += Oh(0.2 * (i - this.avgFrameDuration), -2, 2)), this.selectCanvas(), this.updateRendererSize(), this.updateRendererScale();
                    const { dpr: n, scaleFactor: s } = this;
                    for (const e of this.orderedScenes()) {
                        const { element: r } = e;
                        if (!r.modelIsVisible && e.renderCount > 0) continue;
                        if ((this.preRender(e, t, i), !e.isDirty)) continue;
                        if (null != e.externalRenderer) {
                            const t = e.getCamera();
                            t.updateMatrix();
                            const { matrix: i, projectionMatrix: n } = t,
                                s = i.elements.slice(),
                                r = e.getTarget();
                            (s[12] += r.x), (s[13] += r.y), (s[14] += r.z), e.externalRenderer.render({ viewMatrix: s, projectionMatrix: n.elements });
                            continue;
                        }
                        if (!r.modelIsVisible && !this.multipleScenesVisible) for (const t of this.scenes) t.element.modelIsVisible && (t.isDirty = !0);
                        const a = Math.min(Math.ceil(e.width * s * n), this.canvas3D.width),
                            o = Math.min(Math.ceil(e.height * s * n), this.canvas3D.height);
                        if ((this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.floor(this.height * n) - o, a, o), this.threeRenderer.render(e, e.camera), this.multipleScenesVisible)) {
                            null == e.context && e.createContext();
                            const t = e.context;
                            t.clearRect(0, 0, a, o), t.drawImage(this.canvas3D, 0, 0, a, o, 0, 0, a, o);
                        }
                        (e.isDirty = !1), r.loaded && ++e.renderCount;
                    }
                }
                dispose() {
                    null != this.textureUtils && this.textureUtils.dispose(), null != this.roughnessMipmapper && this.roughnessMipmapper.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), (this.textureUtils = null), (this.threeRenderer = null);
                    const t = [];
                    for (const e of this.scenes) t.push(e.element);
                    return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), t;
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var fd, vd;
            md._singleton = new md({ powerPreference: (self.ModelViewerElement || {}).powerPreference || "high-performance", debug: zh() });
            const yd = Symbol("ongoingActivities"),
                xd = Symbol("announceTotalProgress"),
                wd = Symbol("eventDelegate");
            class _d {
                constructor() {
                    (this[fd] = document.createDocumentFragment()), (this.addEventListener = (...t) => this[wd].addEventListener(...t)), (this.removeEventListener = (...t) => this[wd].removeEventListener(...t)), (this.dispatchEvent = (...t) => this[wd].dispatchEvent(...t)), (this[vd] = new Set());
                }
                get ongoingActivityCount() {
                    return this[yd].size;
                }
                beginActivity() {
                    const t = { progress: 0 };
                    return (
                        this[yd].add(t),
                        1 === this.ongoingActivityCount && this[xd](),
                        (e) => {
                            let i;
                            return (i = Math.max(Oh(e, 0, 1), t.progress)), i !== t.progress && ((t.progress = i), this[xd]()), t.progress;
                        }
                    );
                }
                [((fd = wd), (vd = yd), xd)]() {
                    let t = 0,
                        e = 0,
                        i = 0;
                    for (const n of this[yd]) {
                        const { progress: s } = n;
                        (t += s * (0.5 / Math.pow(2, e++))), 1 === s && i++;
                    }
                    i === this.ongoingActivityCount && ((t = 1), this[yd].clear()), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: t } }));
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var Id,
                Cd,
                Md,
                Ed,
                bd,
                Sd,
                Bd,
                Td,
                Ld,
                Dd,
                Qd = function (t, e, i, n) {
                    for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                    return r > 3 && a && Object.defineProperty(e, i, a), a;
                };
            const Rd = document.createElement("canvas"),
                Pd = Symbol("template"),
                Nd = Symbol("fallbackResizeHandler"),
                Fd = Symbol("defaultAriaLabel"),
                Ud = Symbol("resizeObserver"),
                kd = Symbol("clearModelTimeout"),
                Od = Symbol("onContextLost"),
                Gd = Symbol("loaded"),
                zd = Symbol("updateSize"),
                Vd = Symbol("intersectionObserver"),
                Hd = Symbol("isElementInViewport"),
                Wd = Symbol("announceModelVisibility"),
                qd = Symbol("ariaLabel"),
                jd = Symbol("loadedTime"),
                Yd = Symbol("updateSource"),
                Jd = Symbol("markLoaded"),
                Xd = Symbol("container"),
                Kd = Symbol("input"),
                Zd = Symbol("canvas"),
                $d = Symbol("scene"),
                tp = Symbol("needsRender"),
                ep = Symbol("tick"),
                ip = Symbol("onModelLoad"),
                np = Symbol("onResize"),
                sp = Symbol("renderer"),
                rp = Symbol("progressTracker"),
                ap = Symbol("getLoaded"),
                op = Symbol("getModelIsVisible"),
                lp = Symbol("shouldAttemptPreload"),
                cp = Symbol("sceneIsReady"),
                hp = Symbol("hasTransitioned"),
                up = (t) => ({
                    x: t.x,
                    y: t.y,
                    z: t.z,
                    toString() {
                        return `${this.x}m ${this.y}m ${this.z}m`;
                    },
                });
            class dp extends F {
                constructor() {
                    super(),
                        (this.alt = null),
                        (this.src = null),
                        (this[Id] = !1),
                        (this[Cd] = !1),
                        (this[Md] = 0),
                        (this[Ed] = null),
                        (this[bd] = kh(() => {
                            const t = this.getBoundingClientRect();
                            this[zd](t);
                        }, 50)),
                        (this[Sd] = kh((t) => {
                            const e = this.modelIsVisible;
                            e !== t && this.dispatchEvent(new CustomEvent("model-visibility", { detail: { visible: e } }));
                        }, 0)),
                        (this[Bd] = null),
                        (this[Td] = null),
                        (this[Ld] = new _d()),
                        (this[Dd] = (t) => {
                            this.dispatchEvent(new CustomEvent("error", { detail: { type: "webglcontextlost", sourceError: t.sourceEvent } }));
                        });
                    const t = this.constructor.template;
                    window.ShadyCSS && window.ShadyCSS.styleElement(this, {}), this.attachShadow({ mode: "open" });
                    const e = this.shadowRoot;
                    let i, n;
                    if ((e.appendChild(t.content.cloneNode(!0)), (this[Xd] = e.querySelector(".container")), (this[Kd] = e.querySelector(".userInput")), (this[Zd] = e.querySelector("canvas")), (this[Fd] = this[Kd].getAttribute("aria-label")), this.isConnected)) {
                        const t = this.getBoundingClientRect();
                        (i = t.width), (n = t.height);
                    } else (i = 300), (n = 150);
                    (this[$d] = new Au({ canvas: this[Zd], element: this, width: i, height: n })),
                        this[$d].addEventListener("model-load", async (t) => {
                            this[Jd](), this[ip](), await ((t = 0) => new Promise((e) => setTimeout(e, t)))(), this.dispatchEvent(new CustomEvent("load", { detail: { url: t.url } }));
                        }),
                        Promise.resolve().then(() => {
                            this[zd](this.getBoundingClientRect());
                        }),
                        j &&
                            (this[Ud] = new ResizeObserver((t) => {
                                if (!this[sp].isPresenting) for (let e of t) e.target === this && this[zd](e.contentRect);
                            })),
                        Y
                            ? (this[Vd] = new IntersectionObserver(
                                  (t) => {
                                      for (let e of t)
                                          if (e.target === this) {
                                              const t = this.modelIsVisible;
                                              (this[Hd] = e.isIntersecting), this[Wd](t), this[Hd] && !this[cp]() && this[Yd]();
                                          }
                                  },
                                  { root: null, rootMargin: "0px", threshold: 0 },
                              ))
                            : (this[Hd] = !0);
                }
                static get is() {
                    return "model-viewer";
                }
                static get template() {
                    return (
                        this.hasOwnProperty(Pd) ||
                            (this[Pd] = ((t) => {
                                const e = document.createElement("template");
                                return (e.innerHTML = it.innerHTML), window.ShadyCSS && window.ShadyCSS.prepareTemplate(e, t), e;
                            })(this.is)),
                        this[Pd]
                    );
                }
                static set modelCacheSize(t) {
                    Sh[Eh].evictionThreshold = t;
                }
                static get modelCacheSize() {
                    return Sh[Eh].evictionThreshold;
                }
                static set minimumRenderScale(t) {
                    md.singleton.minScale = t;
                }
                static get minimumRenderScale() {
                    return md.singleton.minScale;
                }
                get loaded() {
                    return this[ap]();
                }
                get [((Id = Hd), (Cd = Gd), (Md = jd), (Ed = kd), (bd = Nd), (Sd = Wd), (Bd = Ud), (Td = Vd), (Ld = rp), sp)]() {
                    return md.singleton;
                }
                get modelIsVisible() {
                    return this[op]();
                }
                connectedCallback() {
                    super.connectedCallback && super.connectedCallback(), j ? this[Ud].observe(this) : self.addEventListener("resize", this[Nd]), Y && this[Vd].observe(this);
                    const t = this[sp];
                    t.addEventListener("contextlost", this[Od]), t.registerScene(this[$d]), null != this[kd] && (self.clearTimeout(this[kd]), (this[kd] = null), this.requestUpdate("src", null));
                }
                disconnectedCallback() {
                    super.disconnectedCallback && super.disconnectedCallback(), j ? this[Ud].unobserve(this) : self.removeEventListener("resize", this[Nd]), Y && this[Vd].unobserve(this);
                    const t = this[sp];
                    t.removeEventListener("contextlost", this[Od]),
                        t.unregisterScene(this[$d]),
                        (this[kd] = self.setTimeout(() => {
                            this[$d].reset();
                        }, 1e3));
                }
                updated(t) {
                    if ((super.updated(t), t.has("src") && (null == this.src ? ((this[Gd] = !1), (this[jd] = 0), this[$d].reset()) : this.src !== this[$d].url && ((this[Gd] = !1), (this[jd] = 0), this[Yd]())), t.has("alt"))) {
                        const t = null == this.alt ? this[Fd] : this.alt;
                        this[Kd].setAttribute("aria-label", t);
                    }
                }
                toDataURL(t, e) {
                    return this[sp].displayCanvas(this[$d]).toDataURL(t, e);
                }
                async toBlob(t) {
                    const e = t ? t.mimeType : void 0,
                        i = t ? t.qualityArgument : void 0,
                        n = t ? t.idealAspect : void 0,
                        { width: s, height: r, fieldOfViewAspect: a, aspect: o } = this[$d],
                        { dpr: l, scaleFactor: c } = this[sp];
                    let h = s * c * l,
                        u = r * c * l,
                        d = 0,
                        p = 0;
                    if (!0 === n)
                        if (a > o) {
                            const t = u;
                            (u = Math.round(h / a)), (p = (t - u) / 2);
                        } else {
                            const t = h;
                            (h = Math.round(u * a)), (d = (t - h) / 2);
                        }
                    (Rd.width = h), (Rd.height = u);
                    try {
                        return new Promise(
                            async (t, n) => (
                                Rd.getContext("2d").drawImage(this[sp].displayCanvas(this[$d]), d, p, h, u, 0, 0, h, u),
                                !Rd.msToBlob || (e && "image/png" !== e)
                                    ? Rd.toBlob
                                        ? void Rd.toBlob(
                                              (e) => {
                                                  if (!e) return n(new Error("Unable to retrieve canvas blob"));
                                                  t(e);
                                              },
                                              e,
                                              i,
                                          )
                                        : t(
                                              await (async (t) =>
                                                  new Promise((e, i) => {
                                                      const n = t.match(/data:(.*);/);
                                                      if (!n) return i(new Error(`${t} is not a valid data Url`));
                                                      const s = n[1],
                                                          r = t.replace(/data:image\/\w+;base64,/, ""),
                                                          a = atob(r),
                                                          o = [];
                                                      for (let t = 0; t < a.length; t += 512) {
                                                          const e = a.slice(t, t + 512),
                                                              i = new Array(e.length);
                                                          for (let t = 0; t < e.length; t++) i[t] = e.charCodeAt(t);
                                                          const n = new Uint8Array(i);
                                                          o.push(n);
                                                      }
                                                      e(new Blob(o, { type: s }));
                                                  }))(Rd.toDataURL(e, i)),
                                          )
                                    : t(Rd.msToBlob())
                            ),
                        );
                    } finally {
                        this[zd]({ width: s, height: r });
                    }
                }
                registerRenderer(t) {
                    this[$d].externalRenderer = t;
                }
                unregisterRenderer() {
                    this[$d].externalRenderer = null;
                }
                get [qd]() {
                    return null == this.alt || "null" === this.alt ? this[Fd] : this.alt;
                }
                [ap]() {
                    return this[Gd];
                }
                [op]() {
                    return this.loaded && this[Hd];
                }
                [hp]() {
                    return this.modelIsVisible;
                }
                [lp]() {
                    return !!this.src && this[Hd];
                }
                [cp]() {
                    return this[Gd];
                }
                [zd]({ width: t, height: e }) {
                    (this[Xd].style.width = `${t}px`), (this[Xd].style.height = `${e}px`), this[np]({ width: parseFloat(t), height: parseFloat(e) });
                }
                [ep](t, e) {}
                [Jd]() {
                    this[Gd] || ((this[Gd] = !0), (this[jd] = performance.now()));
                }
                [tp]() {
                    this[$d].isDirty = !0;
                }
                [ip]() {}
                [np](t) {
                    this[$d].setSize(t.width, t.height);
                }
                async [((Dd = Od), Yd)]() {
                    if (this.loaded || !this[lp]()) return;
                    const t = this[rp].beginActivity(),
                        e = this.src;
                    try {
                        await this[$d].setSource(e, (e) => t(0.8 * e));
                        const i = { url: e };
                        this.dispatchEvent(new CustomEvent("preload", { detail: i }));
                    } catch (t) {
                        this.dispatchEvent(new CustomEvent("error", { detail: t }));
                    } finally {
                        t(0.9),
                            requestAnimationFrame(() => {
                                requestAnimationFrame(() => {
                                    t(1);
                                });
                            });
                    }
                }
            }
            Qd([k({ type: String })], dp.prototype, "alt", void 0), Qd([k({ type: String })], dp.prototype, "src", void 0);
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var pp = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            const Ap = Symbol("changeAnimation"),
                gp = Symbol("paused"),
                mp = Symbol("hotspotMap"),
                fp = Symbol("mutationCallback"),
                vp = Symbol("observer"),
                yp = Symbol("addHotspot"),
                xp = Symbol("removeHotspot"),
                wp = new mt(),
                _p = new se(),
                Ip = new ft();
            /*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/ var Cp = function (t) {
                return URL.createObjectURL(new Blob([t], { type: "text/javascript" }));
            };
            try {
                URL.revokeObjectURL(Cp(""));
            } catch (Uc) {
                Cp = function (t) {
                    return "data:application/javascript;charset=UTF-8," + encodeURI(t);
                };
            }
            var Mp = Uint8Array,
                Ep = Uint16Array,
                bp = Uint32Array,
                Sp = new Mp([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
                Bp = new Mp([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
                Tp = new Mp([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                Lp = function (t, e) {
                    for (var i = new Ep(31), n = 0; n < 31; ++n) i[n] = e += 1 << t[n - 1];
                    var s = new bp(i[30]);
                    for (n = 1; n < 30; ++n) for (var r = i[n]; r < i[n + 1]; ++r) s[r] = ((r - i[n]) << 5) | n;
                    return [i, s];
                },
                Dp = Lp(Sp, 2),
                Qp = Dp[0],
                Rp = Dp[1];
            (Qp[28] = 258), (Rp[258] = 28);
            for (var Pp = Lp(Bp, 0)[1], Np = new Ep(32768), Fp = 0; Fp < 32768; ++Fp) {
                var Up = ((43690 & Fp) >>> 1) | ((21845 & Fp) << 1);
                (Up = ((61680 & (Up = ((52428 & Up) >>> 2) | ((13107 & Up) << 2))) >>> 4) | ((3855 & Up) << 4)), (Np[Fp] = (((65280 & Up) >>> 8) | ((255 & Up) << 8)) >>> 1);
            }
            var kp = function (t, e, i) {
                    for (var n = t.length, s = 0, r = new Ep(e); s < n; ++s) ++r[t[s] - 1];
                    var a,
                        o = new Ep(e);
                    for (s = 0; s < e; ++s) o[s] = (o[s - 1] + r[s - 1]) << 1;
                    if (i) {
                        a = new Ep(1 << e);
                        var l = 15 - e;
                        for (s = 0; s < n; ++s) if (t[s]) for (var c = (s << 4) | t[s], h = e - t[s], u = o[t[s] - 1]++ << h, d = u | ((1 << h) - 1); u <= d; ++u) a[Np[u] >>> l] = c;
                    } else for (a = new Ep(n), s = 0; s < n; ++s) t[s] && (a[s] = Np[o[t[s] - 1]++] >>> (15 - t[s]));
                    return a;
                },
                Op = new Mp(288);
            for (Fp = 0; Fp < 144; ++Fp) Op[Fp] = 8;
            for (Fp = 144; Fp < 256; ++Fp) Op[Fp] = 9;
            for (Fp = 256; Fp < 280; ++Fp) Op[Fp] = 7;
            for (Fp = 280; Fp < 288; ++Fp) Op[Fp] = 8;
            var Gp = new Mp(32);
            for (Fp = 0; Fp < 32; ++Fp) Gp[Fp] = 5;
            var zp = kp(Op, 9, 0),
                Vp = kp(Gp, 5, 0),
                Hp = function (t) {
                    return ((t / 8) | 0) + (7 & t && 1);
                },
                Wp = function (t, e, i) {
                    (null == e || e < 0) && (e = 0), (null == i || i > t.length) && (i = t.length);
                    var n = new (t instanceof Ep ? Ep : t instanceof bp ? bp : Mp)(i - e);
                    return n.set(t.subarray(e, i)), n;
                },
                qp = function (t, e, i) {
                    i <<= 7 & e;
                    var n = (e / 8) | 0;
                    (t[n] |= i), (t[n + 1] |= i >>> 8);
                },
                jp = function (t, e, i) {
                    i <<= 7 & e;
                    var n = (e / 8) | 0;
                    (t[n] |= i), (t[n + 1] |= i >>> 8), (t[n + 2] |= i >>> 16);
                },
                Yp = function (t, e) {
                    for (var i = [], n = 0; n < t.length; ++n) t[n] && i.push({ s: n, f: t[n] });
                    var s = i.length,
                        r = i.slice();
                    if (!s) return [eA, 0];
                    if (1 == s) {
                        var a = new Mp(i[0].s + 1);
                        return (a[i[0].s] = 1), [a, 1];
                    }
                    i.sort(function (t, e) {
                        return t.f - e.f;
                    }),
                        i.push({ s: -1, f: 25001 });
                    var o = i[0],
                        l = i[1],
                        c = 0,
                        h = 1,
                        u = 2;
                    for (i[0] = { s: -1, f: o.f + l.f, l: o, r: l }; h != s - 1; ) (o = i[i[c].f < i[u].f ? c++ : u++]), (l = i[c != h && i[c].f < i[u].f ? c++ : u++]), (i[h++] = { s: -1, f: o.f + l.f, l: o, r: l });
                    var d = r[0].s;
                    for (n = 1; n < s; ++n) r[n].s > d && (d = r[n].s);
                    var p = new Ep(d + 1),
                        A = Jp(i[h - 1], p, 0);
                    if (A > e) {
                        n = 0;
                        var g = 0,
                            m = A - e,
                            f = 1 << m;
                        for (
                            r.sort(function (t, e) {
                                return p[e.s] - p[t.s] || t.f - e.f;
                            });
                            n < s;
                            ++n
                        ) {
                            var v = r[n].s;
                            if (!(p[v] > e)) break;
                            (g += f - (1 << (A - p[v]))), (p[v] = e);
                        }
                        for (g >>>= m; g > 0; ) {
                            var y = r[n].s;
                            p[y] < e ? (g -= 1 << (e - p[y]++ - 1)) : ++n;
                        }
                        for (; n >= 0 && g; --n) {
                            var x = r[n].s;
                            p[x] == e && (--p[x], ++g);
                        }
                        A = e;
                    }
                    return [new Mp(p), A];
                },
                Jp = function (t, e, i) {
                    return -1 == t.s ? Math.max(Jp(t.l, e, i + 1), Jp(t.r, e, i + 1)) : (e[t.s] = i);
                },
                Xp = function (t) {
                    for (var e = t.length; e && !t[--e]; );
                    for (
                        var i = new Ep(++e),
                            n = 0,
                            s = t[0],
                            r = 1,
                            a = function (t) {
                                i[n++] = t;
                            },
                            o = 1;
                        o <= e;
                        ++o
                    )
                        if (t[o] == s && o != e) ++r;
                        else {
                            if (!s && r > 2) {
                                for (; r > 138; r -= 138) a(32754);
                                r > 2 && (a(r > 10 ? ((r - 11) << 5) | 28690 : ((r - 3) << 5) | 12305), (r = 0));
                            } else if (r > 3) {
                                for (a(s), --r; r > 6; r -= 6) a(8304);
                                r > 2 && (a(((r - 3) << 5) | 8208), (r = 0));
                            }
                            for (; r--; ) a(s);
                            (r = 1), (s = t[o]);
                        }
                    return [i.subarray(0, n), e];
                },
                Kp = function (t, e) {
                    for (var i = 0, n = 0; n < e.length; ++n) i += t[n] * e[n];
                    return i;
                },
                Zp = function (t, e, i) {
                    var n = i.length,
                        s = Hp(e + 2);
                    (t[s] = 255 & n), (t[s + 1] = n >>> 8), (t[s + 2] = 255 ^ t[s]), (t[s + 3] = 255 ^ t[s + 1]);
                    for (var r = 0; r < n; ++r) t[s + r + 4] = i[r];
                    return 8 * (s + 4 + n);
                },
                $p = function (t, e, i, n, s, r, a, o, l, c, h) {
                    qp(e, h++, i), ++s[256];
                    for (var u = Yp(s, 15), d = u[0], p = u[1], A = Yp(r, 15), g = A[0], m = A[1], f = Xp(d), v = f[0], y = f[1], x = Xp(g), w = x[0], _ = x[1], I = new Ep(19), C = 0; C < v.length; ++C) I[31 & v[C]]++;
                    for (C = 0; C < w.length; ++C) I[31 & w[C]]++;
                    for (var M = Yp(I, 7), E = M[0], b = M[1], S = 19; S > 4 && !E[Tp[S - 1]]; --S);
                    var B,
                        T,
                        L,
                        D,
                        Q = (c + 5) << 3,
                        R = Kp(s, Op) + Kp(r, Gp) + a,
                        P = Kp(s, d) + Kp(r, g) + a + 14 + 3 * S + Kp(I, E) + (2 * I[16] + 3 * I[17] + 7 * I[18]);
                    if (Q <= R && Q <= P) return Zp(e, h, t.subarray(l, l + c));
                    if ((qp(e, h, 1 + (P < R)), (h += 2), P < R)) {
                        (B = kp(d, p, 0)), (T = d), (L = kp(g, m, 0)), (D = g);
                        var N = kp(E, b, 0);
                        for (qp(e, h, y - 257), qp(e, h + 5, _ - 1), qp(e, h + 10, S - 4), h += 14, C = 0; C < S; ++C) qp(e, h + 3 * C, E[Tp[C]]);
                        h += 3 * S;
                        for (var F = [v, w], U = 0; U < 2; ++U) {
                            var k = F[U];
                            for (C = 0; C < k.length; ++C) {
                                var O = 31 & k[C];
                                qp(e, h, N[O]), (h += E[O]), O > 15 && (qp(e, h, (k[C] >>> 5) & 127), (h += k[C] >>> 12));
                            }
                        }
                    } else (B = zp), (T = Op), (L = Vp), (D = Gp);
                    for (C = 0; C < o; ++C)
                        if (n[C] > 255) {
                            (O = (n[C] >>> 18) & 31), jp(e, h, B[O + 257]), (h += T[O + 257]), O > 7 && (qp(e, h, (n[C] >>> 23) & 31), (h += Sp[O]));
                            var G = 31 & n[C];
                            jp(e, h, L[G]), (h += D[G]), G > 3 && (jp(e, h, (n[C] >>> 5) & 8191), (h += Bp[G]));
                        } else jp(e, h, B[n[C]]), (h += T[n[C]]);
                    return jp(e, h, B[256]), h + T[256];
                },
                tA = new bp([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
                eA = new Mp(0),
                iA = (function () {
                    for (var t = new bp(256), e = 0; e < 256; ++e) {
                        for (var i = e, n = 9; --n; ) i = (1 & i && 3988292384) ^ (i >>> 1);
                        t[e] = i;
                    }
                    return t;
                })(),
                nA = function () {
                    var t = -1;
                    return {
                        p: function (e) {
                            for (var i = t, n = 0; n < e.length; ++n) i = iA[(255 & i) ^ e[n]] ^ (i >>> 8);
                            t = i;
                        },
                        d: function () {
                            return ~t;
                        },
                    };
                },
                sA = function (t, e) {
                    var i = {};
                    for (var n in t) i[n] = t[n];
                    for (var n in e) i[n] = e[n];
                    return i;
                },
                rA = function (t, e, i) {
                    for (; i; ++e) (t[e] = i), (i >>>= 8);
                };
            function aA(t, e) {
                return (function (t, e, i, n, s) {
                    return (function (t, e, i, n, s, r) {
                        var a = t.length,
                            o = new Mp(n + a + 5 * (1 + Math.ceil(a / 7e3)) + s),
                            l = o.subarray(n, o.length - s),
                            c = 0;
                        if (!e || a < 8)
                            for (var h = 0; h <= a; h += 65535) {
                                var u = h + 65535;
                                u < a ? (c = Zp(l, c, t.subarray(h, u))) : ((l[h] = r), (c = Zp(l, c, t.subarray(h, a))));
                            }
                        else {
                            for (
                                var d = tA[e - 1],
                                    p = d >>> 13,
                                    A = 8191 & d,
                                    g = (1 << i) - 1,
                                    m = new Ep(32768),
                                    f = new Ep(g + 1),
                                    v = Math.ceil(i / 3),
                                    y = 2 * v,
                                    x = function (e) {
                                        return (t[e] ^ (t[e + 1] << v) ^ (t[e + 2] << y)) & g;
                                    },
                                    w = new bp(25e3),
                                    _ = new Ep(288),
                                    I = new Ep(32),
                                    C = 0,
                                    M = 0,
                                    E = ((h = 0), 0),
                                    b = 0,
                                    S = 0;
                                h < a;
                                ++h
                            ) {
                                var B = x(h),
                                    T = 32767 & h,
                                    L = f[B];
                                if (((m[T] = L), (f[B] = T), b <= h)) {
                                    var D = a - h;
                                    if ((C > 7e3 || E > 24576) && D > 423) {
                                        (c = $p(t, l, 0, w, _, I, M, E, S, h - S, c)), (E = C = M = 0), (S = h);
                                        for (var Q = 0; Q < 286; ++Q) _[Q] = 0;
                                        for (Q = 0; Q < 30; ++Q) I[Q] = 0;
                                    }
                                    var R = 2,
                                        P = 0,
                                        N = A,
                                        F = (T - L) & 32767;
                                    if (D > 2 && B == x(h - F))
                                        for (var U = Math.min(p, D) - 1, k = Math.min(32767, h), O = Math.min(258, D); F <= k && --N && T != L; ) {
                                            if (t[h + R] == t[h + R - F]) {
                                                for (var G = 0; G < O && t[h + G] == t[h + G - F]; ++G);
                                                if (G > R) {
                                                    if (((R = G), (P = F), G > U)) break;
                                                    var z = Math.min(F, G - 2),
                                                        V = 0;
                                                    for (Q = 0; Q < z; ++Q) {
                                                        var H = (h - F + Q + 32768) & 32767,
                                                            W = (H - m[H] + 32768) & 32767;
                                                        W > V && ((V = W), (L = H));
                                                    }
                                                }
                                            }
                                            F += ((T = L) - (L = m[T]) + 32768) & 32767;
                                        }
                                    if (P) {
                                        w[E++] = 268435456 | (Rp[R] << 18) | Pp[P];
                                        var q = 31 & Rp[R],
                                            j = 31 & Pp[P];
                                        (M += Sp[q] + Bp[j]), ++_[257 + q], ++I[j], (b = h + R), ++C;
                                    } else (w[E++] = t[h]), ++_[t[h]];
                                }
                            }
                            (c = $p(t, l, r, w, _, I, M, E, S, h - S, c)), !r && 7 & c && (c = Zp(l, c + 1, eA));
                        }
                        return Wp(o, 0, n + Hp(c) + s);
                    })(t, null == e.level ? 6 : e.level, null == e.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t.length)))) : 12 + e.mem, i, n, !s);
                })(t, e || {}, 0, 0);
            }
            var oA = function (t, e, i, n) {
                    for (var s in t) {
                        var r = t[s],
                            a = e + s;
                        r instanceof Mp ? (i[a] = [r, n]) : Array.isArray(r) ? (i[a] = [r[0], sA(n, r[1])]) : oA(r, a + "/", i, n);
                    }
                },
                lA = "undefined" != typeof TextEncoder && new TextEncoder(),
                cA = "undefined" != typeof TextDecoder && new TextDecoder();
            try {
                cA.decode(eA, { stream: !0 });
            } catch (Uc) {}
            function hA(t, e) {
                if (e) {
                    for (var i = new Mp(t.length), n = 0; n < t.length; ++n) i[n] = t.charCodeAt(n);
                    return i;
                }
                if (lA) return lA.encode(t);
                var s = t.length,
                    r = new Mp(t.length + (t.length >> 1)),
                    a = 0,
                    o = function (t) {
                        r[a++] = t;
                    };
                for (n = 0; n < s; ++n) {
                    if (a + 5 > r.length) {
                        var l = new Mp(a + 8 + ((s - n) << 1));
                        l.set(r), (r = l);
                    }
                    var c = t.charCodeAt(n);
                    c < 128 || e ? o(c) : c < 2048 ? (o(192 | (c >> 6)), o(128 | (63 & c))) : c > 55295 && c < 57344 ? (o(240 | ((c = (65536 + (1047552 & c)) | (1023 & t.charCodeAt(++n))) >> 18)), o(128 | ((c >> 12) & 63)), o(128 | ((c >> 6) & 63)), o(128 | (63 & c))) : (o(224 | (c >> 12)), o(128 | ((c >> 6) & 63)), o(128 | (63 & c)));
                }
                return Wp(r, 0, a);
            }
            var uA = function (t) {
                    var e = 0;
                    if (t)
                        for (var i in t) {
                            var n = t[i].length;
                            if (n > 65535) throw "extra field too long";
                            e += n + 4;
                        }
                    return e;
                },
                dA = function (t, e, i, n, s, r, a, o) {
                    var l = n.length,
                        c = i.extra,
                        h = o && o.length,
                        u = uA(c);
                    rA(t, e, null != a ? 33639248 : 67324752), (e += 4), null != a && ((t[e++] = 20), (t[e++] = i.os)), (t[e] = 20), (e += 2), (t[e++] = (i.flag << 1) | (null == r && 8)), (t[e++] = s && 8), (t[e++] = 255 & i.compression), (t[e++] = i.compression >> 8);
                    var d = new Date(null == i.mtime ? Date.now() : i.mtime),
                        p = d.getFullYear() - 1980;
                    if (p < 0 || p > 119) throw "date not in range 1980-2099";
                    if ((rA(t, e, (p << 25) | ((d.getMonth() + 1) << 21) | (d.getDate() << 16) | (d.getHours() << 11) | (d.getMinutes() << 5) | (d.getSeconds() >>> 1)), (e += 4), null != r && (rA(t, e, i.crc), rA(t, e + 4, r), rA(t, e + 8, i.size)), rA(t, e + 12, l), rA(t, e + 14, u), (e += 16), null != a && (rA(t, e, h), rA(t, e + 6, i.attrs), rA(t, e + 10, a), (e += 14)), t.set(n, e), (e += l), u))
                        for (var A in c) {
                            var g = c[A],
                                m = g.length;
                            rA(t, e, +A), rA(t, e + 2, m), t.set(g, e + 4), (e += 4 + m);
                        }
                    return h && (t.set(o, e), (e += h)), e;
                };
            class pA {
                async parse(t) {
                    const e = { "model.usda": null };
                    let i = '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
                    const n = {},
                        s = {};
                    t.traverseVisible((t) => {
                        if (t.isMesh && t.material.isMeshStandardMaterial) {
                            const s = t.geometry,
                                r = t.material,
                                a = "geometries/Geometry_" + s.id + ".usd";
                            if (!(a in e)) {
                                const t = (function (t) {
                                    return `\ndef "Geometry"\n{\n  ${(function (t) {
                                        const e = t.attributes,
                                            i = e.position.count;
                                        return `\n    def Mesh "Geometry"\n    {\n        int[] faceVertexCounts = [${(function (t) {
                                            const e = null !== t.index ? t.index.array.length : t.attributes.position.count;
                                            return Array(e / 3)
                                                .fill(3)
                                                .join(", ");
                                        })(t)}]\n        int[] faceVertexIndices = [${(function (t) {
                                            if (null !== t.index) return t.index.array.join(", ");
                                            const e = [],
                                                i = t.attributes.position.count;
                                            for (let t = 0; t < i; t++) e.push(t);
                                            return e.join(", ");
                                        })(t)}]\n        normal3f[] normals = [${mA(e.normal, i)}] (\n            interpolation = "vertex"\n        )\n        point3f[] points = [${mA(e.position, i)}]\n        float2[] primvars:st = [${(function (t, e) {
                                            if (void 0 === t) return Array(e).fill("(0, 0)").join(", ");
                                            const i = [],
                                                n = t.array;
                                            for (let t = 0; t < n.length; t += 2) i.push(`(${n[t + 0].toPrecision(7)}, ${1 - n[t + 1].toPrecision(7)})`);
                                            return i.join(", ");
                                        })(e.uv, i)}] (\n            interpolation = "vertex"\n        )\n        uniform token subdivisionScheme = "none"\n    }\n`;
                                    })(t)}\n}\n`;
                                })(s);
                                e[a] = (function (t) {
                                    let e = '#usda 1.0\n(\n    customLayerData = {\n        string creator = "Three.js USDZExporter"\n    }\n    metersPerUnit = 1\n    upAxis = "Y"\n)\n\n';
                                    return (e += t), hA(e);
                                })(t);
                            }
                            r.uuid in n || (n[r.uuid] = r),
                                (i += (function (t, e, i) {
                                    const n = "Object_" + t.id,
                                        s = (function (t) {
                                            const e = t.elements;
                                            return `( ${gA(e, 0)}, ${gA(e, 4)}, ${gA(e, 8)}, ${gA(e, 12)} )`;
                                        })(t.matrixWorld);
                                    return t.matrixWorld.determinant(), `def Xform "${n}" (\n    prepend references = @./geometries/Geometry_${e.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${s}\n    uniform token[] xformOpOrder = ["xformOp:transform"]\n\n    rel material:binding = </Materials/Material_${i.id}>\n}\n\n`;
                                })(t, s, r));
                        }
                    }),
                        (i += (function (t, e) {
                            const i = [];
                            for (const n in t) {
                                const s = t[n];
                                i.push(fA(s, e));
                            }
                            return `def "Materials"\n{\n${i.join("")}\n}\n\n`;
                        })(n, s)),
                        (e["model.usda"] = hA(i)),
                        (i = null);
                    for (const t in s) {
                        const i = s[t],
                            n = t.split("_")[1],
                            r = 1023 === i.format,
                            a = AA(i.image, n),
                            o = await new Promise((t) => a.toBlob(t, r ? "image/png" : "image/jpeg", 1));
                        e[`textures/Texture_${t}.${r ? "png" : "jpg"}`] = new Uint8Array(await o.arrayBuffer());
                    }
                    let r = 0;
                    for (const t in e) {
                        const i = e[t];
                        r += 34 + t.length;
                        const n = 63 & r;
                        if (4 !== n) {
                            const s = new Uint8Array(64 - n);
                            e[t] = [i, { extra: { 12345: s } }];
                        }
                        r = i.length;
                    }
                    return (function (t, e) {
                        e || (e = {});
                        var i = {},
                            n = [];
                        oA(t, "", i, e);
                        var s = 0,
                            r = 0;
                        for (var a in i) {
                            var o = i[a],
                                l = o[0],
                                c = o[1],
                                h = 0 == c.level ? 0 : 8,
                                u = (I = hA(a)).length,
                                d = c.comment,
                                p = d && hA(d),
                                A = p && p.length,
                                g = uA(c.extra);
                            if (u > 65535) throw "filename too long";
                            var m = h ? aA(l, c) : l,
                                f = m.length,
                                v = nA();
                            v.p(l), n.push(sA(c, { size: l.length, crc: v.d(), c: m, f: I, m: p, u: u != a.length || (p && d.length != A), o: s, compression: h })), (s += 30 + u + g + f), (r += 76 + 2 * (u + g) + (A || 0) + f);
                        }
                        for (var y = new Mp(r + 22), x = s, w = r - s, _ = 0; _ < n.length; ++_) {
                            var I = n[_];
                            dA(y, I.o, I, I.f, I.u, I.c.length);
                            var C = 30 + I.f.length + uA(I.extra);
                            y.set(I.c, I.o + C), dA(y, s, I, I.f, I.u, I.c.length, I.o, I.m), (s += 16 + C + (I.m ? I.m.length : 0));
                        }
                        return (
                            (function (t, e, i, n, s) {
                                rA(t, e, 101010256), rA(t, e + 8, i), rA(t, e + 10, i), rA(t, e + 12, n), rA(t, e + 16, s);
                            })(y, s, n.length, w, x),
                            y
                        );
                    })(e, { level: 0 });
                }
            }
            function AA(t, e) {
                if (("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) || ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) || ("undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas) || ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)) {
                    const i = 1024 / Math.max(t.width, t.height),
                        n = document.createElement("canvas");
                    (n.width = t.width * Math.min(1, i)), (n.height = t.height * Math.min(1, i));
                    const s = n.getContext("2d");
                    if ((s.drawImage(t, 0, 0, n.width, n.height), void 0 !== e)) {
                        const t = parseInt(e, 16),
                            i = ((t >> 16) & 255) / 255,
                            r = ((t >> 8) & 255) / 255,
                            a = (255 & t) / 255,
                            o = s.getImageData(0, 0, n.width, n.height),
                            l = o.data;
                        for (let t = 0; t < l.length; t += 4) (l[t + 0] = l[t + 0] * i), (l[t + 1] = l[t + 1] * r), (l[t + 2] = l[t + 2] * a);
                        s.putImageData(o, 0, 0);
                    }
                    return n;
                }
            }
            function gA(t, e) {
                return `(${t[e + 0]}, ${t[e + 1]}, ${t[e + 2]}, ${t[e + 3]})`;
            }
            function mA(t, e) {
                if (void 0 === t) return Array(e).fill("(0, 0, 0)").join(", ");
                const i = [],
                    n = t.array;
                for (let t = 0; t < n.length; t += 3) i.push(`(${n[t + 0].toPrecision(7)}, ${n[t + 1].toPrecision(7)}, ${n[t + 2].toPrecision(7)})`);
                return i.join(", ");
            }
            function fA(t, e) {
                const i = "            ",
                    n = [],
                    s = [];
                function r(i, n, s) {
                    const r = i.id + (s ? "_" + s.getHexString() : ""),
                        a = 1023 === i.format;
                    return (e[r] = i), `\n        def Shader "Transform2d_${n}" (\n            sdrMetadata = {\n                string role = "math"\n            }\n        )\n        {\n            uniform token info:id = "UsdTransform2d"\n            float2 inputs:in.connect = </Materials/Material_${t.id}/uvReader_st.outputs:result>\n            float2 inputs:scale = ${yA(i.repeat)}\n            float2 inputs:translation = ${yA(i.offset)}\n            float2 outputs:result\n        }\n\n        def Shader "Texture_${i.id}_${n}"\n        {\n            uniform token info:id = "UsdUVTexture"\n            asset inputs:file = @textures/Texture_${r}.${a ? "png" : "jpg"}@\n            float2 inputs:st.connect = </Materials/Material_${t.id}/Transform2d_${n}.outputs:result>\n            token inputs:wrapS = "repeat"\n            token inputs:wrapT = "repeat"\n            float outputs:r\n            float outputs:g\n            float outputs:b\n            float3 outputs:rgb\n        }`;
                }
                return (
                    null !== t.map ? (n.push(`${i}color3f inputs:diffuseColor.connect = </Materials/Material_${t.id}/Texture_${t.map.id}_diffuse.outputs:rgb>`), s.push(r(t.map, "diffuse", t.color))) : n.push(`${i}color3f inputs:diffuseColor = ${vA(t.color)}`),
                    null !== t.emissiveMap ? (n.push(`${i}color3f inputs:emissiveColor.connect = </Materials/Material_${t.id}/Texture_${t.emissiveMap.id}_emissive.outputs:rgb>`), s.push(r(t.emissiveMap, "emissive"))) : t.emissive.getHex() > 0 && n.push(`${i}color3f inputs:emissiveColor = ${vA(t.emissive)}`),
                    null !== t.normalMap && (n.push(`${i}normal3f inputs:normal.connect = </Materials/Material_${t.id}/Texture_${t.normalMap.id}_normal.outputs:rgb>`), s.push(r(t.normalMap, "normal"))),
                    null !== t.aoMap && (n.push(`${i}float inputs:occlusion.connect = </Materials/Material_${t.id}/Texture_${t.aoMap.id}_occlusion.outputs:r>`), s.push(r(t.aoMap, "occlusion"))),
                    null !== t.roughnessMap && 1 === t.roughness ? (n.push(`${i}float inputs:roughness.connect = </Materials/Material_${t.id}/Texture_${t.roughnessMap.id}_roughness.outputs:g>`), s.push(r(t.roughnessMap, "roughness"))) : n.push(`${i}float inputs:roughness = ${t.roughness}`),
                    null !== t.metalnessMap && 1 === t.metalness ? (n.push(`${i}float inputs:metallic.connect = </Materials/Material_${t.id}/Texture_${t.metalnessMap.id}_metallic.outputs:b>`), s.push(r(t.metalnessMap, "metallic"))) : n.push(`${i}float inputs:metallic = ${t.metalness}`),
                    n.push(`${i}float inputs:opacity = ${t.opacity}`),
                    t.isMeshPhysicalMaterial && (n.push(`${i}float inputs:clearcoat = ${t.clearcoat}`), n.push(`${i}float inputs:clearcoatRoughness = ${t.clearcoatRoughness}`), n.push(`${i}float inputs:ior = ${t.ior}`)),
                    `\n    def Material "Material_${t.id}"\n    {\n        def Shader "PreviewSurface"\n        {\n            uniform token info:id = "UsdPreviewSurface"\n${n.join("\n")}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n\n        token outputs:surface.connect = </Materials/Material_${t.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = "st"\n\n        def Shader "uvReader_st"\n        {\n            uniform token info:id = "UsdPrimvarReader_float2"\n            token inputs:varname.connect = </Materials/Material_${t.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n\n${s.join("\n")}\n\n    }\n`
                );
            }
            function vA(t) {
                return `(${t.r}, ${t.g}, ${t.b})`;
            }
            function yA(t) {
                return `(${t.x}, ${t.y})`;
                /* @license
                 * Copyright 2019 Google LLC. All Rights Reserved.
                 * Licensed under the Apache License, Version 2.0 (the 'License');
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *     http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an 'AS IS' BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
                /* @license
                 * Copyright 2019 Google LLC. All Rights Reserved.
                 * Licensed under the Apache License, Version 2.0 (the 'License');
                 * you may not use this file except in compliance with the License.
                 * You may obtain a copy of the License at
                 *
                 *     http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an 'AS IS' BASIS,
                 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                 * See the License for the specific language governing permissions and
                 * limitations under the License.
                 */
            }
            var xA = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            let wA = !1,
                _A = !1;
            const IA =
                ((CA = ["quick-look", "scene-viewer", "webxr", "none"]),
                (t) => {
                    try {
                        const e = Wh(t),
                            i = (e.length ? e[0].terms : [])
                                .filter((t) => t && "ident" === t.type)
                                .map((t) => t.value)
                                .filter((t) => CA.indexOf(t) > -1),
                            n = new Set();
                        for (const t of i) n.add(t);
                        return n;
                    } catch (t) {}
                    return new Set();
                });
            var CA;
            const MA = "quick-look",
                EA = "scene-viewer",
                bA = "webxr",
                SA = "none",
                BA = Symbol("arButtonContainer"),
                TA = Symbol("enterARWithWebXR"),
                LA = Symbol("openSceneViewer"),
                DA = Symbol("openIOSARQuickLook"),
                QA = Symbol("canActivateAR"),
                RA = Symbol("arMode"),
                PA = Symbol("arModes"),
                NA = Symbol("arAnchor"),
                FA = Symbol("preload"),
                UA = Symbol("onARButtonContainerClick"),
                kA = Symbol("onARStatus"),
                OA = Symbol("onARTracking"),
                GA = Symbol("onARTap"),
                zA = Symbol("selectARMode"),
                VA = Symbol("triggerLoad");
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var HA, WA, qA;
            const jA = Symbol("evaluate"),
                YA = Symbol("lastValue");
            class JA {
                constructor() {
                    this[HA] = null;
                }
                static evaluatableFor(t, e = $h) {
                    if (t instanceof JA) return t;
                    if ("number" === t.type) return "%" === t.unit ? new ZA(t, e) : t;
                    switch (t.name.value) {
                        case "calc":
                            return new ng(t, e);
                        case "env":
                            return new tg(t);
                    }
                    return $h;
                }
                static evaluate(t) {
                    return t instanceof JA ? t.evaluate() : t;
                }
                static isConstant(t) {
                    return !(t instanceof JA) || t.isConstant;
                }
                static applyIntrinsics(t, e) {
                    const { basis: i, keywords: n } = e,
                        { auto: s } = n;
                    return i.map((e, i) => {
                        const r = null == s[i] ? e : s[i];
                        let a = t[i] ? t[i] : r;
                        if ("ident" === a.type) {
                            const t = a.value;
                            t in n && (a = n[t][i]);
                        }
                        return (null != a && "ident" !== a.type) || (a = r), "%" === a.unit ? Hh((a.number / 100) * e.number, e.unit) : ((a = iu(a, e)), a.unit !== e.unit ? e : a);
                    });
                }
                get isConstant() {
                    return !1;
                }
                evaluate() {
                    return (this.isConstant && null != this[YA]) || (this[YA] = this[jA]()), this[YA];
                }
            }
            HA = YA;
            const XA = Symbol("percentage"),
                KA = Symbol("basis");
            class ZA extends JA {
                constructor(t, e) {
                    super(), (this[XA] = t), (this[KA] = e);
                }
                get isConstant() {
                    return !0;
                }
                [jA]() {
                    return Hh((this[XA].number / 100) * this[KA].number, this[KA].unit);
                }
            }
            const $A = Symbol("identNode");
            class tg extends JA {
                constructor(t) {
                    super(), (this[WA] = null);
                    const e = t.arguments.length ? t.arguments[0].terms[0] : null;
                    null != e && "ident" === e.type && (this[$A] = e);
                }
                get isConstant() {
                    return !1;
                }
                [((WA = $A), jA)]() {
                    return null != this[$A] && "window-scroll-y" === this[$A].value ? { type: "number", number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0, unit: null } : $h;
                }
            }
            const eg = /[\*\/]/,
                ig = Symbol("evalutor");
            class ng extends JA {
                constructor(t, e = $h) {
                    if ((super(), (this[qA] = null), 1 !== t.arguments.length)) return;
                    const i = t.arguments[0].terms.slice(),
                        n = [];
                    for (; i.length; ) {
                        const t = i.shift();
                        if (n.length > 0) {
                            const i = n[n.length - 1];
                            if ("operator" === i.type && eg.test(i.value)) {
                                const i = n.pop(),
                                    s = n.pop();
                                if (null == s) return;
                                n.push(new og(i, JA.evaluatableFor(s, e), JA.evaluatableFor(t, e)));
                                continue;
                            }
                        }
                        n.push("operator" === t.type ? t : JA.evaluatableFor(t, e));
                    }
                    for (; n.length > 2; ) {
                        const [t, i, s] = n.splice(0, 3);
                        if ("operator" !== i.type) return;
                        n.unshift(new og(i, JA.evaluatableFor(t, e), JA.evaluatableFor(s, e)));
                    }
                    1 === n.length && (this[ig] = n[0]);
                }
                get isConstant() {
                    return null == this[ig] || JA.isConstant(this[ig]);
                }
                [((qA = ig), jA)]() {
                    return null != this[ig] ? JA.evaluate(this[ig]) : $h;
                }
            }
            const sg = Symbol("operator"),
                rg = Symbol("left"),
                ag = Symbol("right");
            class og extends JA {
                constructor(t, e, i) {
                    super(), (this[sg] = t), (this[rg] = e), (this[ag] = i);
                }
                get isConstant() {
                    return JA.isConstant(this[rg]) && JA.isConstant(this[ag]);
                }
                [jA]() {
                    const t = iu(JA.evaluate(this[rg])),
                        e = iu(JA.evaluate(this[ag])),
                        { number: i, unit: n } = t,
                        { number: s, unit: r } = e;
                    if (null != r && null != n && r != n) return $h;
                    const a = n || r;
                    let o;
                    switch (this[sg].value) {
                        case "+":
                            o = i + s;
                            break;
                        case "-":
                            o = i - s;
                            break;
                        case "/":
                            o = i / s;
                            break;
                        case "*":
                            o = i * s;
                            break;
                        default:
                            return $h;
                    }
                    return { type: "number", number: o, unit: a };
                }
            }
            const lg = Symbol("evaluatables"),
                cg = Symbol("intrinsics");
            class hg extends JA {
                constructor(t, e) {
                    super(), (this[cg] = e);
                    const i = t[0],
                        n = null != i ? i.terms : [];
                    this[lg] = e.basis.map((t, e) => {
                        const i = n[e];
                        return null == i ? { type: "ident", value: "auto" } : "ident" === i.type ? i : JA.evaluatableFor(i, t);
                    });
                }
                get isConstant() {
                    for (const t of this[lg]) if (!JA.isConstant(t)) return !1;
                    return !0;
                }
                [jA]() {
                    const t = this[lg].map((t) => JA.evaluate(t));
                    return JA.applyIntrinsics(t, this[cg]).map((t) => t.number);
                }
            }
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var ug, dg, pg, Ag;
            const gg = Symbol("instances"),
                mg = Symbol("activateListener"),
                fg = Symbol("deactivateListener"),
                vg = Symbol("notifyInstances"),
                yg = Symbol("notify"),
                xg = Symbol("callback");
            class wg {
                constructor(t) {
                    this[xg] = t;
                }
                static [vg]() {
                    for (const t of wg[gg]) t[yg]();
                }
                static [((ug = gg), mg)]() {
                    window.addEventListener("scroll", this[vg], { passive: !0 });
                }
                static [fg]() {
                    window.removeEventListener("scroll", this[vg]);
                }
                observe() {
                    0 === wg[gg].size && wg[mg](), wg[gg].add(this);
                }
                disconnect() {
                    wg[gg].delete(this), 0 === wg[gg].size && wg[fg]();
                }
                [yg]() {
                    this[xg]();
                }
            }
            wg[ug] = new Set();
            const _g = Symbol("computeStyleCallback"),
                Ig = Symbol("astWalker"),
                Cg = Symbol("dependencies"),
                Mg = Symbol("onScroll");
            class Eg {
                constructor(t) {
                    (this[dg] = {}),
                        (this[pg] = new Zh(["function"])),
                        (this[Ag] = () => {
                            this[_g]({ relatedState: "window-scroll" });
                        }),
                        (this[_g] = t);
                }
                observeEffectsFor(t) {
                    const e = {},
                        i = this[Cg];
                    this[Ig].walk(t, (t) => {
                        const { name: n } = t,
                            s = t.arguments[0].terms[0];
                        if ("env" === n.value && null != s && "ident" === s.type && "window-scroll-y" === s.value)
                            if (null == e["window-scroll"]) {
                                const t = "window-scroll" in i ? i["window-scroll"] : new wg(this[Mg]);
                                t.observe(), delete i["window-scroll"], (e["window-scroll"] = t);
                            }
                    });
                    for (const t in i) i[t].disconnect();
                    this[Cg] = e;
                }
                dispose() {
                    for (const t in this[Cg]) this[Cg][t].disconnect();
                }
            }
            (dg = Cg), (pg = Ig), (Ag = Mg);
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const bg = (t) => {
                    const e = t.observeEffects || !1,
                        i = t.intrinsics instanceof Function ? t.intrinsics : () => t.intrinsics;
                    return (n, s) => {
                        const r = n.updated,
                            a = n.connectedCallback,
                            o = n.disconnectedCallback,
                            l = Symbol(`${s}StyleEffector`),
                            c = Symbol(`${s}StyleEvaluator`),
                            h = Symbol(`${s}UpdateEvaluator`),
                            u = Symbol(`${s}EvaluateAndSync`);
                        Object.defineProperties(n, {
                            [l]: { value: null, writable: !0 },
                            [c]: { value: null, writable: !0 },
                            [h]: {
                                value: function () {
                                    const t = Wh(this[s]);
                                    (this[c] = new hg(t, i(this))), null == this[l] && e && (this[l] = new Eg(() => this[u]())), null != this[l] && this[l].observeEffectsFor(t);
                                },
                            },
                            [u]: {
                                value: function () {
                                    if (null == this[c]) return;
                                    const e = this[c].evaluate();
                                    this[t.updateHandler](e);
                                },
                            },
                            updated: {
                                value: function (t) {
                                    t.has(s) && (this[h](), this[u]()), r.call(this, t);
                                },
                            },
                            connectedCallback: {
                                value: function () {
                                    a.call(this), this.requestUpdate(s, this[s]);
                                },
                            },
                            disconnectedCallback: {
                                value: function () {
                                    o.call(this), null != this[l] && (this[l].dispose(), (this[l] = null));
                                },
                            },
                        });
                    };
                },
                Sg = Object.freeze({ minimumRadius: 0, maximumRadius: 1 / 0, minimumPolarAngle: Math.PI / 8, maximumPolarAngle: Math.PI - Math.PI / 8, minimumAzimuthalAngle: -1 / 0, maximumAzimuthalAngle: 1 / 0, minimumFieldOfView: 10, maximumFieldOfView: 45, interactionPolicy: "always-allow", touchAction: "pan-y" }),
                Bg = /^touch(start|end|move)$/,
                Tg = Math.PI / 8,
                Lg = "user-interaction";
            /* @license
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ class Dg extends nt {
                constructor(t, e) {
                    super(),
                        (this.camera = t),
                        (this.element = e),
                        (this.sensitivity = 1),
                        (this._interactionEnabled = !1),
                        (this._disableZoom = !1),
                        (this.isUserChange = !1),
                        (this.isUserPointing = !1),
                        (this.spherical = new Gl()),
                        (this.goalSpherical = new Gl()),
                        (this.thetaDamper = new Vh()),
                        (this.phiDamper = new Vh()),
                        (this.radiusDamper = new Vh()),
                        (this.logFov = Math.log(Sg.maximumFieldOfView)),
                        (this.goalLogFov = this.logFov),
                        (this.fovDamper = new Vh()),
                        (this.pointerIsDown = !1),
                        (this.lastPointerPosition = { clientX: 0, clientY: 0 }),
                        (this.touchMode = "rotate"),
                        (this.touchDecided = !1),
                        (this.onPointerMove = (t) => {
                            if (this.pointerIsDown && this.canInteract) {
                                if (Bg.test(t.type)) {
                                    const { touches: e } = t;
                                    switch (this.touchMode) {
                                        case "zoom":
                                            if (this.lastTouches.length > 1 && e.length > 1) {
                                                const t = (0.04 * (this.twoTouchDistance(this.lastTouches[0], this.lastTouches[1]) - this.twoTouchDistance(e[0], e[1]))) / 10;
                                                this.userAdjustOrbit(0, 0, t);
                                            }
                                            break;
                                        case "rotate":
                                            const { touchAction: t } = this._options;
                                            if (!this.touchDecided && "none" !== t) {
                                                this.touchDecided = !0;
                                                const { clientX: i, clientY: n } = e[0],
                                                    s = Math.abs(i - this.lastPointerPosition.clientX),
                                                    r = Math.abs(n - this.lastPointerPosition.clientY);
                                                if (("pan-y" === t && r > s) || ("pan-x" === t && s > r)) return void (this.touchMode = "scroll");
                                            }
                                            this.handleSinglePointerMove(e[0]);
                                            break;
                                        case "scroll":
                                            return;
                                    }
                                    this.lastTouches = e;
                                } else this.handleSinglePointerMove(t);
                                t.cancelable && t.preventDefault();
                            }
                        }),
                        (this.onPointerDown = (t) => {
                            if (((this.pointerIsDown = !0), (this.isUserPointing = !1), Bg.test(t.type))) {
                                const { touches: e } = t;
                                switch (((this.touchDecided = !1), e.length)) {
                                    default:
                                    case 1:
                                        (this.touchMode = "rotate"), this.handleSinglePointerDown(e[0]);
                                        break;
                                    case 2:
                                        this.touchMode = this._disableZoom ? "scroll" : "zoom";
                                }
                                this.lastTouches = e;
                            } else this.handleSinglePointerDown(t);
                        }),
                        (this.onPointerUp = (t) => {
                            (this.element.style.cursor = "grab"), (this.pointerIsDown = !1), this.isUserPointing && this.dispatchEvent({ type: "pointer-change-end", pointer: Object.assign({}, this.lastPointerPosition) });
                        }),
                        (this.onWheel = (t) => {
                            if (!this.canInteract) return;
                            const e = (t.deltaY * (1 == t.deltaMode ? 18 : 1) * 0.04) / 30;
                            this.userAdjustOrbit(0, 0, e), t.cancelable && t.preventDefault();
                        }),
                        (this.onKeyDown = (t) => {
                            let e = !1;
                            switch (t.keyCode) {
                                case 33:
                                    (e = !0), this.userAdjustOrbit(0, 0, 0.04);
                                    break;
                                case 34:
                                    (e = !0), this.userAdjustOrbit(0, 0, -0.04);
                                    break;
                                case 38:
                                    (e = !0), this.userAdjustOrbit(0, -Tg, 0);
                                    break;
                                case 40:
                                    (e = !0), this.userAdjustOrbit(0, Tg, 0);
                                    break;
                                case 37:
                                    (e = !0), this.userAdjustOrbit(-Tg, 0, 0);
                                    break;
                                case 39:
                                    (e = !0), this.userAdjustOrbit(Tg, 0, 0);
                            }
                            e && t.cancelable && t.preventDefault();
                        }),
                        (this._options = Object.assign({}, Sg)),
                        this.setOrbit(0, Math.PI / 2, 1),
                        this.setFieldOfView(100),
                        this.jumpToGoal();
                }
                get interactionEnabled() {
                    return this._interactionEnabled;
                }
                enableInteraction() {
                    if (!1 === this._interactionEnabled) {
                        const { element: t } = this;
                        t.addEventListener("mousemove", this.onPointerMove), t.addEventListener("mousedown", this.onPointerDown), this._disableZoom || t.addEventListener("wheel", this.onWheel), t.addEventListener("keydown", this.onKeyDown), t.addEventListener("touchstart", this.onPointerDown, { passive: !0 }), t.addEventListener("touchmove", this.onPointerMove), self.addEventListener("mouseup", this.onPointerUp), self.addEventListener("touchend", this.onPointerUp), (this.element.style.cursor = "grab"), (this._interactionEnabled = !0);
                    }
                }
                disableInteraction() {
                    if (!0 === this._interactionEnabled) {
                        const { element: t } = this;
                        t.removeEventListener("mousemove", this.onPointerMove), t.removeEventListener("mousedown", this.onPointerDown), this._disableZoom || t.removeEventListener("wheel", this.onWheel), t.removeEventListener("keydown", this.onKeyDown), t.removeEventListener("touchstart", this.onPointerDown), t.removeEventListener("touchmove", this.onPointerMove), self.removeEventListener("mouseup", this.onPointerUp), self.removeEventListener("touchend", this.onPointerUp), (t.style.cursor = ""), (this._interactionEnabled = !1);
                    }
                }
                get options() {
                    return this._options;
                }
                set disableZoom(t) {
                    this._disableZoom != t && ((this._disableZoom = t), !0 === t ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel));
                }
                getCameraSpherical(t = new Gl()) {
                    return t.copy(this.spherical);
                }
                getFieldOfView() {
                    return this.camera.fov;
                }
                applyOptions(t) {
                    Object.assign(this._options, t), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov));
                }
                updateNearFar(t, e) {
                    (this.camera.near = Math.max(t, e / 1e3)), (this.camera.far = e), this.camera.updateProjectionMatrix();
                }
                updateAspect(t) {
                    (this.camera.aspect = t), this.camera.updateProjectionMatrix();
                }
                setOrbit(t = this.goalSpherical.theta, e = this.goalSpherical.phi, i = this.goalSpherical.radius) {
                    const { minimumAzimuthalAngle: n, maximumAzimuthalAngle: s, minimumPolarAngle: r, maximumPolarAngle: a, minimumRadius: o, maximumRadius: l } = this._options,
                        { theta: c, phi: h, radius: u } = this.goalSpherical,
                        d = Oh(t, n, s);
                    isFinite(n) || isFinite(s) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - d) + d);
                    const p = Oh(e, r, a),
                        A = Oh(i, o, l);
                    return (d !== c || p !== h || A !== u) && ((this.goalSpherical.theta = d), (this.goalSpherical.phi = p), (this.goalSpherical.radius = A), this.goalSpherical.makeSafe(), (this.isUserChange = !1), !0);
                }
                setRadius(t) {
                    (this.goalSpherical.radius = t), this.setOrbit();
                }
                setFieldOfView(t) {
                    const { minimumFieldOfView: e, maximumFieldOfView: i } = this._options;
                    (t = Oh(t, e, i)), (this.goalLogFov = Math.log(t));
                }
                setDamperDecayTime(t) {
                    this.thetaDamper.setDecayTime(t), this.phiDamper.setDecayTime(t), this.radiusDamper.setDecayTime(t), this.fovDamper.setDecayTime(t);
                }
                adjustOrbit(t, e, i) {
                    const { theta: n, phi: s, radius: r } = this.goalSpherical,
                        { minimumRadius: a, maximumRadius: o, minimumFieldOfView: l, maximumFieldOfView: c } = this._options,
                        h = this.spherical.theta - n,
                        u = Math.PI - 0.001,
                        d = n - Oh(t, -u - h, u - h),
                        p = s - e,
                        A = 0 === i ? 0 : ((i > 0 ? o : a) - r) / (Math.log(i > 0 ? c : l) - this.goalLogFov),
                        g = r + i * Math.min(isFinite(A) ? A : 1 / 0, o - a);
                    if ((this.setOrbit(d, p, g), 0 !== i)) {
                        const t = this.goalLogFov + i;
                        this.setFieldOfView(Math.exp(t));
                    }
                }
                jumpToGoal() {
                    this.update(0, 1e4);
                }
                update(t, e) {
                    if (this.isStationary()) return;
                    const { maximumPolarAngle: i, maximumRadius: n } = this._options,
                        s = this.spherical.theta - this.goalSpherical.theta;
                    Math.abs(s) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle) && (this.spherical.theta -= 2 * Math.sign(s) * Math.PI), (this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, e, Math.PI)), (this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, e, i)), (this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, e, n)), (this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, e, 1)), this.moveCamera();
                }
                isStationary() {
                    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;
                }
                moveCamera() {
                    this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Ae(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && ((this.camera.fov = Math.exp(this.logFov)), this.camera.updateProjectionMatrix());
                    const t = this.isUserChange ? Lg : "none";
                    this.dispatchEvent({ type: "change", source: t });
                }
                get canInteract() {
                    return "allow-when-focused" == this._options.interactionPolicy ? this.element.getRootNode().activeElement === this.element : "always-allow" === this._options.interactionPolicy;
                }
                userAdjustOrbit(t, e, i) {
                    this.adjustOrbit(t * this.sensitivity, e * this.sensitivity, i), (this.isUserChange = !0), this.dispatchEvent({ type: "change", source: Lg });
                }
                wrapAngle(t) {
                    const e = (t + Math.PI) / (2 * Math.PI);
                    return 2 * (e - Math.floor(e)) * Math.PI - Math.PI;
                }
                pixelLengthToSphericalAngle(t) {
                    return (2 * Math.PI * t) / this.element.clientHeight;
                }
                twoTouchDistance(t, e) {
                    const { clientX: i, clientY: n } = t,
                        { clientX: s, clientY: r } = e,
                        a = s - i,
                        o = r - n;
                    return Math.sqrt(a * a + o * o);
                }
                handleSinglePointerMove(t) {
                    const { clientX: e, clientY: i } = t,
                        n = this.pixelLengthToSphericalAngle(e - this.lastPointerPosition.clientX),
                        s = this.pixelLengthToSphericalAngle(i - this.lastPointerPosition.clientY);
                    (this.lastPointerPosition.clientX = e), (this.lastPointerPosition.clientY = i), !1 === this.isUserPointing && ((this.isUserPointing = !0), this.dispatchEvent({ type: "pointer-change-start", pointer: Object.assign({}, t) })), this.userAdjustOrbit(n, s, 0);
                }
                handleSinglePointerDown(t) {
                    (this.lastPointerPosition.clientX = t.clientX), (this.lastPointerPosition.clientY = t.clientY), (this.element.style.cursor = "grabbing");
                    /* @license
                     * Copyright 2019 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            const Qg = (t) => (t < 0.5 ? 2 * t * t : (4 - 2 * t) * t - 1),
                Rg =
                    (t, e, i = Qg) =>
                    (n) =>
                        t + (e - t) * i(n),
                Pg = (t, e) => {
                    const i = [],
                        n = [];
                    let s = t;
                    for (let t = 0; t < e.length; ++t) {
                        const r = e[t],
                            { value: a, frames: o } = r,
                            l = r.ease || Qg,
                            c = Rg(s, a, l);
                        i.push(c), n.push(o), (s = a);
                    }
                    return ((t, e) => {
                        const i = e.reduce((t, e) => t + e, 0),
                            n = e.map((t) => t / i);
                        return (e) => {
                            let i = 0,
                                s = 1 / 0,
                                r = () => 0;
                            for (let a = 0; a < n.length && ((s = n[a]), (r = t[a]), !(e <= i + s)); ++a) i += s;
                            return r((e - i) / s);
                        };
                    })(i, n);
                };
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var Ng = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            const Fg = Pg(0, [
                    { frames: 5, value: -1 },
                    { frames: 1, value: -1 },
                    { frames: 8, value: 1 },
                    { frames: 1, value: 1 },
                    { frames: 5, value: 0 },
                    { frames: 18, value: 0 },
                ]),
                Ug = Pg(0, [
                    { frames: 1, value: 1 },
                    { frames: 5, value: 1 },
                    { frames: 1, value: 0 },
                    { frames: 6, value: 0 },
                ]),
                kg = 1.1 * ou,
                Og = ["front", "right", "back", "left"],
                Gg = ["upper-", "", "lower-"],
                zg = "auto",
                Vg = "when-focused",
                Hg = "wiggle",
                Wg = (t) => ({ basis: [Hh((t[fm] * Math.PI) / 180, "rad")], keywords: { auto: [null] } }),
                qg = { basis: [tu(Hh(25, "deg"))], keywords: { auto: [null] } },
                jg = (t) => {
                    const e = t[$d];
                    return { basis: [tu(Hh(45, "deg"))], keywords: { auto: [Hh(e.framedFieldOfView, "deg")] } };
                },
                Yg = (() => {
                    const t = Wh("0deg 75deg 105%")[0].terms,
                        e = iu(t[0]),
                        i = iu(t[1]);
                    return (t) => {
                        const n = t[$d].idealCameraDistance;
                        return { basis: [e, i, Hh(n, "m")], keywords: { auto: [null, null, Hh(105, "%")] } };
                    };
                })(),
                Jg = (t) => {
                    const e = kg * t[$d].idealCameraDistance;
                    return { basis: [Hh(-1 / 0, "rad"), Hh(Math.PI / 8, "rad"), Hh(e, "m")], keywords: { auto: [null, null, null] } };
                },
                Xg = (t) => {
                    const e = Yg(t),
                        i = new hg([], e).evaluate()[2];
                    return { basis: [Hh(1 / 0, "rad"), Hh(Math.PI - Math.PI / 8, "rad"), Hh(i, "m")], keywords: { auto: [null, null, null] } };
                },
                Kg = (t) => {
                    const e = t[$d].boundingBox.getCenter(new bt());
                    return { basis: [Hh(e.x, "m"), Hh(e.y, "m"), Hh(e.z, "m")], keywords: { auto: [null, null, null] } };
                },
                Zg = Math.PI / 2,
                $g = Math.PI / 3,
                tm = Zg / 2,
                em = 2 * Math.PI,
                im = Symbol("controls"),
                nm = Symbol("promptElement"),
                sm = Symbol("promptAnimatedContainer"),
                rm = Symbol("deferInteractionPrompt"),
                am = Symbol("updateAria"),
                om = Symbol("updateCameraForRadius"),
                lm = Symbol("onBlur"),
                cm = Symbol("onFocus"),
                hm = Symbol("onChange"),
                um = Symbol("onPointerChange"),
                dm = Symbol("waitingToPromptUser"),
                pm = Symbol("userHasInteracted"),
                Am = Symbol("promptElementVisibleTime"),
                gm = Symbol("lastPromptOffset"),
                mm = Symbol("focusedTime"),
                fm = Symbol("zoomAdjustedFieldOfView"),
                vm = Symbol("lastSpherical"),
                ym = Symbol("jumpCamera"),
                xm = Symbol("initialized"),
                wm = Symbol("maintainThetaPhi"),
                _m = Symbol("syncCameraOrbit"),
                Im = Symbol("syncFieldOfView"),
                Cm = Symbol("syncCameraTarget"),
                Mm = Symbol("syncMinCameraOrbit"),
                Em = Symbol("syncMaxCameraOrbit"),
                bm = Symbol("syncMinFieldOfView"),
                Sm = Symbol("syncMaxFieldOfView");
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var Bm, Tm;
            const Lm = Symbol("modelViewerStatusInstance"),
                Dm = Symbol("updateStatus");
            (Bm = Lm), (Tm = Dm);
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var Qm = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            const Rm = "auto",
                Pm = "manual",
                Nm = new (class extends nt {
                    constructor() {
                        super(), (this[Bm] = null), (this.registeredInstanceStatuses = new Map()), (this.loadingPromises = []), (this.statusElement = document.createElement("p")), (this.statusUpdateInProgress = !1), (this[Tm] = kh(() => this.updateStatus(), 100));
                        const { statusElement: t } = this,
                            { style: e } = t;
                        t.setAttribute("role", "status"), t.classList.add("screen-reader-only"), (e.top = e.left = "0"), (e.pointerEvents = "none");
                    }
                    registerInstance(t) {
                        if (this.registeredInstanceStatuses.has(t)) return;
                        let e = () => {};
                        const i = !1 === t.loaded && !!t.src,
                            n = new Promise((n) => {
                                if (!i) return void n();
                                const s = () => {
                                    n(), t.removeEventListener("load", s), t.removeEventListener("error", s);
                                };
                                t.addEventListener("load", s), t.addEventListener("error", s), (e = s);
                            });
                        this.registeredInstanceStatuses.set(t, { onUnregistered: e }), this.loadingPromises.push(n), null == this.modelViewerStatusInstance && (this.modelViewerStatusInstance = t);
                    }
                    unregisterInstance(t) {
                        if (!this.registeredInstanceStatuses.has(t)) return;
                        const e = this.registeredInstanceStatuses,
                            i = e.get(t);
                        e.delete(t),
                            i.onUnregistered(),
                            this.modelViewerStatusInstance === t &&
                                (this.modelViewerStatusInstance =
                                    e.size > 0
                                        ? ((t) => {
                                              if (null != t.keys) return t.keys().next().value || null;
                                              let e = null;
                                              try {
                                                  t.forEach((t, i, n) => {
                                                      throw ((e = i), new Error());
                                                  });
                                              } catch (t) {}
                                              return e;
                                          })(e)
                                        : null);
                    }
                    get modelViewerStatusInstance() {
                        return this[Lm];
                    }
                    set modelViewerStatusInstance(t) {
                        if (this[Lm] === t) return;
                        const { statusElement: e } = this;
                        null != t && null != t.shadowRoot ? t.shadowRoot.appendChild(e) : null != e.parentNode && e.parentNode.removeChild(e), (this[Lm] = t), this[Dm]();
                    }
                    async updateStatus() {
                        if (!this.statusUpdateInProgress && 0 !== this.loadingPromises.length) {
                            for (this.statusElement.textContent = "This page includes one or more 3D models that are loading", this.statusUpdateInProgress = !0, this.dispatchEvent({ type: "initial-status-announced" }); this.loadingPromises.length; ) {
                                const { loadingPromises: t } = this;
                                (this.loadingPromises = []), await Promise.all(t);
                            }
                            (this.statusElement.textContent = "All 3D models in the page have loaded"), (this.statusUpdateInProgress = !1), this.dispatchEvent({ type: "finished-loading-announced" });
                        }
                    }
                })(),
                Fm = Symbol("defaultProgressBarElement"),
                Um = Symbol("defaultProgressMaskElement"),
                km = Symbol("posterContainerElement"),
                Om = Symbol("defaultPosterElement"),
                Gm = Symbol("posterDismissalSource"),
                zm = Symbol("hidePoster"),
                Vm = Symbol("modelIsRevealed"),
                Hm = Symbol("updateProgressBar"),
                Wm = Symbol("lastReportedProgress"),
                qm = Symbol("transitioned"),
                jm = Symbol("ariaLabelCallToAction"),
                Ym = Symbol("onClick"),
                Jm = Symbol("onKeydown"),
                Xm = Symbol("onProgress");
            class Km {
                constructor() {
                    (this.pluginCallbacks = []),
                        this.register(function (t) {
                            return new lf(t);
                        }),
                        this.register(function (t) {
                            return new cf(t);
                        }),
                        this.register(function (t) {
                            return new hf(t);
                        }),
                        this.register(function (t) {
                            return new uf(t);
                        }),
                        this.register(function (t) {
                            return new df(t);
                        });
                }
                register(t) {
                    return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this;
                }
                unregister(t) {
                    return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this;
                }
                parse(t, e, i) {
                    const n = new of(),
                        s = [];
                    for (let t = 0, e = this.pluginCallbacks.length; t < e; t++) s.push(this.pluginCallbacks[t](n));
                    n.setPlugins(s), n.write(t, e, i);
                }
            }
            const Zm = 5121,
                $m = 5123,
                tf = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987, 1001: 33071, 1e3: 10497, 1002: 33648 },
                ef = { scale: "scale", position: "translation", quaternion: "rotation", morphTargetInfluences: "weights" };
            function nf(t, e) {
                return (
                    t.length === e.length &&
                    t.every(function (t, i) {
                        return t === e[i];
                    })
                );
            }
            function sf(t) {
                return 4 * Math.ceil(t / 4);
            }
            function rf(t, e = 0) {
                const i = sf(t.byteLength);
                if (i !== t.byteLength) {
                    const n = new Uint8Array(i);
                    if ((n.set(new Uint8Array(t)), 0 !== e)) for (let s = t.byteLength; s < i; s++) n[s] = e;
                    return n.buffer;
                }
                return t;
            }
            let af = null;
            class of {
                constructor() {
                    (this.plugins = []), (this.options = {}), (this.pending = []), (this.buffers = []), (this.byteOffset = 0), (this.buffers = []), (this.nodeMap = new Map()), (this.skins = []), (this.extensionsUsed = {}), (this.uids = new Map()), (this.uid = 0), (this.json = { asset: { version: "2.0", generator: "THREE.GLTFExporter" } }), (this.cache = { meshes: new Map(), attributes: new Map(), attributesNormalized: new Map(), materials: new Map(), textures: new Map(), images: new Map() });
                }
                setPlugins(t) {
                    this.plugins = t;
                }
                write(t, e, i) {
                    (this.options = Object.assign({}, { binary: !1, trs: !1, onlyVisible: !0, truncateDrawRange: !0, embedImages: !0, maxTextureSize: 1 / 0, animations: [], includeCustomExtensions: !1 }, i)), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(t);
                    const n = this;
                    Promise.all(this.pending).then(function () {
                        const t = n.buffers,
                            i = n.json,
                            s = n.options,
                            r = n.extensionsUsed,
                            a = new Blob(t, { type: "application/octet-stream" }),
                            o = Object.keys(r);
                        if ((o.length > 0 && (i.extensionsUsed = o), i.buffers && i.buffers.length > 0 && (i.buffers[0].byteLength = a.size), !0 === s.binary)) {
                            const t = new window.FileReader();
                            t.readAsArrayBuffer(a),
                                (t.onloadend = function () {
                                    const n = rf(t.result),
                                        s = new DataView(new ArrayBuffer(8));
                                    s.setUint32(0, n.byteLength, !0), s.setUint32(4, 5130562, !0);
                                    const r = rf(
                                            (function (t) {
                                                if (void 0 !== window.TextEncoder) return new TextEncoder().encode(t).buffer;
                                                const e = new Uint8Array(new ArrayBuffer(t.length));
                                                for (let i = 0, n = t.length; i < n; i++) {
                                                    const n = t.charCodeAt(i);
                                                    e[i] = n > 255 ? 32 : n;
                                                }
                                                return e.buffer;
                                            })(JSON.stringify(i)),
                                            32,
                                        ),
                                        a = new DataView(new ArrayBuffer(8));
                                    a.setUint32(0, r.byteLength, !0), a.setUint32(4, 1313821514, !0);
                                    const o = new ArrayBuffer(12),
                                        l = new DataView(o);
                                    l.setUint32(0, 1179937895, !0), l.setUint32(4, 2, !0);
                                    const c = 12 + a.byteLength + r.byteLength + s.byteLength + n.byteLength;
                                    l.setUint32(8, c, !0);
                                    const h = new Blob([o, a, r, s, n], { type: "application/octet-stream" }),
                                        u = new window.FileReader();
                                    u.readAsArrayBuffer(h),
                                        (u.onloadend = function () {
                                            e(u.result);
                                        });
                                });
                        } else if (i.buffers && i.buffers.length > 0) {
                            const t = new window.FileReader();
                            t.readAsDataURL(a),
                                (t.onloadend = function () {
                                    const n = t.result;
                                    (i.buffers[0].uri = n), e(i);
                                });
                        } else e(i);
                    });
                }
                serializeUserData(t, e) {
                    if (0 === Object.keys(t.userData).length) return;
                    const i = this.options,
                        n = this.extensionsUsed;
                    try {
                        const s = JSON.parse(JSON.stringify(t.userData));
                        if (i.includeCustomExtensions && s.gltfExtensions) {
                            void 0 === e.extensions && (e.extensions = {});
                            for (const t in s.gltfExtensions) (e.extensions[t] = s.gltfExtensions[t]), (n[t] = !0);
                            delete s.gltfExtensions;
                        }
                        Object.keys(s).length > 0 && (e.extras = s);
                    } catch (e) {}
                }
                getUID(t) {
                    return this.uids.has(t) || this.uids.set(t, this.uid++), this.uids.get(t);
                }
                isNormalizedNormalAttribute(t) {
                    if (this.cache.attributesNormalized.has(t)) return !1;
                    const e = new bt();
                    for (let i = 0, n = t.count; i < n; i++) if (Math.abs(e.fromBufferAttribute(t, i).length() - 1) > 5e-4) return !1;
                    return !0;
                }
                createNormalizedNormalAttribute(t) {
                    const e = this.cache;
                    if (e.attributesNormalized.has(t)) return e.attributesNormalized.get(t);
                    const i = t.clone(),
                        n = new bt();
                    for (let t = 0, e = i.count; t < e; t++) n.fromBufferAttribute(i, t), 0 === n.x && 0 === n.y && 0 === n.z ? n.setX(1) : n.normalize(), i.setXYZ(t, n.x, n.y, n.z);
                    return e.attributesNormalized.set(t, i), i;
                }
                applyTextureTransform(t, e) {
                    let i = !1;
                    const n = {};
                    (0 === e.offset.x && 0 === e.offset.y) || ((n.offset = e.offset.toArray()), (i = !0)), 0 !== e.rotation && ((n.rotation = e.rotation), (i = !0)), (1 === e.repeat.x && 1 === e.repeat.y) || ((n.scale = e.repeat.toArray()), (i = !0)), i && ((t.extensions = t.extensions || {}), (t.extensions.KHR_texture_transform = n), (this.extensionsUsed.KHR_texture_transform = !0));
                }
                processBuffer(t) {
                    const e = this.json,
                        i = this.buffers;
                    return e.buffers || (e.buffers = [{ byteLength: 0 }]), i.push(t), 0;
                }
                processBufferView(t, e, i, n, s) {
                    const r = this.json;
                    let a;
                    r.bufferViews || (r.bufferViews = []), (a = e === Zm ? 1 : e === $m ? 2 : 4);
                    const o = sf(n * t.itemSize * a),
                        l = new DataView(new ArrayBuffer(o));
                    let c = 0;
                    for (let s = i; s < i + n; s++)
                        for (let i = 0; i < t.itemSize; i++) {
                            let n;
                            t.itemSize > 4 ? (n = t.array[s * t.itemSize + i]) : 0 === i ? (n = t.getX(s)) : 1 === i ? (n = t.getY(s)) : 2 === i ? (n = t.getZ(s)) : 3 === i && (n = t.getW(s)), 5126 === e ? l.setFloat32(c, n, !0) : 5125 === e ? l.setUint32(c, n, !0) : e === $m ? l.setUint16(c, n, !0) : e === Zm && l.setUint8(c, n), (c += a);
                        }
                    const h = { buffer: this.processBuffer(l.buffer), byteOffset: this.byteOffset, byteLength: o };
                    return void 0 !== s && (h.target = s), 34962 === s && (h.byteStride = t.itemSize * a), (this.byteOffset += o), r.bufferViews.push(h), { id: r.bufferViews.length - 1, byteLength: 0 };
                }
                processBufferViewImage(t) {
                    const e = this,
                        i = e.json;
                    return (
                        i.bufferViews || (i.bufferViews = []),
                        new Promise(function (n) {
                            const s = new window.FileReader();
                            s.readAsArrayBuffer(t),
                                (s.onloadend = function () {
                                    const t = rf(s.result),
                                        r = { buffer: e.processBuffer(t), byteOffset: e.byteOffset, byteLength: t.byteLength };
                                    (e.byteOffset += t.byteLength), n(i.bufferViews.push(r) - 1);
                                });
                        })
                    );
                }
                processAccessor(t, e, i, n) {
                    const s = this.options,
                        r = this.json;
                    let a;
                    if (t.array.constructor === Float32Array) a = 5126;
                    else if (t.array.constructor === Uint32Array) a = 5125;
                    else if (t.array.constructor === Uint16Array) a = $m;
                    else {
                        if (t.array.constructor !== Uint8Array) throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");
                        a = Zm;
                    }
                    if ((void 0 === i && (i = 0), void 0 === n && (n = t.count), s.truncateDrawRange && void 0 !== e && null === e.index)) {
                        const s = i + n,
                            r = e.drawRange.count === 1 / 0 ? t.count : e.drawRange.start + e.drawRange.count;
                        (i = Math.max(i, e.drawRange.start)), (n = Math.min(s, r) - i) < 0 && (n = 0);
                    }
                    if (0 === n) return null;
                    const o = (function (t, e, i) {
                        const n = { min: new Array(t.itemSize).fill(Number.POSITIVE_INFINITY), max: new Array(t.itemSize).fill(Number.NEGATIVE_INFINITY) };
                        for (let s = e; s < e + i; s++)
                            for (let e = 0; e < t.itemSize; e++) {
                                let i;
                                t.itemSize > 4 ? (i = t.array[s * t.itemSize + e]) : 0 === e ? (i = t.getX(s)) : 1 === e ? (i = t.getY(s)) : 2 === e ? (i = t.getZ(s)) : 3 === e && (i = t.getW(s)), (n.min[e] = Math.min(n.min[e], i)), (n.max[e] = Math.max(n.max[e], i));
                            }
                        return n;
                    })(t, i, n);
                    let l;
                    void 0 !== e && (l = t === e.index ? 34963 : 34962);
                    const c = this.processBufferView(t, a, i, n, l),
                        h = { bufferView: c.id, byteOffset: c.byteOffset, componentType: a, count: n, max: o.max, min: o.min, type: { 1: "SCALAR", 2: "VEC2", 3: "VEC3", 4: "VEC4", 16: "MAT4" }[t.itemSize] };
                    return !0 === t.normalized && (h.normalized = !0), r.accessors || (r.accessors = []), r.accessors.push(h) - 1;
                }
                processImage(t, e, i) {
                    const n = this,
                        s = n.cache,
                        r = n.json,
                        a = n.options,
                        o = n.pending;
                    s.images.has(t) || s.images.set(t, {});
                    const l = s.images.get(t),
                        c = 1023 === e ? "image/png" : "image/jpeg",
                        h = c + ":flipY/" + i.toString();
                    if (void 0 !== l[h]) return l[h];
                    r.images || (r.images = []);
                    const u = { mimeType: c };
                    if (a.embedImages) {
                        const s = (af = af || document.createElement("canvas"));
                        (s.width = Math.min(t.width, a.maxTextureSize)), (s.height = Math.min(t.height, a.maxTextureSize));
                        const r = s.getContext("2d");
                        if ((!0 === i && (r.translate(0, s.height), r.scale(1, -1)), ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement) || ("undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement) || ("undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas) || ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap))) r.drawImage(t, 0, 0, s.width, s.height);
                        else {
                            t.width > a.maxTextureSize || (t.height, a.maxTextureSize);
                            const i = new Uint8ClampedArray(t.height * t.width * 4);
                            if (1023 === e) for (let e = 0; e < i.length; e += 4) (i[e + 0] = t.data[e + 0]), (i[e + 1] = t.data[e + 1]), (i[e + 2] = t.data[e + 2]), (i[e + 3] = t.data[e + 3]);
                            else for (let e = 0, n = 0; e < i.length; e += 4, n += 3) (i[e + 0] = t.data[n + 0]), (i[e + 1] = t.data[n + 1]), (i[e + 2] = t.data[n + 2]), (i[e + 3] = 255);
                            r.putImageData(new ImageData(i, t.width, t.height), 0, 0);
                        }
                        !0 === a.binary
                            ? o.push(
                                  new Promise(function (t) {
                                      s.toBlob(function (e) {
                                          n.processBufferViewImage(e).then(function (e) {
                                              (u.bufferView = e), t();
                                          });
                                      }, c);
                                  }),
                              )
                            : (u.uri = s.toDataURL(c));
                    } else u.uri = t.src;
                    const d = r.images.push(u) - 1;
                    return (l[h] = d), d;
                }
                processSampler(t) {
                    const e = this.json;
                    e.samplers || (e.samplers = []);
                    const i = { magFilter: tf[t.magFilter], minFilter: tf[t.minFilter], wrapS: tf[t.wrapS], wrapT: tf[t.wrapT] };
                    return e.samplers.push(i) - 1;
                }
                processTexture(t) {
                    const e = this.cache,
                        i = this.json;
                    if (e.textures.has(t)) return e.textures.get(t);
                    i.textures || (i.textures = []);
                    const n = { sampler: this.processSampler(t), source: this.processImage(t.image, t.format, t.flipY) };
                    t.name && (n.name = t.name),
                        this._invokeAll(function (e) {
                            e.writeTexture && e.writeTexture(t, n);
                        });
                    const s = i.textures.push(n) - 1;
                    return e.textures.set(t, s), s;
                }
                processMaterial(t) {
                    const e = this.cache,
                        i = this.json;
                    if (e.materials.has(t)) return e.materials.get(t);
                    if (t.isShaderMaterial) return null;
                    i.materials || (i.materials = []);
                    const n = { pbrMetallicRoughness: {} };
                    !0 !== t.isMeshStandardMaterial && t.isMeshBasicMaterial;
                    const s = t.color.toArray().concat([t.opacity]);
                    if ((nf(s, [1, 1, 1, 1]) || (n.pbrMetallicRoughness.baseColorFactor = s), t.isMeshStandardMaterial ? ((n.pbrMetallicRoughness.metallicFactor = t.metalness), (n.pbrMetallicRoughness.roughnessFactor = t.roughness)) : ((n.pbrMetallicRoughness.metallicFactor = 0.5), (n.pbrMetallicRoughness.roughnessFactor = 0.5)), (t.metalnessMap || t.roughnessMap) && t.metalnessMap === t.roughnessMap)) {
                        const e = { index: this.processTexture(t.metalnessMap) };
                        this.applyTextureTransform(e, t.metalnessMap), (n.pbrMetallicRoughness.metallicRoughnessTexture = e);
                    }
                    if (t.map) {
                        const e = { index: this.processTexture(t.map) };
                        this.applyTextureTransform(e, t.map), (n.pbrMetallicRoughness.baseColorTexture = e);
                    }
                    if (t.emissive) {
                        const e = t.emissive.clone().multiplyScalar(t.emissiveIntensity),
                            i = Math.max(e.r, e.g, e.b);
                        if ((i > 1 && e.multiplyScalar(1 / i), i > 0 && (n.emissiveFactor = e.toArray()), t.emissiveMap)) {
                            const e = { index: this.processTexture(t.emissiveMap) };
                            this.applyTextureTransform(e, t.emissiveMap), (n.emissiveTexture = e);
                        }
                    }
                    if (t.normalMap) {
                        const e = { index: this.processTexture(t.normalMap) };
                        t.normalScale && 1 !== t.normalScale.x && (e.scale = t.normalScale.x), this.applyTextureTransform(e, t.normalMap), (n.normalTexture = e);
                    }
                    if (t.aoMap) {
                        const e = { index: this.processTexture(t.aoMap), texCoord: 1 };
                        1 !== t.aoMapIntensity && (e.strength = t.aoMapIntensity), this.applyTextureTransform(e, t.aoMap), (n.occlusionTexture = e);
                    }
                    t.transparent ? (n.alphaMode = "BLEND") : t.alphaTest > 0 && ((n.alphaMode = "MASK"), (n.alphaCutoff = t.alphaTest)),
                        2 === t.side && (n.doubleSided = !0),
                        "" !== t.name && (n.name = t.name),
                        this.serializeUserData(t, n),
                        this._invokeAll(function (e) {
                            e.writeMaterial && e.writeMaterial(t, n);
                        });
                    const r = i.materials.push(n) - 1;
                    return e.materials.set(t, r), r;
                }
                processMesh(t) {
                    const e = this.cache,
                        i = this.json,
                        n = [t.geometry.uuid];
                    if (Array.isArray(t.material)) for (let e = 0, i = t.material.length; e < i; e++) n.push(t.material[e].uuid);
                    else n.push(t.material.uuid);
                    const s = n.join(":");
                    if (e.meshes.has(s)) return e.meshes.get(s);
                    const r = t.geometry;
                    let a;
                    if (((a = t.isLineSegments ? 1 : t.isLineLoop ? 2 : t.isLine ? 3 : t.isPoints ? 0 : t.material.wireframe ? 1 : 4), !0 !== r.isBufferGeometry)) throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");
                    const o = {},
                        l = {},
                        c = [],
                        h = [],
                        u = { uv: "TEXCOORD_0", uv2: "TEXCOORD_1", color: "COLOR_0", skinWeight: "WEIGHTS_0", skinIndex: "JOINTS_0" },
                        d = r.getAttribute("normal");
                    void 0 === d || this.isNormalizedNormalAttribute(d) || r.setAttribute("normal", this.createNormalizedNormalAttribute(d));
                    let p = null;
                    for (let t in r.attributes) {
                        if ("morph" === t.substr(0, 5)) continue;
                        const i = r.attributes[t];
                        if (((t = u[t] || t.toUpperCase()), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(t) || (t = "_" + t), e.attributes.has(this.getUID(i)))) {
                            l[t] = e.attributes.get(this.getUID(i));
                            continue;
                        }
                        p = null;
                        const n = i.array;
                        "JOINTS_0" !== t || n instanceof Uint16Array || n instanceof Uint8Array || (p = new $e(new Uint16Array(n), i.itemSize, i.normalized));
                        const s = this.processAccessor(p || i, r);
                        null !== s && ((l[t] = s), e.attributes.set(this.getUID(i), s));
                    }
                    if ((void 0 !== d && r.setAttribute("normal", d), 0 === Object.keys(l).length)) return null;
                    if (void 0 !== t.morphTargetInfluences && t.morphTargetInfluences.length > 0) {
                        const i = [],
                            n = [],
                            s = {};
                        if (void 0 !== t.morphTargetDictionary) for (const e in t.morphTargetDictionary) s[t.morphTargetDictionary[e]] = e;
                        for (let a = 0; a < t.morphTargetInfluences.length; ++a) {
                            const o = {};
                            let l = !1;
                            for (const t in r.morphAttributes) {
                                if ("position" !== t && "normal" !== t) {
                                    l || (l = !0);
                                    continue;
                                }
                                const i = r.morphAttributes[t][a],
                                    n = t.toUpperCase(),
                                    s = r.attributes[t];
                                if (e.attributes.has(this.getUID(i))) {
                                    o[n] = e.attributes.get(this.getUID(i));
                                    continue;
                                }
                                const c = i.clone();
                                if (!r.morphTargetsRelative) for (let t = 0, e = i.count; t < e; t++) c.setXYZ(t, i.getX(t) - s.getX(t), i.getY(t) - s.getY(t), i.getZ(t) - s.getZ(t));
                                (o[n] = this.processAccessor(c, r)), e.attributes.set(this.getUID(s), o[n]);
                            }
                            h.push(o), i.push(t.morphTargetInfluences[a]), void 0 !== t.morphTargetDictionary && n.push(s[a]);
                        }
                        (o.weights = i), n.length > 0 && ((o.extras = {}), (o.extras.targetNames = n));
                    }
                    const A = Array.isArray(t.material);
                    if (A && 0 === r.groups.length) return null;
                    const g = A ? t.material : [t.material],
                        m = A ? r.groups : [{ materialIndex: 0, start: void 0, count: void 0 }];
                    for (let t = 0, i = m.length; t < i; t++) {
                        const i = { mode: a, attributes: l };
                        if ((this.serializeUserData(r, i), h.length > 0 && (i.targets = h), null !== r.index)) {
                            let n = this.getUID(r.index);
                            (void 0 === m[t].start && void 0 === m[t].count) || (n += ":" + m[t].start + ":" + m[t].count), e.attributes.has(n) ? (i.indices = e.attributes.get(n)) : ((i.indices = this.processAccessor(r.index, r, m[t].start, m[t].count)), e.attributes.set(n, i.indices)), null === i.indices && delete i.indices;
                        }
                        const n = this.processMaterial(g[m[t].materialIndex]);
                        null !== n && (i.material = n), c.push(i);
                    }
                    (o.primitives = c),
                        i.meshes || (i.meshes = []),
                        this._invokeAll(function (e) {
                            e.writeMesh && e.writeMesh(t, o);
                        });
                    const f = i.meshes.push(o) - 1;
                    return e.meshes.set(s, f), f;
                }
                processCamera(t) {
                    const e = this.json;
                    e.cameras || (e.cameras = []);
                    const i = t.isOrthographicCamera,
                        n = { type: i ? "orthographic" : "perspective" };
                    return i ? (n.orthographic = { xmag: 2 * t.right, ymag: 2 * t.top, zfar: t.far <= 0 ? 0.001 : t.far, znear: t.near < 0 ? 0 : t.near }) : (n.perspective = { aspectRatio: t.aspect, yfov: gt.degToRad(t.fov), zfar: t.far <= 0 ? 0.001 : t.far, znear: t.near < 0 ? 0 : t.near }), "" !== t.name && (n.name = t.type), e.cameras.push(n) - 1;
                }
                processAnimation(t, e) {
                    const i = this.json,
                        n = this.nodeMap;
                    i.animations || (i.animations = []);
                    const s = (t = Km.Utils.mergeMorphTargetTracks(t.clone(), e)).tracks,
                        r = [],
                        a = [];
                    for (let t = 0; t < s.length; ++t) {
                        const i = s[t],
                            o = Nl.parseTrackName(i.name);
                        let l = Nl.findNode(e, o.nodeName);
                        const c = ef[o.propertyName];
                        if (("bones" === o.objectName && (l = !0 === l.isSkinnedMesh ? l.skeleton.getBoneByName(o.objectIndex) : void 0), !l || !c)) return null;
                        const h = 1;
                        let u,
                            d = i.values.length / i.times.length;
                        c === ef.morphTargetInfluences && (d /= l.morphTargetInfluences.length), !0 === i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? ((u = "CUBICSPLINE"), (d /= 3)) : (u = 2300 === i.getInterpolation() ? "STEP" : "LINEAR"), a.push({ input: this.processAccessor(new $e(i.times, h)), output: this.processAccessor(new $e(i.values, d)), interpolation: u }), r.push({ sampler: a.length - 1, target: { node: n.get(l), path: c } });
                    }
                    return i.animations.push({ name: t.name || "clip_" + i.animations.length, samplers: a, channels: r }), i.animations.length - 1;
                }
                processSkin(t) {
                    const e = this.json,
                        i = this.nodeMap,
                        n = e.nodes[i.get(t)],
                        s = t.skeleton;
                    if (void 0 === s) return null;
                    const r = t.skeleton.bones[0];
                    if (void 0 === r) return null;
                    const a = [],
                        o = new Float32Array(16 * s.bones.length),
                        l = new se();
                    for (let e = 0; e < s.bones.length; ++e) a.push(i.get(s.bones[e])), l.copy(s.boneInverses[e]), l.multiply(t.bindMatrix).toArray(o, 16 * e);
                    return void 0 === e.skins && (e.skins = []), e.skins.push({ inverseBindMatrices: this.processAccessor(new $e(o, 16)), joints: a, skeleton: i.get(r) }), (n.skin = e.skins.length - 1);
                }
                processNode(t) {
                    const e = this.json,
                        i = this.options,
                        n = this.nodeMap;
                    e.nodes || (e.nodes = []);
                    const s = {};
                    if (i.trs) {
                        const e = t.quaternion.toArray(),
                            i = t.position.toArray(),
                            n = t.scale.toArray();
                        nf(e, [0, 0, 0, 1]) || (s.rotation = e), nf(i, [0, 0, 0]) || (s.translation = i), nf(n, [1, 1, 1]) || (s.scale = n);
                    } else t.matrixAutoUpdate && t.updateMatrix(), !1 === nf(t.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (s.matrix = t.matrix.elements);
                    if (("" !== t.name && (s.name = String(t.name)), this.serializeUserData(t, s), t.isMesh || t.isLine || t.isPoints)) {
                        const e = this.processMesh(t);
                        null !== e && (s.mesh = e);
                    } else t.isCamera && (s.camera = this.processCamera(t));
                    if ((t.isSkinnedMesh && this.skins.push(t), t.children.length > 0)) {
                        const e = [];
                        for (let n = 0, s = t.children.length; n < s; n++) {
                            const s = t.children[n];
                            if (s.visible || !1 === i.onlyVisible) {
                                const t = this.processNode(s);
                                null !== t && e.push(t);
                            }
                        }
                        e.length > 0 && (s.children = e);
                    }
                    this._invokeAll(function (e) {
                        e.writeNode && e.writeNode(t, s);
                    });
                    const r = e.nodes.push(s) - 1;
                    return n.set(t, r), r;
                }
                processScene(t) {
                    const e = this.json,
                        i = this.options;
                    e.scenes || ((e.scenes = []), (e.scene = 0));
                    const n = {};
                    "" !== t.name && (n.name = t.name), e.scenes.push(n);
                    const s = [];
                    for (let e = 0, n = t.children.length; e < n; e++) {
                        const n = t.children[e];
                        if (n.visible || !1 === i.onlyVisible) {
                            const t = this.processNode(n);
                            null !== t && s.push(t);
                        }
                    }
                    s.length > 0 && (n.nodes = s), this.serializeUserData(t, n);
                }
                processObjects(t) {
                    const e = new Pr();
                    e.name = "AuxScene";
                    for (let i = 0; i < t.length; i++) e.children.push(t[i]);
                    this.processScene(e);
                }
                processInput(t) {
                    const e = this.options;
                    (t = t instanceof Array ? t : [t]),
                        this._invokeAll(function (e) {
                            e.beforeParse && e.beforeParse(t);
                        });
                    const i = [];
                    for (let e = 0; e < t.length; e++) t[e] instanceof Pr ? this.processScene(t[e]) : i.push(t[e]);
                    i.length > 0 && this.processObjects(i);
                    for (let t = 0; t < this.skins.length; ++t) this.processSkin(this.skins[t]);
                    for (let i = 0; i < e.animations.length; ++i) this.processAnimation(e.animations[i], t[0]);
                    this._invokeAll(function (e) {
                        e.afterParse && e.afterParse(t);
                    });
                }
                _invokeAll(t) {
                    for (let e = 0, i = this.plugins.length; e < i; e++) t(this.plugins[e]);
                }
            }
            class lf {
                constructor(t) {
                    (this.writer = t), (this.name = "KHR_lights_punctual");
                }
                writeNode(t, e) {
                    if (!t.isLight) return;
                    if (!t.isDirectionalLight && !t.isPointLight && !t.isSpotLight) return;
                    const i = this.writer,
                        n = i.json,
                        s = i.extensionsUsed,
                        r = {};
                    t.name && (r.name = t.name), (r.color = t.color.toArray()), (r.intensity = t.intensity), t.isDirectionalLight ? (r.type = "directional") : t.isPointLight ? ((r.type = "point"), t.distance > 0 && (r.range = t.distance)) : t.isSpotLight && ((r.type = "spot"), t.distance > 0 && (r.range = t.distance), (r.spot = {}), (r.spot.innerConeAngle = (t.penumbra - 1) * t.angle * -1), (r.spot.outerConeAngle = t.angle)), void 0 !== t.decay && t.decay, !t.target || (t.target.parent === t && 0 === t.target.position.x && 0 === t.target.position.y && t.target.position.z), s[this.name] || ((n.extensions = n.extensions || {}), (n.extensions[this.name] = { lights: [] }), (s[this.name] = !0));
                    const a = n.extensions[this.name].lights;
                    a.push(r), (e.extensions = e.extensions || {}), (e.extensions[this.name] = { light: a.length - 1 });
                }
            }
            class cf {
                constructor(t) {
                    (this.writer = t), (this.name = "KHR_materials_unlit");
                }
                writeMaterial(t, e) {
                    if (!t.isMeshBasicMaterial) return;
                    const i = this.writer.extensionsUsed;
                    (e.extensions = e.extensions || {}), (e.extensions[this.name] = {}), (i[this.name] = !0), (e.pbrMetallicRoughness.metallicFactor = 0), (e.pbrMetallicRoughness.roughnessFactor = 0.9);
                }
            }
            class hf {
                constructor(t) {
                    (this.writer = t), (this.name = "KHR_materials_pbrSpecularGlossiness");
                }
                writeMaterial(t, e) {
                    if (!t.isGLTFSpecularGlossinessMaterial) return;
                    const i = this.writer,
                        n = i.extensionsUsed,
                        s = {};
                    e.pbrMetallicRoughness.baseColorFactor && (s.diffuseFactor = e.pbrMetallicRoughness.baseColorFactor);
                    const r = [1, 1, 1];
                    if ((t.specular.toArray(r, 0), (s.specularFactor = r), (s.glossinessFactor = t.glossiness), e.pbrMetallicRoughness.baseColorTexture && (s.diffuseTexture = e.pbrMetallicRoughness.baseColorTexture), t.specularMap)) {
                        const e = { index: i.processTexture(t.specularMap) };
                        i.applyTextureTransform(e, t.specularMap), (s.specularGlossinessTexture = e);
                    }
                    (e.extensions = e.extensions || {}), (e.extensions[this.name] = s), (n[this.name] = !0);
                }
            }
            class uf {
                constructor(t) {
                    (this.writer = t), (this.name = "KHR_materials_transmission");
                }
                writeMaterial(t, e) {
                    if (!t.isMeshPhysicalMaterial || 0 === t.transmission) return;
                    const i = this.writer,
                        n = i.extensionsUsed,
                        s = {};
                    if (((s.transmissionFactor = t.transmission), t.transmissionMap)) {
                        const e = { index: i.processTexture(t.transmissionMap) };
                        i.applyTextureTransform(e, t.transmissionMap), (s.transmissionTexture = e);
                    }
                    (e.extensions = e.extensions || {}), (e.extensions[this.name] = s), (n[this.name] = !0);
                }
            }
            class df {
                constructor(t) {
                    (this.writer = t), (this.name = "KHR_materials_volume");
                }
                writeMaterial(t, e) {
                    if (!t.isMeshPhysicalMaterial || 0 === t.thickness) return;
                    const i = this.writer,
                        n = i.extensionsUsed,
                        s = {};
                    if (((s.thicknessFactor = t.thickness), t.thicknessMap)) {
                        const e = { index: i.processTexture(t.thicknessMap) };
                        i.applyTextureTransform(e, t.thicknessMap), (s.thicknessTexture = e);
                    }
                    (s.attenuationDistance = t.attenuationDistance), (s.attenuationColor = t.attenuationTint.toArray()), (e.extensions = e.extensions || {}), (e.extensions[this.name] = s), (n[this.name] = !0);
                }
            }
            Km.Utils = {
                insertKeyframe: function (t, e) {
                    const i = 0.001,
                        n = t.getValueSize(),
                        s = new t.TimeBufferType(t.times.length + 1),
                        r = new t.ValueBufferType(t.values.length + n),
                        a = t.createInterpolant(new t.ValueBufferType(n));
                    let o;
                    if (0 === t.times.length) {
                        s[0] = e;
                        for (let t = 0; t < n; t++) r[t] = 0;
                        o = 0;
                    } else if (e < t.times[0]) {
                        if (Math.abs(t.times[0] - e) < i) return 0;
                        (s[0] = e), s.set(t.times, 1), r.set(a.evaluate(e), 0), r.set(t.values, n), (o = 0);
                    } else if (e > t.times[t.times.length - 1]) {
                        if (Math.abs(t.times[t.times.length - 1] - e) < i) return t.times.length - 1;
                        (s[s.length - 1] = e), s.set(t.times, 0), r.set(t.values, 0), r.set(a.evaluate(e), t.values.length), (o = s.length - 1);
                    } else
                        for (let l = 0; l < t.times.length; l++) {
                            if (Math.abs(t.times[l] - e) < i) return l;
                            if (t.times[l] < e && t.times[l + 1] > e) {
                                s.set(t.times.slice(0, l + 1), 0), (s[l + 1] = e), s.set(t.times.slice(l + 1), l + 2), r.set(t.values.slice(0, (l + 1) * n), 0), r.set(a.evaluate(e), (l + 1) * n), r.set(t.values.slice((l + 1) * n), (l + 2) * n), (o = l + 1);
                                break;
                            }
                        }
                    return (t.times = s), (t.values = r), o;
                },
                mergeMorphTargetTracks: function (t, e) {
                    const i = [],
                        n = {},
                        s = t.tracks;
                    for (let t = 0; t < s.length; ++t) {
                        let r = s[t];
                        const a = Nl.parseTrackName(r.name),
                            o = Nl.findNode(e, a.nodeName);
                        if ("morphTargetInfluences" !== a.propertyName || void 0 === a.propertyIndex) {
                            i.push(r);
                            continue;
                        }
                        if (r.createInterpolant !== r.InterpolantFactoryMethodDiscrete && r.createInterpolant !== r.InterpolantFactoryMethodLinear) {
                            if (r.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                            (r = r.clone()), r.setInterpolation(2301);
                        }
                        const l = o.morphTargetInfluences.length,
                            c = o.morphTargetDictionary[a.propertyIndex];
                        if (void 0 === c) throw new Error("THREE.GLTFExporter: Morph target name not found: " + a.propertyIndex);
                        let h;
                        if (void 0 === n[o.uuid]) {
                            h = r.clone();
                            const t = new h.ValueBufferType(l * h.times.length);
                            for (let e = 0; e < h.times.length; e++) t[e * l + c] = h.values[e];
                            (h.name = (a.nodeName || "") + ".morphTargetInfluences"), (h.values = t), (n[o.uuid] = h), i.push(h);
                            continue;
                        }
                        const u = r.createInterpolant(new r.ValueBufferType(1));
                        h = n[o.uuid];
                        for (let t = 0; t < h.times.length; t++) h.values[t * l + c] = u.evaluate(h.times[t]);
                        for (let t = 0; t < r.times.length; t++) {
                            const e = this.insertKeyframe(h, r.times[t]);
                            h.values[e * l + c] = r.values[t];
                        }
                    }
                    return (t.tracks = i), t;
                },
            };
            /* @license
             * Copyright 2021 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const pf = (t) => void 0 !== t.material && t.userData && t.userData.variantMaterials && !!Array.from(t.userData.variantMaterials.values()).filter((t) => Af(t.material)),
                Af = (t) => t && t.isMaterial && !Array.isArray(t);
            class gf {
                constructor(t) {
                    (this.writer = t), (this.name = "KHR_materials_variants"), (this.variantNames = []);
                }
                beforeParse(t) {
                    const e = new Set();
                    for (const i of t)
                        i.traverse((t) => {
                            if (!pf(t)) return;
                            const i = t.userData.variantMaterials;
                            for (const t of i.keys()) {
                                const n = i.get(t);
                                Af(n.material) && e.add(t);
                            }
                        });
                    e.forEach((t) => this.variantNames.push(t));
                }
                writeMesh(t, e) {
                    if (!pf(t)) return;
                    const i = t.userData,
                        n = i.variantMaterials,
                        s = new Map();
                    for (const t of n.keys()) {
                        const e = n.get(t).material;
                        if (!Af(e)) continue;
                        const i = this.variantNames.indexOf(t),
                            r = this.writer.processMaterial(e);
                        s.has(r) || s.set(r, { material: r, variants: [] }), s.get(r).variants.push(i);
                    }
                    const r = Array.from(s.values())
                        .map((t) => t.variants.sort((t, e) => t - e) && t)
                        .sort((t, e) => t.material - e.material);
                    if (0 === r.length) return;
                    const a = Af(i.originalMaterial) ? this.writer.processMaterial(i.originalMaterial) : -1;
                    for (const t of e.primitives) a >= 0 && (t.material = a), (t.extensions = t.extensions || {}), (t.extensions[this.name] = { mappings: r });
                }
                afterParse() {
                    if (0 === this.variantNames.length) return;
                    const t = this.writer.json;
                    t.extensions = t.extensions || {};
                    const e = this.variantNames.map((t) => ({ name: t }));
                    (t.extensions[this.name] = { variants: e }), (this.writer.extensionsUsed[this.name] = !0);
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const mf = Symbol("correlatedObjects"),
                ff = Symbol("sourceObject"),
                vf = Symbol("onUpdate");
            class yf {
                constructor(t, e, i = null) {
                    (this[vf] = t), (this[ff] = e), (this[mf] = i);
                    /* @license
                     * Copyright 2020 Google LLC. All Rights Reserved.
                     * Licensed under the Apache License, Version 2.0 (the 'License');
                     * you may not use this file except in compliance with the License.
                     * You may obtain a copy of the License at
                     *
                     *     http://www.apache.org/licenses/LICENSE-2.0
                     *
                     * Unless required by applicable law or agreed to in writing, software
                     * distributed under the License is distributed on an 'AS IS' BASIS,
                     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                     * See the License for the specific language governing permissions and
                     * limitations under the License.
                     */
                }
            }
            const xf = new tl(),
                wf = new Xe(),
                _f = new Xi(2, 2),
                If = Symbol("threeTexture");
            class Cf extends yf {
                get [If]() {
                    var t;
                    return null === (t = this[mf]) || void 0 === t ? void 0 : t.values().next().value;
                }
                constructor(t, e, i) {
                    super(t, (i = null != i ? i : { name: "adhoc_image", uri: e && e.image ? e.image.src : "adhoc_image" }), new Set(e ? [e] : []));
                }
                get name() {
                    return this[ff].name || "";
                }
                get uri() {
                    return this[ff].uri;
                }
                get bufferView() {
                    return this[ff].bufferView;
                }
                get type() {
                    return null != this.uri ? "external" : "embedded";
                }
                async setURI(t) {
                    this[ff].uri = t;
                    const e = await new Promise((e, i) => {
                            xf.load(t, e, void 0, i);
                        }),
                        i = this[If];
                    (i.image = e), (i.needsUpdate = !0), this[vf]();
                }
                async createThumbnail(t, e) {
                    const i = new Pr();
                    wf.map = this[If];
                    const n = new Bi(_f, wf);
                    i.add(n);
                    const s = new on(-1, 1, 1, -1, 0, 1),
                        { threeRenderer: r } = md.singleton,
                        a = new Ct(t, e);
                    r.setRenderTarget(a), r.render(i, s), r.setRenderTarget(null);
                    const o = new Uint8Array(t * e * 4);
                    r.readRenderTargetPixels(a, 0, 0, t, e, o), (Rd.width = t), (Rd.height = e);
                    const l = Rd.getContext("2d"),
                        c = l.createImageData(t, e);
                    return (
                        c.data.set(o),
                        l.putImageData(c, 0, 0),
                        new Promise(async (t, e) => {
                            Rd.toBlob((i) => {
                                if (!i) return e("Failed to capture thumbnail.");
                                t(URL.createObjectURL(i));
                            }, "image/png");
                        })
                    );
                }
            }
            var Mf, Ef;
            !(function (t) {
                (t[(t.Nearest = 9728)] = "Nearest"), (t[(t.Linear = 9729)] = "Linear"), (t[(t.NearestMipmapNearest = 9984)] = "NearestMipmapNearest"), (t[(t.LinearMipmapNearest = 9985)] = "LinearMipmapNearest"), (t[(t.NearestMipmapLinear = 9986)] = "NearestMipmapLinear"), (t[(t.LinearMipmapLinear = 9987)] = "LinearMipmapLinear");
            })(Mf || (Mf = {})),
                (function (t) {
                    (t[(t.ClampToEdge = 33071)] = "ClampToEdge"), (t[(t.MirroredRepeat = 33648)] = "MirroredRepeat"), (t[(t.Repeat = 10497)] = "Repeat");
                })(Ef || (Ef = {}));
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const bf = (() => {
                    const t = [Mf.Nearest, Mf.Linear, Mf.NearestMipmapNearest, Mf.LinearMipmapLinear, Mf.NearestMipmapLinear, Mf.LinearMipmapLinear];
                    return (e) => t.indexOf(e) > -1;
                })(),
                Sf = (() => {
                    const t = [Mf.Nearest, Mf.Linear];
                    return (e) => t.indexOf(e) > -1;
                })(),
                Bf = (() => {
                    const t = [Ef.ClampToEdge, Ef.MirroredRepeat, Ef.Repeat];
                    return (e) => t.indexOf(e) > -1;
                })(),
                Tf = Symbol("threeTextures"),
                Lf = Symbol("setProperty"),
                Df = Symbol("sourceSampler");
            class Qf extends yf {
                get [Tf]() {
                    return this[mf];
                }
                get [Df]() {
                    return this[ff];
                }
                constructor(t, e, i) {
                    null == (i = null != i ? i : {}).minFilter && (i.minFilter = e ? e.minFilter : Mf.LinearMipmapLinear), null == i.magFilter && (i.magFilter = e ? e.magFilter : Mf.Linear), null == i.wrapS && (i.wrapS = e ? e.wrapS : Ef.Repeat), null == i.wrapT && (i.wrapT = e ? e.wrapT : Ef.Repeat), super(t, i, new Set(e ? [e] : []));
                }
                get name() {
                    return this[ff].name || "";
                }
                get minFilter() {
                    return this[Df].minFilter;
                }
                get magFilter() {
                    return this[Df].magFilter;
                }
                get wrapS() {
                    return this[Df].wrapS;
                }
                get wrapT() {
                    return this[Df].wrapT;
                }
                setMinFilter(t) {
                    this[Lf]("minFilter", t);
                }
                setMagFilter(t) {
                    this[Lf]("magFilter", t);
                }
                setWrapS(t) {
                    this[Lf]("wrapS", t);
                }
                setWrapT(t) {
                    this[Lf]("wrapT", t);
                }
                [Lf](t, e) {
                    const i = this[Df];
                    if (null != i) {
                        if (
                            ((t, e) => {
                                switch (t) {
                                    case "minFilter":
                                        return bf(e);
                                    case "magFilter":
                                        return Sf(e);
                                    case "wrapS":
                                    case "wrapT":
                                        return Bf(e);
                                    default:
                                        throw new Error(`Cannot configure property "${t}" on Sampler`);
                                }
                            })(t, e)
                        ) {
                            i[t] = e;
                            for (const i of this[Tf]) (i[t] = e), (i.needsUpdate = !0);
                        }
                        this[vf]();
                    }
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const Rf = Symbol("image"),
                Pf = Symbol("sampler");
            class Nf extends yf {
                constructor(t, e, i = null, n = null, s = null) {
                    super(t, i || {}, new Set(e ? [e] : [])), (this[Pf] = new Qf(t, e, n)), (this[Rf] = new Cf(t, e, s));
                }
                get name() {
                    return this[ff].name || "";
                }
                get sampler() {
                    return this[Pf];
                }
                get source() {
                    return this[Rf];
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var Ff;
            const Uf = Symbol("texture"),
                kf = Symbol("materials"),
                Of = Symbol("usage");
            var Gf;
            !(function (t) {
                (t[(t.Base = 0)] = "Base"), (t[(t.MetallicRoughness = 1)] = "MetallicRoughness"), (t[(t.Normal = 2)] = "Normal"), (t[(t.Occlusion = 3)] = "Occlusion"), (t[(t.Emissive = 4)] = "Emissive");
            })(Gf || (Gf = {}));
            class zf {
                constructor(t, e, i, n, s, r) {
                    if (((this[Ff] = null), r)) {
                        const e = s.textures ? s.textures[r.index] : null,
                            n = e && s.samplers ? s.samplers[e.sampler] : null,
                            a = e && s.images ? s.images[e.source] : null;
                        this[Uf] = new Nf(t, i, e, n, a);
                    }
                    (this.onUpdate = t), (this[kf] = n), (this[Of] = e);
                }
                get texture() {
                    return this[Uf];
                }
                setTexture(t) {
                    const e = null != t ? t.source[If] : null;
                    let i = 3001;
                    if (((this[Uf] = t), this[kf]))
                        for (const t of this[kf]) {
                            switch (this[Of]) {
                                case Gf.Base:
                                    t.map = e;
                                    break;
                                case Gf.MetallicRoughness:
                                    (i = 3e3), (t.metalnessMap = e), (t.roughnessMap = e);
                                    break;
                                case Gf.Normal:
                                    (i = 3e3), (t.normalMap = e);
                                    break;
                                case Gf.Occlusion:
                                    (i = 3e3), (t.aoMap = e);
                                    break;
                                case Gf.Emissive:
                                    t.emissiveMap = e;
                            }
                            t.needsUpdate = !0;
                        }
                    e && (e.encoding = i), this.onUpdate();
                }
            }
            Ff = Uf;
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            const Vf = Symbol("threeMaterials"),
                Hf = Symbol("baseColorTexture"),
                Wf = Symbol("metallicRoughnessTexture");
            class qf extends yf {
                constructor(t, e, i, n) {
                    super(t, i, n), null == i.baseColorFactor && (i.baseColorFactor = [1, 1, 1, 1]), null == i.roughnessFactor && (i.roughnessFactor = 1), null == i.metallicFactor && (i.metallicFactor = 1);
                    const { baseColorTexture: s, metallicRoughnessTexture: r } = i,
                        { map: a, metalnessMap: o } = n.values().next().value;
                    (this[Hf] = new zf(t, Gf.Base, a, n, e, s || null)), (this[Wf] = new zf(t, Gf.MetallicRoughness, o, n, e, r || null));
                }
                get [Vf]() {
                    return this[mf];
                }
                get baseColorFactor() {
                    return this[ff].baseColorFactor;
                }
                get metallicFactor() {
                    return this[ff].metallicFactor;
                }
                get roughnessFactor() {
                    return this[ff].roughnessFactor;
                }
                get baseColorTexture() {
                    return this[Hf];
                }
                get metallicRoughnessTexture() {
                    return this[Wf];
                }
                setBaseColorFactor(t) {
                    for (const e of this[Vf]) e.color.fromArray(t), (e.opacity = t[3]);
                    (this[ff].baseColorFactor = t), this[vf]();
                }
                setMetallicFactor(t) {
                    for (const e of this[Vf]) e.metalness = t;
                    (this[ff].metallicFactor = t), this[vf]();
                }
                setRoughnessFactor(t) {
                    for (const e of this[Vf]) e.roughness = t;
                    (this[ff].roughnessFactor = t), this[vf]();
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ const jf = Symbol("pbrMetallicRoughness"),
                Yf = Symbol("normalTexture"),
                Jf = Symbol("occlusionTexture"),
                Xf = Symbol("emissiveTexture"),
                Kf = Symbol("backingThreeMaterial"),
                Zf = Symbol("applyAlphaCutoff");
            class $f extends yf {
                constructor(t, e, i, n) {
                    if ((super(t, i, n), null == n)) return;
                    i.extensions && i.extensions.KHR_materials_pbrSpecularGlossiness, null == i.pbrMetallicRoughness && (i.pbrMetallicRoughness = {}), (this[jf] = new qf(t, e, i.pbrMetallicRoughness, n)), null == i.emissiveFactor && (i.emissiveFactor = [0, 0, 0]), null == i.doubleSided && (i.doubleSided = !1), null == i.alphaMode && (i.alphaMode = "OPAQUE"), null == i.alphaCutoff && (i.alphaCutoff = 0.5);
                    const { normalTexture: s, occlusionTexture: r, emissiveTexture: a } = i,
                        { normalMap: o, aoMap: l, emissiveMap: c } = n.values().next().value;
                    (this[Yf] = new zf(t, Gf.Normal, o, n, e, s || null)), (this[Jf] = new zf(t, Gf.Occlusion, l, n, e, r || null)), (this[Xf] = new zf(t, Gf.Emissive, c, n, e, a || null));
                }
                get [Kf]() {
                    return this[mf].values().next().value;
                }
                get name() {
                    return this[ff].name || "";
                }
                get pbrMetallicRoughness() {
                    return this[jf];
                }
                get normalTexture() {
                    return this[Yf];
                }
                get occlusionTexture() {
                    return this[Jf];
                }
                get emissiveTexture() {
                    return this[Xf];
                }
                get emissiveFactor() {
                    return this[ff].emissiveFactor;
                }
                setEmissiveFactor(t) {
                    for (const e of this[mf]) e.emissive.fromArray(t);
                    (this[ff].emissiveFactor = t), this[vf]();
                }
                [Zf]() {
                    const t = this[ff],
                        e = "OPAQUE" === t.alphaMode ? -0.5 : "BLEND" === t.alphaMode ? 0 : Math.max(1e-4, Math.min(1, t.alphaCutoff));
                    for (const t of this[mf]) (t.alphaTest = e), (t.needsUpdate = !0);
                }
                setAlphaCutoff(t) {
                    (this[ff].alphaCutoff = t), this[Zf](), this[vf]();
                }
                getAlphaCutoff() {
                    return this[ff].alphaCutoff;
                }
                setDoubleSided(t) {
                    for (const e of this[mf]) (e.side = t ? 2 : 0), (e.needsUpdate = !0);
                    (this[ff].doubleSided = t), this[vf]();
                }
                getDoubleSided() {
                    return this[ff].doubleSided;
                }
                setAlphaMode(t) {
                    const e = (t, e) => {
                        (t.transparent = e), (t.depthWrite = !e);
                    };
                    this[ff].alphaMode = t;
                    for (const i of this[mf]) e(i, "OPAQUE" !== t), this[Zf](), (i.needsUpdate = !0);
                    this[vf]();
                }
                getAlphaMode() {
                    return this[ff].alphaMode;
                }
            }
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var tv;
            const ev = Symbol("materials");
            class iv {
                constructor(t, e = () => {}) {
                    this[tv] = [];
                    const { gltf: i, gltfElementMap: n } = t;
                    i.materials.forEach((t) => {
                        this[ev].push(new $f(e, i, t, n.get(t)));
                    });
                }
                get materials() {
                    return this[ev];
                }
            }
            tv = ev;
            /* @license
             * Copyright 2020 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */
            var nv = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            const sv = Symbol("currentGLTF"),
                rv = Symbol("model"),
                av = Symbol("variants"),
                ov = Symbol("getOnUpdateMethod"),
                lv = Symbol("textureLoader"),
                cv = Symbol("originalGltfJson");
            /* @license
             * Copyright 2019 Google LLC. All Rights Reserved.
             * Licensed under the Apache License, Version 2.0 (the 'License');
             * you may not use this file except in compliance with the License.
             * You may obtain a copy of the License at
             *
             *     http://www.apache.org/licenses/LICENSE-2.0
             *
             * Unless required by applicable law or agreed to in writing, software
             * distributed under the License is distributed on an 'AS IS' BASIS,
             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
             * See the License for the specific language governing permissions and
             * limitations under the License.
             */ var hv = function (t, e, i, n) {
                for (var s, r = arguments.length, a = r < 3 ? e : null === n ? (n = Object.getOwnPropertyDescriptor(e, i)) : n, o = t.length - 1; o >= 0; o--) (s = t[o]) && (a = (r < 3 ? s(a) : r > 3 ? s(e, i, a) : s(e, i)) || a);
                return r > 3 && a && Object.defineProperty(e, i, a), a;
            };
            const uv = Math.PI / 32,
                dv = { basis: [tu(Hh(uv, "rad"))], keywords: { auto: [null] } },
                pv = Symbol("autoRotateStartTime"),
                Av = Symbol("radiansPerSecond"),
                gv = Symbol("syncRotationRate"),
                mv = Symbol("onCameraChange"),
                fv = ((t) => {
                    var e, i, n;
                    class s extends t {
                        constructor() {
                            super(...arguments),
                                (this[e] = new Map()),
                                (this[i] = (t) => {
                                    t.forEach((t) => {
                                        (t instanceof MutationRecord && "childList" !== t.type) ||
                                            (t.addedNodes.forEach((t) => {
                                                this[yp](t);
                                            }),
                                            t.removedNodes.forEach((t) => {
                                                this[xp](t);
                                            }),
                                            this[tp]());
                                    });
                                }),
                                (this[n] = new MutationObserver(this[fp]));
                        }
                        connectedCallback() {
                            super.connectedCallback();
                            for (let t = 0; t < this.children.length; ++t) this[yp](this.children[t]);
                            const { ShadyDOM: t } = self;
                            null == t ? this[vp].observe(this, { childList: !0 }) : (this[vp] = t.observeChildren(this, this[fp]));
                        }
                        disconnectedCallback() {
                            super.disconnectedCallback();
                            const { ShadyDOM: t } = self;
                            null == t ? this[vp].disconnect() : t.unobserveChildren(this[vp]);
                        }
                        [((e = mp), (i = fp), (n = vp), ep)](t, e) {
                            super[ep](t, e);
                            const i = this[$d],
                                { annotationRenderer: n } = i,
                                s = i.getCamera();
                            i.isDirty && (i.updateHotspots(s.position), (n.domElement.style.display = ""), n.render(i, s));
                        }
                        updateHotspot(t) {
                            const e = this[mp].get(t.name);
                            null != e && (e.updatePosition(t.position), e.updateNormal(t.normal), this[tp]());
                        }
                        positionAndNormalFromPoint(t, e) {
                            const i = this[$d],
                                { width: n, height: s, target: r } = i;
                            wp
                                .set(t / n, e / s)
                                .multiplyScalar(2)
                                .subScalar(1),
                                (wp.y *= -1);
                            const a = i.positionAndNormalFromPoint(wp);
                            if (null == a) return null;
                            _p.copy(r.matrixWorld).invert();
                            const o = up(a.position.applyMatrix4(_p));
                            return Ip.getNormalMatrix(_p), { position: o, normal: up(a.normal.applyNormalMatrix(Ip)) };
                        }
                        [yp](t) {
                            if (!(t instanceof HTMLElement && 0 === t.slot.indexOf("hotspot"))) return;
                            let e = this[mp].get(t.slot);
                            null != e ? e.increment() : ((e = new nu({ name: t.slot, position: t.dataset.position, normal: t.dataset.normal })), this[mp].set(t.slot, e), this[$d].addHotspot(e)), (this[$d].isDirty = !0);
                        }
                        [xp](t) {
                            if (!(t instanceof HTMLElement)) return;
                            const e = this[mp].get(t.slot);
                            e && (e.decrement() && (this[$d].removeHotspot(e), this[mp].delete(t.slot)), (this[$d].isDirty = !0));
                        }
                    }
                    return s;
                })(
                    ((t) => {
                        var e, i, n, s, r;
                        class a extends t {
                            constructor() {
                                super(...arguments), (this[e] = void 0), (this[i] = null), (this[n] = []), (this[s] = new nl()), (this[r] = null), (this.variantName = void 0), (this.orientation = "0 0 0"), (this.scale = "1 1 1");
                            }
                            get model() {
                                return this[rv];
                            }
                            get availableVariants() {
                                return this[av];
                            }
                            get originalGltfJson() {
                                return this[cv];
                            }
                            [((e = rv), (i = sv), (n = av), (s = lv), (r = cv), ov)]() {
                                return () => {
                                    this[tp]();
                                };
                            }
                            async createTexture(t, e = "image/png") {
                                const i = this[sv],
                                    n = await new Promise((e) => this[lv].load(t, e));
                                return i && n ? ((n.encoding = 3001), (n.wrapS = 1e3), (n.wrapT = 1e3), (n.flipY = !1), "image/jpeg" === e && (n.format = 1022), new Nf(this[ov](), n)) : null;
                            }
                            async updated(t) {
                                if ((super.updated(t), t.has("variantName"))) {
                                    const t = this[sv],
                                        { variantName: e } = this;
                                    if (null == t) return;
                                    const i = await t.correlatedSceneGraph.loadVariant(e),
                                        { gltf: n, gltfElementMap: s } = t.correlatedSceneGraph;
                                    for (const t of i) {
                                        const e = n.materials[t];
                                        this[rv].materials[t] = new $f(this[ov](), n, e, s.get(e));
                                    }
                                    this[tp]();
                                }
                                if (t.has("orientation") || t.has("scale")) {
                                    const { modelContainer: t } = this[$d],
                                        e = Wh(this.orientation)[0].terms,
                                        i = iu(e[0]).number,
                                        n = iu(e[1]).number,
                                        s = iu(e[2]).number;
                                    t.quaternion.setFromEuler(new Ae(n, s, i, "YXZ"));
                                    const r = Wh(this.scale)[0].terms;
                                    t.scale.set(r[0].number, r[1].number, r[2].number), this[$d].updateBoundingBox(), this[$d].updateShadow(), this[sp].arRenderer.onUpdateScene(), this[tp]();
                                }
                            }
                            [ip]() {
                                super[ip](), (this[av] = []);
                                const { currentGLTF: t } = this[$d];
                                if (null != t) {
                                    const { correlatedSceneGraph: e } = t;
                                    null != e && t !== this[sv] && ((this[rv] = new iv(e, this[ov]())), (this[cv] = JSON.parse(JSON.stringify(e.gltf)))), "variants" in t.userData && ((this[av] = t.userData.variants.slice()), this.requestUpdate("variantName"));
                                }
                                (this[sv] = t), this.dispatchEvent(new CustomEvent("scene-graph-ready"));
                            }
                            async exportScene(t) {
                                const e = this[$d];
                                return new Promise(async (i) => {
                                    const n = { binary: !0, onlyVisible: !0, maxTextureSize: 1 / 0, forcePowerOfTwoTextures: !1, includeCustomExtensions: !1, embedImages: !0 };
                                    Object.assign(n, t), (n.animations = e.animations), (n.truncateDrawRange = !0);
                                    const s = e.shadow;
                                    let r = !1;
                                    null != s && ((r = s.visible), (s.visible = !1));
                                    const a = this[sv];
                                    null != a && "functions" in a.userData && "ensureLoadVariants" in a.userData.functions && (await a.userData.functions.ensureLoadVariants(e)), new Km().register((t) => new gf(t)).parse(e.modelContainer.children[0], (t) => i(new Blob([n.binary ? t : JSON.stringify(t)], { type: n.binary ? "application/octet-stream" : "application/json" })), n), null != s && (s.visible = r);
                                });
                            }
                        }
                        return nv([k({ type: String, attribute: "variant-name" })], a.prototype, "variantName", void 0), nv([k({ type: String, attribute: "orientation" })], a.prototype, "orientation", void 0), nv([k({ type: String, attribute: "scale" })], a.prototype, "scale", void 0), a;
                    })(
                        ((t) => {
                            var e, i, n;
                            class s extends t {
                                constructor() {
                                    super(...arguments),
                                        (this.autoRotate = !1),
                                        (this.autoRotateDelay = 3e3),
                                        (this.rotationPerSecond = "auto"),
                                        (this[e] = performance.now()),
                                        (this[i] = 0),
                                        (this[n] = (t) => {
                                            this.autoRotate && "user-interaction" === t.detail.source && (this[pv] = performance.now());
                                        });
                                }
                                connectedCallback() {
                                    super.connectedCallback(), this.addEventListener("camera-change", this[mv]), (this[pv] = performance.now());
                                }
                                disconnectedCallback() {
                                    super.disconnectedCallback(), this.removeEventListener("camera-change", this[mv]), (this[pv] = performance.now());
                                }
                                updated(t) {
                                    super.updated(t), t.has("autoRotate") && (this[pv] = performance.now());
                                }
                                [((e = pv), (i = Av), gv)](t) {
                                    this[Av] = t[0];
                                }
                                [ep](t, e) {
                                    if ((super[ep](t, e), !this.autoRotate || !this[hp]() || this[sp].isPresenting)) return;
                                    const i = Math.min(e, t - this[pv] - this.autoRotateDelay);
                                    i > 0 && (this[$d].yaw = this.turntableRotation + this[Av] * i * 0.001);
                                }
                                get turntableRotation() {
                                    return this[$d].yaw;
                                }
                                resetTurntableRotation(t = 0) {
                                    this[$d].yaw = t;
                                }
                            }
                            return (n = mv), hv([k({ type: Boolean, attribute: "auto-rotate" })], s.prototype, "autoRotate", void 0), hv([k({ type: Number, attribute: "auto-rotate-delay" })], s.prototype, "autoRotateDelay", void 0), hv([bg({ intrinsics: dv, updateHandler: gv }), k({ type: String, attribute: "rotation-per-second" })], s.prototype, "rotationPerSecond", void 0), s;
                        })(
                            ((t) => {
                                var e, i, n;
                                class s extends t {
                                    constructor() {
                                        super(...arguments),
                                            (this.environmentImage = null),
                                            (this.skyboxImage = null),
                                            (this.shadowIntensity = 0),
                                            (this.shadowSoftness = 1),
                                            (this.exposure = 1),
                                            (this[e] = null),
                                            (this[i] = null),
                                            (this[n] = (t) => {
                                                t.element === this && this[Cu]();
                                            });
                                    }
                                    connectedCallback() {
                                        super.connectedCallback(), this[sp].loader.addEventListener("preload", this[Eu]);
                                    }
                                    disconnectedCallback() {
                                        super.disconnectedCallback(), this[sp].loader.removeEventListener("preload", this[Eu]);
                                    }
                                    updated(t) {
                                        super.updated(t), t.has("shadowIntensity") && (this[$d].setShadowIntensity(0.1 * this.shadowIntensity), this[tp]()), t.has("shadowSoftness") && (this[$d].setShadowSoftness(this.shadowSoftness), this[tp]()), t.has("exposure") && ((this[$d].exposure = this.exposure), this[tp]()), (t.has("environmentImage") || t.has("skyboxImage")) && this[lp]() && this[Cu]();
                                    }
                                    [((e = _u), (i = Mu), (n = Eu), ip)]() {
                                        super[ip](), null != this[_u] && this[Iu](this[_u]);
                                    }
                                    async [Cu]() {
                                        const { skyboxImage: t, environmentImage: e } = this;
                                        null != this[Mu] && (this[Mu](), (this[Mu] = null));
                                        const { textureUtils: i } = this[sp];
                                        if (null != i)
                                            try {
                                                const { environmentMap: n, skybox: s } = await new Promise(async (n, s) => {
                                                        const r = i.generateEnvironmentMapAndSkybox(Nh(t), e, { progressTracker: this[rp] });
                                                        (this[Mu] = () => s(r)), n(await r);
                                                    }),
                                                    r = n.texture;
                                                (this[$d].background = null != s ? (s.userData.url === r.userData.url ? r : s) : null), this[Iu](n.texture), this[$d].dispatchEvent({ type: "envmap-update" });
                                            } catch (t) {
                                                if (t instanceof Error) throw (this[Iu](null), t);
                                            }
                                    }
                                    [Iu](t) {
                                        (this[_u] = t), (this[$d].environment = this[_u]), this.dispatchEvent(new CustomEvent("environment-change")), this[tp]();
                                    }
                                }
                                return wu([k({ type: String, attribute: "environment-image" })], s.prototype, "environmentImage", void 0), wu([k({ type: String, attribute: "skybox-image" })], s.prototype, "skyboxImage", void 0), wu([k({ type: Number, attribute: "shadow-intensity" })], s.prototype, "shadowIntensity", void 0), wu([k({ type: Number, attribute: "shadow-softness" })], s.prototype, "shadowSoftness", void 0), wu([k({ type: Number })], s.prototype, "exposure", void 0), s;
                            })(
                                ((t) => {
                                    var e, i, n, s, r, a, o, l, c, h, u, d, p, A, g, m, f;
                                    class v extends t {
                                        constructor() {
                                            super(...arguments),
                                                (this.cameraControls = !1),
                                                (this.cameraOrbit = "0deg 75deg 105%"),
                                                (this.cameraTarget = "auto auto auto"),
                                                (this.fieldOfView = "auto"),
                                                (this.minCameraOrbit = "auto"),
                                                (this.maxCameraOrbit = "auto"),
                                                (this.minFieldOfView = "auto"),
                                                (this.maxFieldOfView = "auto"),
                                                (this.interactionPromptThreshold = 3e3),
                                                (this.interactionPromptStyle = Hg),
                                                (this.interactionPrompt = zg),
                                                (this.interactionPolicy = "always-allow"),
                                                (this.orbitSensitivity = 1),
                                                (this.touchAction = "pan-y"),
                                                (this.disableZoom = !1),
                                                (this.interpolationDecay = 50),
                                                (this.bounds = "legacy"),
                                                (this[e] = this.shadowRoot.querySelector(".interaction-prompt")),
                                                (this[i] = this.shadowRoot.querySelector(".interaction-prompt > .animated-container")),
                                                (this[n] = 1 / 0),
                                                (this[s] = 0),
                                                (this[r] = 1 / 0),
                                                (this[a] = !1),
                                                (this[o] = !1),
                                                (this[l] = new Dg(this[$d].camera, this[Kd])),
                                                (this[c] = 0),
                                                (this[h] = new Gl()),
                                                (this[u] = !1),
                                                (this[d] = !1),
                                                (this[p] = !1),
                                                (this[A] = () => {
                                                    const t = this[Kd];
                                                    isFinite(this[mm]) || (this[mm] = performance.now());
                                                    const e = this[qd];
                                                    t.getAttribute("aria-label") !== e && t.setAttribute("aria-label", e), this.interactionPrompt !== Vg || this[pm] || (this[dm] = !0);
                                                }),
                                                (this[g] = () => {
                                                    this.interactionPrompt === Vg && ((this[dm] = !1), this[nm].classList.remove("visible"), (this[Am] = 1 / 0), (this[mm] = 1 / 0));
                                                }),
                                                (this[m] = ({ source: t }) => {
                                                    this[am](), this[tp](), t === Lg && ((this[pm] = !0), this[rm]()), this.dispatchEvent(new CustomEvent("camera-change", { detail: { source: t } }));
                                                }),
                                                (this[f] = (t) => {
                                                    "pointer-change-start" === t.type ? this[Xd].classList.add("pointer-tumbling") : this[Xd].classList.remove("pointer-tumbling");
                                                });
                                        }
                                        getCameraOrbit() {
                                            const { theta: t, phi: e, radius: i } = this[vm];
                                            return {
                                                theta: t,
                                                phi: e,
                                                radius: i,
                                                toString() {
                                                    return `${this.theta}rad ${this.phi}rad ${this.radius}m`;
                                                },
                                            };
                                        }
                                        getCameraTarget() {
                                            return up(this[sp].isPresenting ? this[sp].arRenderer.target : this[$d].getTarget());
                                        }
                                        getFieldOfView() {
                                            return this[im].getFieldOfView();
                                        }
                                        getMinimumFieldOfView() {
                                            return this[im].options.minimumFieldOfView;
                                        }
                                        getMaximumFieldOfView() {
                                            return this[im].options.maximumFieldOfView;
                                        }
                                        jumpCameraToGoal() {
                                            (this[ym] = !0), this.requestUpdate(ym, !1);
                                        }
                                        resetInteractionPrompt() {
                                            (this[gm] = 0), (this[Am] = 1 / 0), (this[pm] = !1), (this[dm] = this.interactionPrompt === zg && this.cameraControls);
                                        }
                                        connectedCallback() {
                                            super.connectedCallback(), this[im].addEventListener("change", this[hm]), this[im].addEventListener("pointer-change-start", this[um]), this[im].addEventListener("pointer-change-end", this[um]);
                                        }
                                        disconnectedCallback() {
                                            super.disconnectedCallback(), this[im].removeEventListener("change", this[hm]), this[im].removeEventListener("pointer-change-start", this[um]), this[im].removeEventListener("pointer-change-end", this[um]);
                                        }
                                        updated(t) {
                                            super.updated(t);
                                            const e = this[im],
                                                i = this[Kd];
                                            if ((t.has("cameraControls") && (this.cameraControls ? (e.enableInteraction(), this.interactionPrompt === zg && (this[dm] = !0), i.addEventListener("focus", this[cm]), i.addEventListener("blur", this[lm])) : (i.removeEventListener("focus", this[cm]), i.removeEventListener("blur", this[lm]), e.disableInteraction(), this[rm]())), t.has("disableZoom") && (e.disableZoom = this.disableZoom), t.has("bounds") && (this[$d].tightBounds = "tight" === this.bounds), (t.has("interactionPrompt") || t.has("cameraControls") || t.has("src")) && (this.interactionPrompt === zg && this.cameraControls && !this[pm] ? (this[dm] = !0) : this[rm]()), t.has("interactionPromptStyle") && this[nm].classList.toggle("wiggle", this.interactionPromptStyle === Hg), t.has("interactionPolicy"))) {
                                                const t = this.interactionPolicy;
                                                e.applyOptions({ interactionPolicy: t });
                                            }
                                            if (t.has("touchAction")) {
                                                const t = this.touchAction;
                                                e.applyOptions({ touchAction: t });
                                            }
                                            t.has("orbitSensitivity") && (e.sensitivity = this.orbitSensitivity),
                                                t.has("interpolationDecay") && (e.setDamperDecayTime(this.interpolationDecay), this[$d].setTargetDamperDecayTime(this.interpolationDecay)),
                                                !0 === this[ym] &&
                                                    Promise.resolve().then(() => {
                                                        e.jumpToGoal(), this[$d].jumpToGoal(), (this[ym] = !1);
                                                    });
                                        }
                                        async updateFraming() {
                                            const t = this[$d],
                                                e = t.framedFieldOfView;
                                            await this.requestUpdate("cameraTarget"), t.updateFraming("tight" === this.bounds ? t.getTarget() : void 0), t.frameModel();
                                            const i = t.framedFieldOfView,
                                                n = this[im].getFieldOfView() / e;
                                            (this[fm] = i * n), (this[wm] = !0), this.requestUpdate("maxFieldOfView"), this.requestUpdate("fieldOfView"), this.requestUpdate("minCameraOrbit"), this.requestUpdate("maxCameraOrbit"), await this.requestUpdate("cameraOrbit");
                                        }
                                        [((e = nm), (i = sm), (n = mm), (s = gm), (r = Am), (a = pm), (o = dm), (l = im), (c = fm), (h = vm), (u = ym), (d = xm), (p = wm), Im)](t) {
                                            this[im].setFieldOfView((180 * t[0]) / Math.PI);
                                        }
                                        [_m](t) {
                                            if (this[wm]) {
                                                const { theta: e, phi: i } = this.getCameraOrbit();
                                                (t[0] = e), (t[1] = i), (this[wm] = !1);
                                            }
                                            this[im].setOrbit(t[0], t[1], t[2]);
                                        }
                                        [Mm](t) {
                                            this[im].applyOptions({ minimumAzimuthalAngle: t[0], minimumPolarAngle: t[1], minimumRadius: t[2] }), this.jumpCameraToGoal();
                                        }
                                        [Em](t) {
                                            this[im].applyOptions({ maximumAzimuthalAngle: t[0], maximumPolarAngle: t[1], maximumRadius: t[2] }), this[om](t[2]), this.jumpCameraToGoal();
                                        }
                                        [bm](t) {
                                            this[im].applyOptions({ minimumFieldOfView: (180 * t[0]) / Math.PI }), this.jumpCameraToGoal();
                                        }
                                        [Sm](t) {
                                            this[im].applyOptions({ maximumFieldOfView: (180 * t[0]) / Math.PI }), this.jumpCameraToGoal();
                                        }
                                        [Cm](t) {
                                            const [e, i, n] = t;
                                            this[$d].setTarget(e, i, n), this[sp].arRenderer.updateTarget();
                                        }
                                        [ep](t, e) {
                                            if ((super[ep](t, e), this[sp].isPresenting || !this[hp]())) return;
                                            const i = performance.now();
                                            if (this[dm]) {
                                                const t = this.interactionPrompt === zg ? this[jd] : this[mm];
                                                this.loaded && i > t + this.interactionPromptThreshold && (this[Kd].setAttribute("aria-label", "Use mouse, touch or arrow keys to control the camera!"), (this[dm] = !1), (this[Am] = i), this[nm].classList.add("visible"));
                                            }
                                            if (isFinite(this[Am]) && this.interactionPromptStyle === Hg) {
                                                const t = this[$d],
                                                    e = ((i - this[Am]) / 5e3) % 1,
                                                    n = Fg(e),
                                                    s = Ug(e);
                                                if (((this[sm].style.opacity = `${s}`), n !== this[gm])) {
                                                    const e = n * t.width * 0.05,
                                                        i = ((n - this[gm]) * Math.PI) / 16;
                                                    (this[sm].style.transform = `translateX(${e}px)`), this[im].adjustOrbit(i, 0, 0), (this[gm] = n);
                                                }
                                            }
                                            this[im].update(t, e), this[$d].updateTarget(e);
                                        }
                                        [rm]() {
                                            (this[dm] = !1), this[nm].classList.remove("visible"), (this[Am] = 1 / 0);
                                        }
                                        [om](t) {
                                            const { idealCameraDistance: e } = this[$d],
                                                i = 2 * Math.max(e, t);
                                            this[im].updateNearFar(0, i);
                                        }
                                        [am]() {
                                            const { theta: t, phi: e } = this[vm],
                                                { theta: i, phi: n } = this[im].getCameraSpherical(this[vm]),
                                                s = this.getRootNode();
                                            if (null != s && s.activeElement === this) {
                                                const s = (4 + Math.floor(((t % em) + tm) / Zg)) % 4,
                                                    r = (4 + Math.floor(((i % em) + tm) / Zg)) % 4,
                                                    a = Math.floor(e / $g),
                                                    o = Math.floor(n / $g);
                                                if (r !== s || o !== a) {
                                                    const t = `View from stage ${Gg[o]}${Og[r]}`;
                                                    this[Kd].setAttribute("aria-label", t);
                                                }
                                            }
                                        }
                                        [np](t) {
                                            const e = this[im],
                                                i = this[$d].framedFieldOfView;
                                            super[np](t);
                                            const n = this[$d].framedFieldOfView,
                                                s = e.getFieldOfView() / i;
                                            (this[fm] = n * s), e.updateAspect(this[$d].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.jumpCameraToGoal();
                                        }
                                        [ip]() {
                                            super[ip]();
                                            const { framedFieldOfView: t } = this[$d];
                                            (this[fm] = t), this[xm] ? (this[wm] = !0) : (this[xm] = !0), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal();
                                        }
                                    }
                                    return (
                                        (A = cm),
                                        (g = lm),
                                        (m = hm),
                                        (f = um),
                                        Ng([k({ type: Boolean, attribute: "camera-controls" })], v.prototype, "cameraControls", void 0),
                                        Ng([bg({ intrinsics: Yg, observeEffects: !0, updateHandler: _m }), k({ type: String, attribute: "camera-orbit", hasChanged: () => !0 })], v.prototype, "cameraOrbit", void 0),
                                        Ng([bg({ intrinsics: Kg, observeEffects: !0, updateHandler: Cm }), k({ type: String, attribute: "camera-target", hasChanged: () => !0 })], v.prototype, "cameraTarget", void 0),
                                        Ng([bg({ intrinsics: Wg, observeEffects: !0, updateHandler: Im }), k({ type: String, attribute: "field-of-view", hasChanged: () => !0 })], v.prototype, "fieldOfView", void 0),
                                        Ng([bg({ intrinsics: Jg, updateHandler: Mm }), k({ type: String, attribute: "min-camera-orbit", hasChanged: () => !0 })], v.prototype, "minCameraOrbit", void 0),
                                        Ng([bg({ intrinsics: Xg, updateHandler: Em }), k({ type: String, attribute: "max-camera-orbit", hasChanged: () => !0 })], v.prototype, "maxCameraOrbit", void 0),
                                        Ng([bg({ intrinsics: qg, updateHandler: bm }), k({ type: String, attribute: "min-field-of-view", hasChanged: () => !0 })], v.prototype, "minFieldOfView", void 0),
                                        Ng([bg({ intrinsics: jg, updateHandler: Sm }), k({ type: String, attribute: "max-field-of-view", hasChanged: () => !0 })], v.prototype, "maxFieldOfView", void 0),
                                        Ng([k({ type: Number, attribute: "interaction-prompt-threshold" })], v.prototype, "interactionPromptThreshold", void 0),
                                        Ng([k({ type: String, attribute: "interaction-prompt-style" })], v.prototype, "interactionPromptStyle", void 0),
                                        Ng([k({ type: String, attribute: "interaction-prompt" })], v.prototype, "interactionPrompt", void 0),
                                        Ng([k({ type: String, attribute: "interaction-policy" })], v.prototype, "interactionPolicy", void 0),
                                        Ng([k({ type: Number, attribute: "orbit-sensitivity" })], v.prototype, "orbitSensitivity", void 0),
                                        Ng([k({ type: String, attribute: "touch-action" })], v.prototype, "touchAction", void 0),
                                        Ng([k({ type: Boolean, attribute: "disable-zoom" })], v.prototype, "disableZoom", void 0),
                                        Ng([k({ type: Number, attribute: "interpolation-decay" })], v.prototype, "interpolationDecay", void 0),
                                        Ng([k({ type: String, attribute: "bounds" })], v.prototype, "bounds", void 0),
                                        v
                                    );
                                })(
                                    ((t) => {
                                        var e, i, n, s, r, a, o, l, c, h;
                                        class u extends t {
                                            constructor() {
                                                super(...arguments),
                                                    (this.ar = !1),
                                                    (this.arScale = "auto"),
                                                    (this.arPlacement = "floor"),
                                                    (this.arModes = "webxr scene-viewer"),
                                                    (this.iosSrc = null),
                                                    (this.xrEnvironment = !1),
                                                    (this[e] = !1),
                                                    (this[i] = this.shadowRoot.querySelector(".ar-button")),
                                                    (this[n] = document.createElement("a")),
                                                    (this[s] = new Set()),
                                                    (this[r] = SA),
                                                    (this[a] = !1),
                                                    (this[o] = (t) => {
                                                        t.preventDefault(), this.activateAR();
                                                    }),
                                                    (this[l] = ({ status: t }) => {
                                                        (t !== Qu && this[sp].arRenderer.presentedScene !== this[$d]) || (this.setAttribute("ar-status", t), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: t } })), t === Qu ? this.removeAttribute("ar-tracking") : t === Ru && this.setAttribute("ar-tracking", Pu));
                                                    }),
                                                    (this[c] = ({ status: t }) => {
                                                        this.setAttribute("ar-tracking", t), this.dispatchEvent(new CustomEvent("ar-tracking", { detail: { status: t } }));
                                                    }),
                                                    (this[h] = (t) => {
                                                        "_apple_ar_quicklook_button_tapped" == t.data && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"));
                                                    });
                                            }
                                            get canActivateAR() {
                                                return this[RA] !== SA;
                                            }
                                            connectedCallback() {
                                                super.connectedCallback(), this[sp].arRenderer.addEventListener("status", this[kA]), this.setAttribute("ar-status", Qu), this[sp].arRenderer.addEventListener("tracking", this[OA]), this[NA].addEventListener("message", this[GA]);
                                            }
                                            disconnectedCallback() {
                                                super.disconnectedCallback(), this[sp].arRenderer.removeEventListener("status", this[kA]), this[sp].arRenderer.removeEventListener("tracking", this[OA]), this[NA].removeEventListener("message", this[GA]);
                                            }
                                            async update(t) {
                                                super.update(t), t.has("arScale") && (this[$d].canScale = "fixed" !== this.arScale), t.has("arPlacement") && (this[$d].setShadowIntensity(this[$d].shadowIntensity), this[tp]()), (t.has("ar") || t.has("arModes") || t.has("iosSrc")) && (t.has("arModes") && (this[PA] = IA(this.arModes)), this[zA]());
                                            }
                                            async activateAR() {
                                                switch (this[RA]) {
                                                    case MA:
                                                        this[DA]();
                                                        break;
                                                    case bA:
                                                        await this[TA]();
                                                        break;
                                                    case EA:
                                                        this[LA]();
                                                }
                                            }
                                            async [((e = QA), (i = BA), (n = NA), (s = PA), (r = RA), (a = FA), (o = UA), (l = kA), (c = OA), (h = GA), zA)]() {
                                                if (((this[RA] = SA), this.ar)) {
                                                    if (null != this.src)
                                                        for (const t of this[PA]) {
                                                            if ("webxr" === t && J && !wA && (await this[sp].arRenderer.supportsPresentation())) {
                                                                this[RA] = bA;
                                                                break;
                                                            }
                                                            if ("scene-viewer" === t && et && !_A) {
                                                                this[RA] = EA;
                                                                break;
                                                            }
                                                            if ("quick-look" === t && Z) {
                                                                this[RA] = MA;
                                                                break;
                                                            }
                                                        }
                                                    !this.canActivateAR && null != this.iosSrc && Z && (this[RA] = MA);
                                                }
                                                if (this.canActivateAR) this[BA].classList.add("enabled"), this[BA].addEventListener("click", this[UA]);
                                                else if (this[BA].classList.contains("enabled")) {
                                                    this[BA].removeEventListener("click", this[UA]), this[BA].classList.remove("enabled");
                                                    const t = "failed";
                                                    this.setAttribute("ar-status", t), this.dispatchEvent(new CustomEvent("ar-status", { detail: { status: t } }));
                                                }
                                            }
                                            async [TA]() {
                                                await this[VA]();
                                                try {
                                                    this[BA].removeEventListener("click", this[UA]);
                                                    const { arRenderer: t } = this[sp];
                                                    (t.placeOnWall = "wall" === this.arPlacement), await t.present(this[$d], this.xrEnvironment);
                                                } catch (t) {
                                                    await this[sp].arRenderer.stopPresenting(), (wA = !0), await this[zA](), this.activateAR();
                                                } finally {
                                                    this[zA]();
                                                }
                                            }
                                            async [VA]() {
                                                this.loaded ||
                                                    ((this[FA] = !0),
                                                    this[Yd](),
                                                    await ((t, e, i = null) =>
                                                        new Promise((n) => {
                                                            t.addEventListener(e, function s(r) {
                                                                (i && !i(r)) || (n(r), t.removeEventListener(e, s));
                                                            });
                                                        }))(
                                                        /* @license
                                                         * Copyright 2020 Google LLC. All Rights Reserved.
                                                         * Licensed under the Apache License, Version 2.0 (the 'License');
                                                         * you may not use this file except in compliance with the License.
                                                         * You may obtain a copy of the License at
                                                         *
                                                         *     http://www.apache.org/licenses/LICENSE-2.0
                                                         *
                                                         * Unless required by applicable law or agreed to in writing, software
                                                         * distributed under the License is distributed on an 'AS IS' BASIS,
                                                         * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                         * See the License for the specific language governing permissions and
                                                         * limitations under the License.
                                                         */ this,
                                                        "load",
                                                    ),
                                                    (this[FA] = !1));
                                            }
                                            [lp]() {
                                                return super[lp]() || this[FA];
                                            }
                                            [LA]() {
                                                const t = self.location.toString(),
                                                    e = new URL(t),
                                                    i = new URL(this.src, t),
                                                    n = new URLSearchParams(i.search);
                                                if (((e.hash = "#model-viewer-no-ar-fallback"), n.set("mode", "ar_preferred"), n.has("disable_occlusion") || n.set("disable_occlusion", "true"), "fixed" === this.arScale && n.set("resizable", "false"), "wall" === this.arPlacement && n.set("enable_vertical_placement", "true"), n.has("sound"))) {
                                                    const e = new URL(n.get("sound"), t);
                                                    n.set("sound", e.toString());
                                                }
                                                if (n.has("link")) {
                                                    const e = new URL(n.get("link"), t);
                                                    n.set("link", e.toString());
                                                }
                                                const s = `intent://arvr.google.com/scene-viewer/1.0?${n.toString() + "&file=" + encodeURIComponent(i.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(e.toString())};end;`;
                                                self.addEventListener(
                                                    "hashchange",
                                                    () => {
                                                        "#model-viewer-no-ar-fallback" === self.location.hash && ((_A = !0), self.history.back(), this[zA]());
                                                    },
                                                    { once: !0 },
                                                ),
                                                    this[NA].setAttribute("href", s),
                                                    this[NA].click();
                                            }
                                            async [DA]() {
                                                const t = !this.iosSrc;
                                                this[BA].classList.remove("enabled");
                                                const e = t ? await this.prepareUSDZ() : this.iosSrc,
                                                    i = new URL(e, self.location.toString());
                                                "fixed" === this.arScale && (i.hash && (i.hash += "&"), (i.hash += "allowsContentScaling=0"));
                                                const n = this[NA];
                                                n.setAttribute("rel", "ar");
                                                const s = document.createElement("img");
                                                n.appendChild(s), n.setAttribute("href", i.toString()), t && n.setAttribute("download", "model.usdz"), n.click(), n.removeChild(s), t && URL.revokeObjectURL(e), this[BA].classList.add("enabled");
                                            }
                                            async prepareUSDZ() {
                                                const t = this[rp].beginActivity();
                                                await this[VA]();
                                                const e = this[$d],
                                                    i = e.shadow;
                                                let n = !1;
                                                null != i && ((n = i.visible), (i.visible = !1)), t(0.2);
                                                const s = new pA(),
                                                    r = await s.parse(e.modelContainer),
                                                    a = new Blob([r], { type: "model/vnd.usdz+zip" }),
                                                    o = URL.createObjectURL(a);
                                                return t(1), null != i && (i.visible = n), o;
                                            }
                                        }
                                        return xA([k({ type: Boolean, attribute: "ar" })], u.prototype, "ar", void 0), xA([k({ type: String, attribute: "ar-scale" })], u.prototype, "arScale", void 0), xA([k({ type: String, attribute: "ar-placement" })], u.prototype, "arPlacement", void 0), xA([k({ type: String, attribute: "ar-modes" })], u.prototype, "arModes", void 0), xA([k({ type: String, attribute: "ios-src" })], u.prototype, "iosSrc", void 0), xA([k({ type: Boolean, attribute: "xr-environment" })], u.prototype, "xrEnvironment", void 0), u;
                                    })(
                                        ((t) => {
                                            var e, i, n, s, r, a, o, l, c, h, u, d, p;
                                            class A extends t {
                                                constructor(...t) {
                                                    super(...t),
                                                        (this.poster = null),
                                                        (this.reveal = Rm),
                                                        (this.loading = "auto"),
                                                        (this[e] = !1),
                                                        (this[i] = !1),
                                                        (this[n] = 0),
                                                        (this[s] = null),
                                                        (this[r] = this.shadowRoot.querySelector(".slot.poster")),
                                                        (this[a] = this.shadowRoot.querySelector("#default-poster")),
                                                        (this[o] = this.shadowRoot.querySelector("#default-progress-bar > .bar")),
                                                        (this[l] = this.shadowRoot.querySelector("#default-progress-bar > .mask")),
                                                        (this[c] = this[Om].getAttribute("aria-label")),
                                                        (this[h] = ((t) => {
                                                            let e = null;
                                                            const i = (...i) => {
                                                                null == e && (t(...i), (e = self.setTimeout(() => (e = null), 100)));
                                                            };
                                                            return (
                                                                (i.flush = () => {
                                                                    null != e && (self.clearTimeout(e), (e = null));
                                                                }),
                                                                i
                                                            );
                                                        })((t) => {
                                                            const e = this[Fm].parentNode;
                                                            requestAnimationFrame(() => {
                                                                (this[Um].style.opacity = "" + 0.2 * (1 - t)), (this[Fm].style.transform = `scaleX(${t})`), 0 === t && (e.removeChild(this[Fm]), e.appendChild(this[Fm])), 1 === t ? this[Fm].classList.add("hide") : this[Fm].classList.remove("hide");
                                                            });
                                                        })),
                                                        (this[u] = () => {
                                                            this.reveal !== Pm && this.dismissPoster();
                                                        }),
                                                        (this[d] = (t) => {
                                                            if (this.reveal !== Pm)
                                                                switch (t.keyCode) {
                                                                    case 32:
                                                                    case 13:
                                                                        this.dismissPoster();
                                                                }
                                                        }),
                                                        (this[p] = (t) => {
                                                            const e = t.detail.totalProgress;
                                                            (this[Wm] = Math.max(e, this[Wm])), 1 === e && (this[Hm].flush(), !this[cp]() || (null == this[Gm] && this.reveal !== Rm) || this[zm]()), this[Hm](e), this.dispatchEvent(new CustomEvent("progress", { detail: { totalProgress: e } }));
                                                        });
                                                    const A = self.ModelViewerElement || {},
                                                        g = A.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.3.6/";
                                                    Sh.setDRACODecoderLocation(g);
                                                    const m = A.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
                                                    Sh.setKTX2TranscoderLocation(m);
                                                }
                                                static set dracoDecoderLocation(t) {
                                                    Sh.setDRACODecoderLocation(t);
                                                }
                                                static get dracoDecoderLocation() {
                                                    return Sh.getDRACODecoderLocation();
                                                }
                                                static set ktx2TranscoderLocation(t) {
                                                    Sh.setKTX2TranscoderLocation(t);
                                                }
                                                static get ktx2TranscoderLocation() {
                                                    return Sh.getKTX2TranscoderLocation();
                                                }
                                                static mapURLs(t) {
                                                    md.singleton.loader[Mh].manager.setURLModifier(t);
                                                }
                                                dismissPoster() {
                                                    this[cp]() ? this[zm]() : ((this[Gm] = "interaction"), this[Yd]());
                                                }
                                                showPoster() {
                                                    const t = this[km],
                                                        e = this[Om];
                                                    e.removeAttribute("tabindex"), e.removeAttribute("aria-hidden"), t.classList.add("show");
                                                    const i = this.modelIsVisible;
                                                    (this[Vm] = !1), this[Wd](i), (this[qm] = !1);
                                                }
                                                getDimensions() {
                                                    return up(this[$d].size);
                                                }
                                                connectedCallback() {
                                                    super.connectedCallback(), this[km].addEventListener("click", this[Ym]), this[km].addEventListener("keydown", this[Jm]), this[rp].addEventListener("progress", this[Xm]), Nm.registerInstance(this);
                                                }
                                                disconnectedCallback() {
                                                    super.disconnectedCallback(), this[km].removeEventListener("click", this[Ym]), this[km].removeEventListener("keydown", this[Jm]), this[rp].removeEventListener("progress", this[Xm]), Nm.unregisterInstance(this);
                                                }
                                                async updated(t) {
                                                    super.updated(t), t.has("poster") && null != this.poster && (this[Om].style.backgroundImage = `url(${this.poster})`), t.has("alt") && this[Om].setAttribute("aria-label", `${this[qd]}. ${this[jm]}`), (t.has("reveal") || t.has("loading")) && this[Yd]();
                                                }
                                                [((e = Vm), (i = qm), (n = Wm), (s = Gm), (r = km), (a = Om), (o = Fm), (l = Um), (c = jm), (h = Hm), (u = Ym), (d = Jm), (p = Xm), lp)]() {
                                                    return !!this.src && (null != this[Gm] || "eager" === this.loading || (this.reveal === Rm && this[Hd]));
                                                }
                                                [cp]() {
                                                    const { src: t } = this;
                                                    return !!t && super[cp]() && 1 === this[Wm];
                                                }
                                                [zm]() {
                                                    this[Gm] = null;
                                                    const t = this[km],
                                                        e = this[Om];
                                                    if (t.classList.contains("show")) {
                                                        t.classList.remove("show");
                                                        const i = this.modelIsVisible;
                                                        (this[Vm] = !0),
                                                            this[Wd](i),
                                                            t.addEventListener(
                                                                "transitionend",
                                                                () => {
                                                                    requestAnimationFrame(() => {
                                                                        this[qm] = !0;
                                                                        const t = this.getRootNode();
                                                                        t && t.activeElement === this && this[Kd].focus(), e.setAttribute("aria-hidden", "true"), (e.tabIndex = -1), this.dispatchEvent(new CustomEvent("poster-dismissed"));
                                                                    });
                                                                },
                                                                { once: !0 },
                                                            );
                                                    }
                                                }
                                                [op]() {
                                                    return super[op]() && this[Vm];
                                                }
                                                [hp]() {
                                                    return super[hp]() && this[qm];
                                                }
                                                async [Yd]() {
                                                    (this[Wm] = 0), (null != this[$d].currentGLTF && null != this.src && this[lp]()) || this.showPoster(), await super[Yd]();
                                                }
                                            }
                                            return Qm([k({ type: String })], A.prototype, "poster", void 0), Qm([k({ type: String })], A.prototype, "reveal", void 0), Qm([k({ type: String })], A.prototype, "loading", void 0), A;
                                        })(
                                            ((t) => {
                                                var e;
                                                class i extends t {
                                                    constructor() {
                                                        super(...arguments), (this.autoplay = !1), (this.animationName = void 0), (this.animationCrossfadeDuration = 300), (this[e] = !0);
                                                    }
                                                    get availableAnimations() {
                                                        return this.loaded ? this[$d].animationNames : [];
                                                    }
                                                    get duration() {
                                                        return this[$d].duration;
                                                    }
                                                    get paused() {
                                                        return this[gp];
                                                    }
                                                    get currentTime() {
                                                        return this[$d].animationTime;
                                                    }
                                                    set currentTime(t) {
                                                        (this[$d].animationTime = t), (this[sp].threeRenderer.shadowMap.needsUpdate = !0), this[tp]();
                                                    }
                                                    pause() {
                                                        this[gp] || ((this[gp] = !0), (this[sp].threeRenderer.shadowMap.autoUpdate = !1), this.dispatchEvent(new CustomEvent("pause")));
                                                    }
                                                    play() {
                                                        this[gp] && this.availableAnimations.length > 0 && ((this[gp] = !1), (this[sp].threeRenderer.shadowMap.autoUpdate = !0), this[$d].hasActiveAnimation || this[Ap](), this.dispatchEvent(new CustomEvent("play")));
                                                    }
                                                    [((e = gp), ip)]() {
                                                        super[ip](), (this[gp] = !0), this.autoplay && (this[Ap](), this.play());
                                                    }
                                                    [ep](t, e) {
                                                        super[ep](t, e), this[gp] || (!this[hp]() && !this[sp].isPresenting) || (this[$d].updateAnimation(e / 1e3), this[tp]());
                                                    }
                                                    updated(t) {
                                                        super.updated(t), t.has("autoplay") && this.autoplay && this.play(), t.has("animationName") && this[Ap]();
                                                    }
                                                    async [Yd]() {
                                                        return this[$d].stopAnimation(), super[Yd]();
                                                    }
                                                    [Ap]() {
                                                        this[$d].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3), this[gp] && (this[$d].updateAnimation(0), this[tp]());
                                                    }
                                                }
                                                return pp([k({ type: Boolean })], i.prototype, "autoplay", void 0), pp([k({ type: String, attribute: "animation-name" })], i.prototype, "animationName", void 0), pp([k({ type: Number, attribute: "animation-crossfade-duration" })], i.prototype, "animationCrossfadeDuration", void 0), i;
                                            })(
                                                ((t) => {
                                                    var e;
                                                    const i = Symbol("endPolyfillCoordination");
                                                    return (
                                                        (e = i),
                                                        class extends t {
                                                            constructor() {
                                                                super(...arguments), (this[e] = null);
                                                            }
                                                            connectedCallback() {
                                                                super.connectedCallback && super.connectedCallback(),
                                                                    null == this[i] &&
                                                                        (this[i] = ((t) => {
                                                                            if (null == t.shadowRoot || t.hasAttribute("data-js-focus-visible")) return () => {};
                                                                            if (!self.applyFocusVisiblePolyfill) {
                                                                                const e = () => {
                                                                                    self.applyFocusVisiblePolyfill(t.shadowRoot);
                                                                                };
                                                                                return (
                                                                                    self.addEventListener("focus-visible-polyfill-ready", e, { once: !0 }),
                                                                                    () => {
                                                                                        self.removeEventListener("focus-visible-polyfill-ready", e);
                                                                                    }
                                                                                );
                                                                            }
                                                                            return self.applyFocusVisiblePolyfill(t.shadowRoot), () => {};
                                                                        })(this));
                                                            }
                                                            disconnectedCallback() {
                                                                super.disconnectedCallback && super.disconnectedCallback(), null != this[i] && (this[i](), (this[i] = null));
                                                            }
                                                        }
                                                    );
                                                })(dp),
                                            ),
                                        ),
                                    ),
                                ),
                            ),
                        ),
                    ),
                );
            customElements.define("model-viewer", fv);
        },
    },
]);
//# sourceMappingURL=https://ton.local.twitter.com/responsive-web-internal/sourcemaps/client-web/ondemand.ModelViewer.301f3aba.js.map
